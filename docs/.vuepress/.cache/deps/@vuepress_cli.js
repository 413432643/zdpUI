import {
  assert_exports,
  child_process_exports,
  events_exports,
  fs_exports,
  init_assert,
  init_child_process,
  init_events,
  init_fs,
  init_os,
  init_path,
  init_stream,
  init_util,
  os_exports,
  path_exports,
  require_dist,
  require_is_glob,
  require_lib,
  require_main,
  require_picomatch,
  stream_exports,
  util_exports
} from "./chunk-Q4NZ5EX6.js";
import "./chunk-UIUCX46I.js";
import {
  __commonJS,
  __esm,
  __export,
  __objRest,
  __require,
  __spreadProps,
  __spreadValues,
  __toCommonJS,
  init_define_EXTERNAL_LINK_ICON_LOCALES,
  init_define_MZ_ZOOM_OPTIONS
} from "./chunk-6P7BTK63.js";

// node_modules/@vuepress/core/lib/app/prepare/prepareClientConfigs.js
var require_prepareClientConfigs = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/prepareClientConfigs.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareClientConfigs = void 0;
    var prepareClientConfigs = async (app) => {
      const clientConfigFiles = await app.pluginApi.hooks.clientConfigFile.process(app);
      const content = `${clientConfigFiles.map((filePath, index) => `import clientConfig${index} from '${filePath}'`).join("\n")}

export const clientConfigs = [
${clientConfigFiles.map((_, index) => `  clientConfig${index},`).join("\n")}
]
`;
      await app.writeTemp("internal/clientConfigs.js", content);
    };
    exports2.prepareClientConfigs = prepareClientConfigs;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/prepareLayoutComponents.js
var require_prepareLayoutComponents = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/prepareLayoutComponents.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareLayoutComponents = void 0;
    var prepareLayoutComponents = async (app) => {
      const content = `import { defineAsyncComponent } from 'vue'

export const layoutComponents = {${Object.entries(app.layouts).map(([name, path]) => `
  ${JSON.stringify(name)}: defineAsyncComponent(() => import(${app.env.isDebug ? `/* webpackChunkName: "layout-${name}" */` : ""}${JSON.stringify(path)})),`).join("")}
}
`;
      await app.writeTemp("internal/layoutComponents.js", content);
    };
    exports2.prepareLayoutComponents = prepareLayoutComponents;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/preparePageComponent.js
var require_preparePageComponent = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/preparePageComponent.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preparePageComponent = void 0;
    var preparePageComponent = async (app, page) => {
      await app.writeTemp(page.componentFilePathRelative, [
        `<template><div>${page.contentRendered}</div></template>
`,
        ...page.hoistedTags
      ].join("\n"));
    };
    exports2.preparePageComponent = preparePageComponent;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/preparePageData.js
var require_preparePageData = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/preparePageData.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preparePageData = void 0;
    var HMR_CODE = `
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
`;
    var preparePageData = async (app, page) => {
      let content = `export const data = ${JSON.stringify(page.data, null, 2)}
`;
      if (app.env.isDev) {
        content += HMR_CODE;
      }
      await app.writeTemp(page.dataFilePathRelative, content);
    };
    exports2.preparePageData = preparePageData;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/preparePagesComponents.js
var require_preparePagesComponents = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/preparePagesComponents.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preparePagesComponents = void 0;
    var preparePagesComponents = async (app) => {
      const content = `import { defineAsyncComponent } from 'vue'

export const pagesComponents = {${app.pages.map(({ key, path, componentFilePath, componentFileChunkName }) => `
  // path: ${path}
  ${JSON.stringify(key)}: defineAsyncComponent(() => import(${componentFileChunkName ? `/* webpackChunkName: "${componentFileChunkName}" */` : ""}${JSON.stringify(componentFilePath)})),`).join("")}
}
`;
      await app.writeTemp("internal/pagesComponents.js", content);
    };
    exports2.preparePagesComponents = preparePagesComponents;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/preparePagesData.js
var require_preparePagesData = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/preparePagesData.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preparePagesData = void 0;
    var preparePagesData = async (app) => {
      const content = `export const pagesData = {${app.pages.map(({ key, path, dataFilePath, dataFileChunkName }) => `
  // path: ${path}
  ${JSON.stringify(key)}: () => import(${dataFileChunkName ? `/* webpackChunkName: "${dataFileChunkName}" */` : ""}${JSON.stringify(dataFilePath)}).then(({ data }) => data),`).join("")}
}
`;
      await app.writeTemp("internal/pagesData.js", content);
    };
    exports2.preparePagesData = preparePagesData;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/preparePagesRoutes.js
var require_preparePagesRoutes = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/preparePagesRoutes.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preparePagesRoutes = void 0;
    var shared_1 = require_dist();
    var transformPageToRouteItem = ({ key, path, pathInferred, filePathRelative, routeMeta }) => {
      const redirectsSet = /* @__PURE__ */ new Set();
      redirectsSet.add(decodeURI(path));
      if (path.endsWith("/")) {
        redirectsSet.add(path + "index.html");
      } else {
        redirectsSet.add(path.replace(/.html$/, ""));
      }
      if (pathInferred !== null) {
        redirectsSet.add(pathInferred);
        redirectsSet.add(encodeURI(pathInferred));
      }
      if (filePathRelative !== null) {
        const filenamePath = (0, shared_1.ensureLeadingSlash)(filePathRelative);
        redirectsSet.add(filenamePath);
        redirectsSet.add(encodeURI(filenamePath));
      }
      redirectsSet.delete(path);
      return [key, path, routeMeta, [...redirectsSet]];
    };
    var preparePagesRoutes = async (app) => {
      const routeItems = app.pages.map(transformPageToRouteItem);
      const content = `import { Vuepress } from '@vuepress/client'

const routeItems = [${routeItems.map((routeItem) => `
  ${JSON.stringify(routeItem)},`).join("")}
]

export const pagesRoutes = routeItems.reduce(
  (result, [name, path, meta, redirects]) => {
    result.push(
      {
        name,
        path,
        component: Vuepress,
        meta,
      },
      ...redirects.map((item) => ({
        path: item,
        redirect: path,
      }))
    )
    return result
  },
  [
    {
      name: '404',
      path: '/:catchAll(.*)',
      component: Vuepress,
    }
  ]
)
`;
      await app.writeTemp("internal/pagesRoutes.js", content);
    };
    exports2.preparePagesRoutes = preparePagesRoutes;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/prepareSiteData.js
var require_prepareSiteData = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/prepareSiteData.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareSiteData = void 0;
    var HMR_CODE = `
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updateSiteData) {
    __VUE_HMR_RUNTIME__.updateSiteData(siteData)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ siteData }) => {
    __VUE_HMR_RUNTIME__.updateSiteData(siteData)
  })
}
`;
    var prepareSiteData = async (app) => {
      let content = `export const siteData = ${JSON.stringify(app.siteData, null, 2)}
`;
      if (app.env.isDev) {
        content += HMR_CODE;
      }
      await app.writeTemp("internal/siteData.js", content);
    };
    exports2.prepareSiteData = prepareSiteData;
  }
});

// node_modules/@vuepress/core/lib/app/prepare/index.js
var require_prepare = __commonJS({
  "node_modules/@vuepress/core/lib/app/prepare/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_prepareClientConfigs(), exports2);
    __exportStar(require_prepareLayoutComponents(), exports2);
    __exportStar(require_preparePageComponent(), exports2);
    __exportStar(require_preparePageData(), exports2);
    __exportStar(require_preparePagesComponents(), exports2);
    __exportStar(require_preparePagesData(), exports2);
    __exportStar(require_preparePagesRoutes(), exports2);
    __exportStar(require_prepareSiteData(), exports2);
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports2, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i2, l2, code, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i2 = 0, l2 = string.length; i2 < l2; i2++) {
        code = string.charCodeAt(i2);
        if (keepEscaped && code === 37 && i2 + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
            result += string.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i2 + 1 < l2) {
            nextCode = string.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i2] + string[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i2]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module2.exports = encode;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i2, l2, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l2 = seq.length; i2 < l2; i2 += 3) {
          b1 = parseInt(seq.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module2.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function format(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u2 = new Url();
      u2.parse(url, slashesDenoteHost);
      return u2;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i2, l2, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module2.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports.encode = require_encode();
    module2.exports.decode = require_decode();
    module2.exports.format = require_format();
    module2.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    exports2.Any = require_regex2();
    exports2.Cc = require_regex3();
    exports2.Cf = require_regex4();
    exports2.P = require_regex();
    exports2.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c2) {
      if (c2 >= 55296 && c2 <= 57343) {
        return false;
      }
      if (c2 >= 64976 && c2 <= 65007) {
        return false;
      }
      if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
        return false;
      }
      if (c2 >= 0 && c2 <= 8) {
        return false;
      }
      if (c2 === 11) {
        return false;
      }
      if (c2 >= 14 && c2 <= 31) {
        return false;
      }
      if (c2 >= 127 && c2 <= 159) {
        return false;
      }
      if (c2 > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c2) {
      if (c2 > 65535) {
        c2 -= 65536;
        var surrogate1 = 55296 + (c2 >> 10), surrogate2 = 56320 + (c2 & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c2);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name) {
      var code = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str2) {
      if (str2.indexOf("\\") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str2) {
      if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str2) {
      if (HTML_ESCAPE_TEST_RE.test(str2)) {
        return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str2;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str2) {
      return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str2) {
      str2 = str2.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str2 = str2.replace(/ẞ/g, "\xDF");
      }
      return str2.toLowerCase().toUpperCase();
    }
    exports2.lib = {};
    exports2.lib.mdurl = require_mdurl();
    exports2.lib.ucmicro = require_uc();
    exports2.assign = assign;
    exports2.isString = isString;
    exports2.has = has;
    exports2.unescapeMd = unescapeMd;
    exports2.unescapeAll = unescapeAll;
    exports2.isValidEntityCode = isValidEntityCode;
    exports2.fromCodePoint = fromCodePoint;
    exports2.escapeHtml = escapeHtml;
    exports2.arrayReplaceAt = arrayReplaceAt;
    exports2.isSpace = isSpace;
    exports2.isWhiteSpace = isWhiteSpace;
    exports2.isMdAsciiPunct = isMdAsciiPunct;
    exports2.isPunctChar = isPunctChar;
    exports2.escapeRE = escapeRE;
    exports2.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkDestination(str2, pos, max) {
      var code, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str2.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str2.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str2.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str2.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str2.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkTitle(str2, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str2.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str2.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    exports2.parseLinkLabel = require_parse_link_label();
    exports2.parseLinkDestination = require_parse_link_destination();
    exports2.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options2, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options2, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options2, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options2.highlight) {
        highlighted = options2.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i2 = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options2.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options2.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options2, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options2, env);
      return slf.renderToken(tokens, idx, options2);
    };
    default_rules.hardbreak = function(tokens, idx, options2) {
      return options2.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options2) {
      return options2.breaks ? options2.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i2, l2, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l2 = token.attrs.length; i2 < l2; i2++) {
        result += " " + escapeHtml(token.attrs[i2][0]) + '="' + escapeHtml(token.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options2) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options2.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options2, env) {
      var type, result = "", rules = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i2, options2, env, this);
        } else {
          result += this.renderToken(tokens, i2, options2);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options2, env) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options2, env);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options2, env) {
      var i2, len, type, result = "", rules = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i2].children, options2, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i2].type](tokens, i2, options2, env, this);
        } else {
          result += this.renderToken(tokens, i2, options2, env);
        }
      }
      return result;
    };
    module2.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name) {
          return i2;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options2) {
      var index = this.__find__(name);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options2) {
      var index = this.__find__(beforeName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options2) {
      var index = this.__find__(afterName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options2) {
      var opt = options2 || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize(state) {
      var str2;
      str2 = state.src.replace(NEWLINES_RE, "\n");
      str2 = str2.replace(NULL_RE, "\uFFFD");
      state.src = str2;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i2, l2;
      for (i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    module2.exports = function linkify(state) {
      var i2, j, l2, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str2, index, ch) {
      return str2.slice(0, index) + ch + str2.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i2, token, text, t2, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t2 = QUOTE_RE.exec(text);
            if (!t2) {
              break;
            }
            canOpen = canClose = true;
            pos = t2.index + 1;
            isSingle = t2[0] === "'";
            lastChar = 32;
            if (t2.index - 1 >= 0) {
              lastChar = text.charCodeAt(t2.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t2[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t2.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t2.index, closeQuote);
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i2,
                pos: t2.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/markdown-it/lib/rules_core/text_join.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function text_join(state) {
      var j, l2, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name) {
          return i2;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module2.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i2, l2, rules;
      rules = this.ruler.getRules("");
      for (i2 = 0, l2 = rules.length; i2 < l2; i2++) {
        rules[i2](state);
      }
    };
    Core.prototype.State = require_state_core();
    module2.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str2) {
      var result = [], pos = 0, max = str2.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str2.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str2.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str2.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str2.charCodeAt(pos);
      }
      result.push(current + str2.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l2, nextLine, columns, columnCount, token, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t2 = columns[i2].trim();
        if (!t2) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t2)) {
          return false;
        }
        if (t2.charCodeAt(t2.length - 1) === 58) {
          aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t2.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i2]) {
          token.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i2].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i2]) {
            token.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i2] ? columns[i2].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l2, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state.bMarks[i2 + startLine] = oldBMarks[i2];
        state.tShift[i2 + startLine] = oldTShift[i2];
        state.sCount[i2 + startLine] = oldSCount[i2];
        state.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i2, l2, level = state.level + 2;
      for (i2 = idx + 2, l2 = state.tokens.length - 2; i2 < l2; i2++) {
        if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
          state.tokens[i2 + 2].hidden = true;
          state.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i2, indent, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l2, label, labelEnd, oldParentType, res, start, str2, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str2.length;
      for (pos = 1; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str2, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str2, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str2.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str2.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str2.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i2, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i2, l2, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function paragraph(state, startLine) {
      var content, terminate, i2, l2, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Token = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s2, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s2 = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s2.length; pos < len; pos++) {
        ch = s2.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s2.length);
      this.eMarks.push(s2.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i2, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i2] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module2.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1], { alt: (_rules[i2][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i2, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i2 = 0; i2 < len; i2++) {
          ok = rules[i2](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module2.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/linkify.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module2.exports = function linkify(state, silent) {
      var pos, max, match, proto, link, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link)
        return false;
      url = link.url;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i2 = 0; i2 < 256; i2++) {
      ESCAPED.push(0);
    }
    var i2;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i2, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i2 = 0; i2 < max; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i2];
          state.tokens[i2] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports.tokenize = function emphasis(state, silent) {
      var i2, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i2 = max - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i2 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match[1]];
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function fragments_join(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module2.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i2, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state.level++;
          ok = rules[i2](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i2, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok = rules[i2](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str2, md, env, outTokens) {
      var i2, rules, len;
      var state = new this.State(str2, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i2 = 0; i2 < len; i2++) {
        rules[i2](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module2.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options2) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options2);
      }
      if (!options2) {
        if (isOptionsObj(schemas)) {
          options2 = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options2);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options2) {
      this.__opts__ = assign(this.__opts__, options2);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// browser-external:punycode
var punycode_exports = {};
__export(punycode_exports, {
  default: () => punycode_default
});
var punycode_default;
var init_punycode = __esm({
  "browser-external:punycode"() {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    punycode_default = new Proxy({}, {
      get() {
        throw new Error('Module "punycode" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = (init_punycode(), __toCommonJS(punycode_exports));
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str2 = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options2) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options2);
      }
      if (!options2) {
        if (!utils.isString(presetName)) {
          options2 = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options2) {
        this.set(options2);
      }
    }
    MarkdownIt.prototype.set = function(options2) {
      utils.assign(this.options, options2);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = require_lib2();
  }
});

// node_modules/markdown-it-anchor/dist/markdownItAnchor.mjs
var markdownItAnchor_exports = {};
__export(markdownItAnchor_exports, {
  default: () => markdownItAnchor_default
});
function r(r2, a2, i2, l2) {
  var o2;
  if (!e) {
    var c2 = "Using deprecated markdown-it-anchor permalink option, see https://github.com/valeriangalliat/markdown-it-anchor#todo-anchor-or-file";
    typeof process == "object" && process && process.emitWarning ? process.emitWarning(c2) : console.warn(c2), e = true;
  }
  var s2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: [].concat(a2.permalinkClass ? [["class", a2.permalinkClass]] : [], [["href", a2.permalinkHref(r2, i2)]], Object.entries(a2.permalinkAttrs(r2, i2))) }), Object.assign(new i2.Token("html_block", "", 0), { content: a2.permalinkSymbol, meta: t }), new i2.Token("link_close", "a", -1)];
  a2.permalinkSpace && i2.tokens[l2 + 1].children[n[a2.permalinkBefore]](Object.assign(new i2.Token("text", "", 0), { content: " " })), (o2 = i2.tokens[l2 + 1].children)[n[a2.permalinkBefore]].apply(o2, s2);
}
function a(e2) {
  return "#" + e2;
}
function i(e2) {
  return {};
}
function o(e2) {
  function n2(t2) {
    return t2 = Object.assign({}, n2.defaults, t2), function(n3, r2, a2, i2) {
      return e2(n3, t2, r2, a2, i2);
    };
  }
  return n2.defaults = Object.assign({}, l), n2.renderPermalinkImpl = e2, n2;
}
function f(e2, n2, t2, r2) {
  var a2 = e2, i2 = r2;
  if (t2 && Object.prototype.hasOwnProperty.call(n2, a2))
    throw new Error("User defined `id` attribute `" + e2 + "` is not unique. Please fix it in your Markdown to continue.");
  for (; Object.prototype.hasOwnProperty.call(n2, a2); )
    a2 = e2 + "-" + i2, i2 += 1;
  return n2[a2] = true, a2;
}
function b(e2, n2) {
  n2 = Object.assign({}, b.defaults, n2), e2.core.ruler.push("anchor", function(e3) {
    for (var t2, a2 = {}, i2 = e3.tokens, l2 = Array.isArray(n2.level) ? (t2 = n2.level, function(e4) {
      return t2.includes(e4);
    }) : function(e4) {
      return function(n3) {
        return n3 >= e4;
      };
    }(n2.level), o2 = 0; o2 < i2.length; o2++) {
      var c2 = i2[o2];
      if (c2.type === "heading_open" && l2(Number(c2.tag.substr(1)))) {
        var s2 = n2.getTokensText(i2[o2 + 1].children), u2 = c2.attrGet("id");
        u2 = u2 == null ? f(n2.slugify(s2), a2, false, n2.uniqueSlugStartIndex) : f(u2, a2, true, n2.uniqueSlugStartIndex), c2.attrSet("id", u2), n2.tabIndex !== false && c2.attrSet("tabindex", "" + n2.tabIndex), typeof n2.permalink == "function" ? n2.permalink(u2, n2, e3, o2) : (n2.permalink || n2.renderPermalink && n2.renderPermalink !== r) && n2.renderPermalink(u2, n2, e3, o2), o2 = i2.indexOf(c2), n2.callback && n2.callback(c2, { slug: u2, title: s2 });
      }
    }
  });
}
var e, n, t, l, c, s, u, d, markdownItAnchor_default;
var init_markdownItAnchor = __esm({
  "node_modules/markdown-it-anchor/dist/markdownItAnchor.mjs"() {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    e = false;
    n = { false: "push", true: "unshift", after: "push", before: "unshift" };
    t = { isPermalinkSymbol: true };
    l = { class: "header-anchor", symbol: "#", renderHref: a, renderAttrs: i };
    c = o(function(e2, r2, a2, i2, l2) {
      var o2, c2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: [].concat(r2.class ? [["class", r2.class]] : [], [["href", r2.renderHref(e2, i2)]], r2.ariaHidden ? [["aria-hidden", "true"]] : [], Object.entries(r2.renderAttrs(e2, i2))) }), Object.assign(new i2.Token("html_inline", "", 0), { content: r2.symbol, meta: t }), new i2.Token("link_close", "a", -1)];
      if (r2.space) {
        var s2 = typeof r2.space == "string" ? r2.space : " ";
        i2.tokens[l2 + 1].children[n[r2.placement]](Object.assign(new i2.Token(typeof r2.space == "string" ? "html_inline" : "text", "", 0), { content: s2 }));
      }
      (o2 = i2.tokens[l2 + 1].children)[n[r2.placement]].apply(o2, c2);
    });
    Object.assign(c.defaults, { space: true, placement: "after", ariaHidden: false });
    s = o(c.renderPermalinkImpl);
    s.defaults = Object.assign({}, c.defaults, { ariaHidden: true });
    u = o(function(e2, n2, t2, r2, a2) {
      var i2 = [Object.assign(new r2.Token("link_open", "a", 1), { attrs: [].concat(n2.class ? [["class", n2.class]] : [], [["href", n2.renderHref(e2, r2)]], Object.entries(n2.renderAttrs(e2, r2))) })].concat(n2.safariReaderFix ? [new r2.Token("span_open", "span", 1)] : [], r2.tokens[a2 + 1].children, n2.safariReaderFix ? [new r2.Token("span_close", "span", -1)] : [], [new r2.Token("link_close", "a", -1)]);
      r2.tokens[a2 + 1] = Object.assign(new r2.Token("inline", "", 0), { children: i2 });
    });
    Object.assign(u.defaults, { safariReaderFix: false });
    d = o(function(e2, r2, a2, i2, l2) {
      var o2;
      if (!["visually-hidden", "aria-label", "aria-describedby", "aria-labelledby"].includes(r2.style))
        throw new Error("`permalink.linkAfterHeader` called with unknown style option `" + r2.style + "`");
      if (!["aria-describedby", "aria-labelledby"].includes(r2.style) && !r2.assistiveText)
        throw new Error("`permalink.linkAfterHeader` called without the `assistiveText` option in `" + r2.style + "` style");
      if (r2.style === "visually-hidden" && !r2.visuallyHiddenClass)
        throw new Error("`permalink.linkAfterHeader` called without the `visuallyHiddenClass` option in `visually-hidden` style");
      var c2 = i2.tokens[l2 + 1].children.filter(function(e3) {
        return e3.type === "text" || e3.type === "code_inline";
      }).reduce(function(e3, n2) {
        return e3 + n2.content;
      }, ""), s2 = [], u2 = [];
      if (r2.class && u2.push(["class", r2.class]), u2.push(["href", r2.renderHref(e2, i2)]), u2.push.apply(u2, Object.entries(r2.renderAttrs(e2, i2))), r2.style === "visually-hidden") {
        if (s2.push(Object.assign(new i2.Token("span_open", "span", 1), { attrs: [["class", r2.visuallyHiddenClass]] }), Object.assign(new i2.Token("text", "", 0), { content: r2.assistiveText(c2) }), new i2.Token("span_close", "span", -1)), r2.space) {
          var d2 = typeof r2.space == "string" ? r2.space : " ";
          s2[n[r2.placement]](Object.assign(new i2.Token(typeof r2.space == "string" ? "html_inline" : "text", "", 0), { content: d2 }));
        }
        s2[n[r2.placement]](Object.assign(new i2.Token("span_open", "span", 1), { attrs: [["aria-hidden", "true"]] }), Object.assign(new i2.Token("html_inline", "", 0), { content: r2.symbol, meta: t }), new i2.Token("span_close", "span", -1));
      } else
        s2.push(Object.assign(new i2.Token("html_inline", "", 0), { content: r2.symbol, meta: t }));
      r2.style === "aria-label" ? u2.push(["aria-label", r2.assistiveText(c2)]) : ["aria-describedby", "aria-labelledby"].includes(r2.style) && u2.push([r2.style, e2]);
      var f2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: u2 })].concat(s2, [new i2.Token("link_close", "a", -1)]);
      (o2 = i2.tokens).splice.apply(o2, [l2 + 3, 0].concat(f2)), r2.wrapper && (i2.tokens.splice(l2, 0, Object.assign(new i2.Token("html_block", "", 0), { content: r2.wrapper[0] + "\n" })), i2.tokens.splice(l2 + 3 + f2.length + 1, 0, Object.assign(new i2.Token("html_block", "", 0), { content: r2.wrapper[1] + "\n" })));
    });
    Object.assign(d.defaults, { style: "visually-hidden", space: true, placement: "after", wrapper: null }), b.permalink = { __proto__: null, legacy: r, renderHref: a, renderAttrs: i, makePermalink: o, linkInsideHeader: c, ariaHidden: s, headerLink: u, linkAfterHeader: d }, b.defaults = { level: 1, slugify: function(e2) {
      return encodeURIComponent(String(e2).trim().toLowerCase().replace(/\s+/g, "-"));
    }, uniqueSlugStartIndex: 1, tabIndex: "-1", getTokensText: function(e2) {
      return e2.filter(function(e3) {
        return ["text", "code_inline"].includes(e3.type);
      }).map(function(e3) {
        return e3.content;
      }).join("");
    }, permalink: false, renderPermalink: r, permalinkClass: s.defaults.class, permalinkSpace: s.defaults.space, permalinkSymbol: "\xB6", permalinkBefore: s.defaults.placement === "before", permalinkHref: s.defaults.renderHref, permalinkAttrs: s.defaults.renderAttrs }, b.default = b;
    markdownItAnchor_default = b;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/anchorPlugin.js
var require_anchorPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/anchorPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anchorPlugin = void 0;
    var markdown_it_anchor_1 = (init_markdownItAnchor(), __toCommonJS(markdownItAnchor_exports));
    exports2.anchorPlugin = markdown_it_anchor_1.default;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/resolveLink.js
var require_resolveLink = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/resolveLink.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveLink = void 0;
    var utils_1 = require_lib();
    var mdurl_1 = require_mdurl();
    var resolveLink = (link, relativePathPrefix, env) => {
      let resolvedLink = (0, mdurl_1.decode)(link);
      if (/^\.{1,2}\//.test(link) && env.filePathRelative) {
        resolvedLink = `${relativePathPrefix}/${utils_1.path.join(utils_1.path.dirname(env.filePathRelative), resolvedLink)}`;
      }
      return resolvedLink;
    };
    exports2.resolveLink = resolveLink;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/assetsPlugin.js
var require_assetsPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/assetsPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assetsPlugin = void 0;
    var resolveLink_1 = require_resolveLink();
    var assetsPlugin = (md, { relativePathPrefix = "@source" } = {}) => {
      const rawImageRule = md.renderer.rules.image;
      md.renderer.rules.image = (tokens, idx, options2, env, self2) => {
        const token = tokens[idx];
        const link = token.attrGet("src");
        if (link) {
          token.attrSet("src", (0, resolveLink_1.resolveLink)(link, relativePathPrefix, env));
        }
        return rawImageRule(tokens, idx, options2, env, self2);
      };
      const createHtmlRule = (rawHtmlRule) => (tokens, idx, options2, env, self2) => {
        tokens[idx].content = tokens[idx].content.replace(/(<img\b.*?src=")([^"]*)(")/gs, (_, prefix, src, suffix) => `${prefix}${(0, resolveLink_1.resolveLink)(src.trim(), relativePathPrefix, env)}${suffix}`).replace(/(<img\b.*?srcset=")([^"]*)(")/gs, (_, prefix, srcset, suffix) => `${prefix}${srcset.split(",").map((item) => item.trim().replace(/^([^ ]*?)([ \n].*)?$/, (_2, url, descriptor = "") => `${(0, resolveLink_1.resolveLink)(url.trim(), relativePathPrefix, env)}${descriptor.replace(/[ \n]+/g, " ").trimEnd()}`)).join(", ")}${suffix}`);
        return rawHtmlRule(tokens, idx, options2, env, self2);
      };
      const rawHtmlBlockRule = md.renderer.rules.html_block;
      const rawHtmlInlineRule = md.renderer.rules.html_inline;
      md.renderer.rules.html_block = createHtmlRule(rawHtmlBlockRule);
      md.renderer.rules.html_inline = createHtmlRule(rawHtmlInlineRule);
    };
    exports2.assetsPlugin = assetsPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/index.js
var require_assetsPlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/assetsPlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_assetsPlugin(), exports2);
    __exportStar(require_resolveLink(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveHighlightLines.js
var require_resolveHighlightLines = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveHighlightLines.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHighlightLine = exports2.resolveHighlightLines = void 0;
    var resolveHighlightLines = (info) => {
      const match = info.match(/{([\d,-]+)}/);
      if (match === null) {
        return null;
      }
      return match[1].split(",").map((item) => {
        const range = item.split("-");
        if (range.length === 1) {
          range.push(range[0]);
        }
        return range.map((str2) => Number.parseInt(str2, 10));
      });
    };
    exports2.resolveHighlightLines = resolveHighlightLines;
    var isHighlightLine = (lineNumber, ranges) => ranges.some(([start, end]) => lineNumber >= start && lineNumber <= end);
    exports2.isHighlightLine = isHighlightLine;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/languages.js
var require_languages = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/languages.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.languageYaml = exports2.languageTypescript = exports2.languageStylus = exports2.languageRust = exports2.languageRuby = exports2.languagePython = exports2.languageMarkdown = exports2.languageKotlin = exports2.languageJavascript = exports2.languageFsharp = exports2.languageDocker = exports2.languageCsharp = exports2.languageBash = void 0;
    exports2.languageBash = {
      name: "bash",
      ext: "sh",
      aliases: ["bash", "sh", "shell", "zsh"]
    };
    exports2.languageCsharp = {
      name: "csharp",
      ext: "cs",
      aliases: ["cs", "csharp"]
    };
    exports2.languageDocker = {
      name: "docker",
      ext: "docker",
      aliases: ["docker", "dockerfile"]
    };
    exports2.languageFsharp = {
      name: "fsharp",
      ext: "fs",
      aliases: ["fs", "fsharp"]
    };
    exports2.languageJavascript = {
      name: "javascript",
      ext: "js",
      aliases: ["javascript", "js"]
    };
    exports2.languageKotlin = {
      name: "kotlin",
      ext: "kt",
      aliases: ["kotlin", "kt"]
    };
    exports2.languageMarkdown = {
      name: "markdown",
      ext: "md",
      aliases: ["markdown", "md"]
    };
    exports2.languagePython = {
      name: "python",
      ext: "py",
      aliases: ["py", "python"]
    };
    exports2.languageRuby = {
      name: "ruby",
      ext: "rb",
      aliases: ["rb", "ruby"]
    };
    exports2.languageRust = {
      name: "rust",
      ext: "rs",
      aliases: ["rs", "rust"]
    };
    exports2.languageStylus = {
      name: "stylus",
      ext: "styl",
      aliases: ["styl", "stylus"]
    };
    exports2.languageTypescript = {
      name: "typescript",
      ext: "ts",
      aliases: ["ts", "typescript"]
    };
    exports2.languageYaml = {
      name: "yaml",
      ext: "yml",
      aliases: ["yaml", "yml"]
    };
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveLanguage.js
var require_resolveLanguage = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveLanguage.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveLanguage = void 0;
    var languages = require_languages();
    var languagesMap;
    var getLanguagesMap = () => {
      if (!languagesMap) {
        languagesMap = Object.values(languages).reduce((result, item) => {
          item.aliases.forEach((alias) => {
            result[alias] = item;
          });
          return result;
        }, {});
      }
      return languagesMap;
    };
    var resolveLanguage = (info) => {
      var _a, _b;
      const alias = ((_a = info.match(/^([^ :[{]+)/)) == null ? void 0 : _a[1]) || "text";
      return (_b = getLanguagesMap()[alias]) != null ? _b : {
        name: alias,
        ext: alias,
        aliases: [alias]
      };
    };
    exports2.resolveLanguage = resolveLanguage;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveLineNumbers.js
var require_resolveLineNumbers = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveLineNumbers.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveLineNumbers = void 0;
    var resolveLineNumbers = (info) => {
      if (/:line-numbers\b/.test(info)) {
        return true;
      }
      if (/:no-line-numbers\b/.test(info)) {
        return false;
      }
      return null;
    };
    exports2.resolveLineNumbers = resolveLineNumbers;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveVPre.js
var require_resolveVPre = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/resolveVPre.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveVPre = void 0;
    var resolveVPre = (info) => {
      if (/:v-pre\b/.test(info)) {
        return true;
      }
      if (/:no-v-pre\b/.test(info)) {
        return false;
      }
      return null;
    };
    exports2.resolveVPre = resolveVPre;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/codePlugin.js
var require_codePlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/codePlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codePlugin = void 0;
    var resolveHighlightLines_1 = require_resolveHighlightLines();
    var resolveLanguage_1 = require_resolveLanguage();
    var resolveLineNumbers_1 = require_resolveLineNumbers();
    var resolveVPre_1 = require_resolveVPre();
    var codePlugin = (md, { highlightLines = true, lineNumbers = true, preWrapper = true, vPre: { block: vPreBlock = true, inline: vPreInline = true } = {} } = {}) => {
      md.renderer.rules.fence = (tokens, idx, options2, env, slf) => {
        var _a, _b, _c;
        const token = tokens[idx];
        const info = token.info ? md.utils.unescapeAll(token.info).trim() : "";
        const language = (0, resolveLanguage_1.resolveLanguage)(info);
        const languageClass = `${options2.langPrefix}${language.name}`;
        const code = ((_a = options2.highlight) == null ? void 0 : _a.call(options2, token.content, language.name, "")) || md.utils.escapeHtml(token.content);
        let result = code.startsWith("<pre") ? code : `<pre class="${languageClass}"><code>${code}</code></pre>`;
        const useVPre = (_b = (0, resolveVPre_1.resolveVPre)(info)) != null ? _b : vPreBlock;
        if (useVPre) {
          result = `<pre v-pre${result.slice("<pre".length)}`;
        }
        if (!preWrapper) {
          return result;
        }
        const lines = code.split("\n").slice(0, -1);
        const highlightLinesRanges = highlightLines ? (0, resolveHighlightLines_1.resolveHighlightLines)(info) : null;
        if (highlightLinesRanges) {
          const highlightLinesCode = lines.map((_, index) => {
            if ((0, resolveHighlightLines_1.isHighlightLine)(index + 1, highlightLinesRanges)) {
              return '<div class="highlight-line">&nbsp;</div>';
            }
            return "<br>";
          }).join("");
          result = `${result}<div class="highlight-lines">${highlightLinesCode}</div>`;
        }
        const useLineNumbers = (_c = (0, resolveLineNumbers_1.resolveLineNumbers)(info)) != null ? _c : typeof lineNumbers === "number" ? lines.length >= lineNumbers : lineNumbers;
        if (useLineNumbers) {
          const lineNumbersCode = lines.map(() => `<div class="line-number"></div>`).join("");
          result = `${result}<div class="line-numbers" aria-hidden="true">${lineNumbersCode}</div>`;
        }
        result = `<div class="${languageClass} ext-${language.ext}${useLineNumbers ? " line-numbers-mode" : ""}">${result}</div>`;
        return result;
      };
      if (vPreInline) {
        const rawInlineCodeRule = md.renderer.rules.code_inline;
        md.renderer.rules.code_inline = (tokens, idx, options2, env, slf) => {
          const result = rawInlineCodeRule(tokens, idx, options2, env, slf);
          return `<code v-pre${result.slice("<code".length)}`;
        };
      }
    };
    exports2.codePlugin = codePlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/codePlugin/index.js
var require_codePlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/codePlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_codePlugin(), exports2);
    __exportStar(require_languages(), exports2);
    __exportStar(require_resolveHighlightLines(), exports2);
    __exportStar(require_resolveLanguage(), exports2);
    __exportStar(require_resolveLineNumbers(), exports2);
    __exportStar(require_resolveVPre(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlRe.js
var require_htmlRe = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlRe.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTML_OPEN_CLOSE_TAG_RE = exports2.HTML_TAG_RE = void 0;
    var attr_name = "[a-zA-Z_:@][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    exports2.HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    exports2.HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/inlineTags.js
var require_inlineTags = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/inlineTags.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inlineTags = void 0;
    exports2.inlineTags = [
      "a",
      "abbr",
      "acronym",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "map",
      "mark",
      "meter",
      "noscript",
      "object",
      "output",
      "picture",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      "script",
      "select",
      "slot",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "tt",
      "var",
      "video",
      "wbr"
    ];
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/vueReservedTags.js
var require_vueReservedTags = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/vueReservedTags.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.vueReservedTags = void 0;
    exports2.vueReservedTags = [
      "template",
      "component",
      "transition",
      "transition-group",
      "keep-alive",
      "slot",
      "teleport"
    ];
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlBlockRule.js
var require_htmlBlockRule = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlBlockRule.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.htmlBlockRule = void 0;
    var blockNames = require_html_blocks();
    var htmlRe_1 = require_htmlRe();
    var inlineTags_1 = require_inlineTags();
    var vueReservedTags_1 = require_vueReservedTags();
    var HTML_SEQUENCES = [
      [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [
        new RegExp("^</?(" + vueReservedTags_1.vueReservedTags.join("|") + ")(?=(\\s|/?>|$))", "i"),
        /^$/,
        true
      ],
      [
        new RegExp("^</?(?!(" + inlineTags_1.inlineTags.join("|") + ")(?![\\w-]))\\w[\\w-]*[\\s/>]"),
        /^$/,
        true
      ],
      [
        new RegExp("^</?(" + blockNames.join("|") + ")(?=(\\s|/?>|$))", "i"),
        /^$/,
        true
      ],
      [new RegExp(htmlRe_1.HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    var htmlBlockRule = (state, startLine, endLine, silent) => {
      let i2;
      let nextLine;
      let lineText;
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      const token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
    exports2.htmlBlockRule = htmlBlockRule;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlInlineRule.js
var require_htmlInlineRule = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/htmlInlineRule.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.htmlInlineRule = void 0;
    var htmlRe_1 = require_htmlRe();
    var isLetter = (ch) => {
      const lc = ch | 32;
      return lc >= 97 && lc <= 122;
    };
    var htmlInlineRule = (state, silent) => {
      const pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      const max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      const ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      const match = state.src.slice(pos).match(htmlRe_1.HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        const token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
      }
      state.pos += match[0].length;
      return true;
    };
    exports2.htmlInlineRule = htmlInlineRule;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/customComponentPlugin.js
var require_customComponentPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/customComponentPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.customComponentPlugin = void 0;
    var htmlBlockRule_1 = require_htmlBlockRule();
    var htmlInlineRule_1 = require_htmlInlineRule();
    var customComponentPlugin = (md) => {
      md.block.ruler.at("html_block", htmlBlockRule_1.htmlBlockRule, {
        alt: ["paragraph", "reference", "blockquote"]
      });
      md.inline.ruler.at("html_inline", htmlInlineRule_1.htmlInlineRule);
    };
    exports2.customComponentPlugin = customComponentPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/index.js
var require_customComponentPlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/customComponentPlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_customComponentPlugin(), exports2);
    __exportStar(require_htmlBlockRule(), exports2);
    __exportStar(require_htmlInlineRule(), exports2);
    __exportStar(require_htmlRe(), exports2);
    __exportStar(require_inlineTags(), exports2);
    __exportStar(require_vueReservedTags(), exports2);
  }
});

// node_modules/markdown-it-emoji/lib/data/full.json
var require_full = __commonJS({
  "node_modules/markdown-it-emoji/lib/data/full.json"(exports2, module2) {
    module2.exports = {
      "100": "\u{1F4AF}",
      "1234": "\u{1F522}",
      grinning: "\u{1F600}",
      smiley: "\u{1F603}",
      smile: "\u{1F604}",
      grin: "\u{1F601}",
      laughing: "\u{1F606}",
      satisfied: "\u{1F606}",
      sweat_smile: "\u{1F605}",
      rofl: "\u{1F923}",
      joy: "\u{1F602}",
      slightly_smiling_face: "\u{1F642}",
      upside_down_face: "\u{1F643}",
      wink: "\u{1F609}",
      blush: "\u{1F60A}",
      innocent: "\u{1F607}",
      smiling_face_with_three_hearts: "\u{1F970}",
      heart_eyes: "\u{1F60D}",
      star_struck: "\u{1F929}",
      kissing_heart: "\u{1F618}",
      kissing: "\u{1F617}",
      relaxed: "\u263A\uFE0F",
      kissing_closed_eyes: "\u{1F61A}",
      kissing_smiling_eyes: "\u{1F619}",
      smiling_face_with_tear: "\u{1F972}",
      yum: "\u{1F60B}",
      stuck_out_tongue: "\u{1F61B}",
      stuck_out_tongue_winking_eye: "\u{1F61C}",
      zany_face: "\u{1F92A}",
      stuck_out_tongue_closed_eyes: "\u{1F61D}",
      money_mouth_face: "\u{1F911}",
      hugs: "\u{1F917}",
      hand_over_mouth: "\u{1F92D}",
      shushing_face: "\u{1F92B}",
      thinking: "\u{1F914}",
      zipper_mouth_face: "\u{1F910}",
      raised_eyebrow: "\u{1F928}",
      neutral_face: "\u{1F610}",
      expressionless: "\u{1F611}",
      no_mouth: "\u{1F636}",
      smirk: "\u{1F60F}",
      unamused: "\u{1F612}",
      roll_eyes: "\u{1F644}",
      grimacing: "\u{1F62C}",
      lying_face: "\u{1F925}",
      relieved: "\u{1F60C}",
      pensive: "\u{1F614}",
      sleepy: "\u{1F62A}",
      drooling_face: "\u{1F924}",
      sleeping: "\u{1F634}",
      mask: "\u{1F637}",
      face_with_thermometer: "\u{1F912}",
      face_with_head_bandage: "\u{1F915}",
      nauseated_face: "\u{1F922}",
      vomiting_face: "\u{1F92E}",
      sneezing_face: "\u{1F927}",
      hot_face: "\u{1F975}",
      cold_face: "\u{1F976}",
      woozy_face: "\u{1F974}",
      dizzy_face: "\u{1F635}",
      exploding_head: "\u{1F92F}",
      cowboy_hat_face: "\u{1F920}",
      partying_face: "\u{1F973}",
      disguised_face: "\u{1F978}",
      sunglasses: "\u{1F60E}",
      nerd_face: "\u{1F913}",
      monocle_face: "\u{1F9D0}",
      confused: "\u{1F615}",
      worried: "\u{1F61F}",
      slightly_frowning_face: "\u{1F641}",
      frowning_face: "\u2639\uFE0F",
      open_mouth: "\u{1F62E}",
      hushed: "\u{1F62F}",
      astonished: "\u{1F632}",
      flushed: "\u{1F633}",
      pleading_face: "\u{1F97A}",
      frowning: "\u{1F626}",
      anguished: "\u{1F627}",
      fearful: "\u{1F628}",
      cold_sweat: "\u{1F630}",
      disappointed_relieved: "\u{1F625}",
      cry: "\u{1F622}",
      sob: "\u{1F62D}",
      scream: "\u{1F631}",
      confounded: "\u{1F616}",
      persevere: "\u{1F623}",
      disappointed: "\u{1F61E}",
      sweat: "\u{1F613}",
      weary: "\u{1F629}",
      tired_face: "\u{1F62B}",
      yawning_face: "\u{1F971}",
      triumph: "\u{1F624}",
      rage: "\u{1F621}",
      pout: "\u{1F621}",
      angry: "\u{1F620}",
      cursing_face: "\u{1F92C}",
      smiling_imp: "\u{1F608}",
      imp: "\u{1F47F}",
      skull: "\u{1F480}",
      skull_and_crossbones: "\u2620\uFE0F",
      hankey: "\u{1F4A9}",
      poop: "\u{1F4A9}",
      shit: "\u{1F4A9}",
      clown_face: "\u{1F921}",
      japanese_ogre: "\u{1F479}",
      japanese_goblin: "\u{1F47A}",
      ghost: "\u{1F47B}",
      alien: "\u{1F47D}",
      space_invader: "\u{1F47E}",
      robot: "\u{1F916}",
      smiley_cat: "\u{1F63A}",
      smile_cat: "\u{1F638}",
      joy_cat: "\u{1F639}",
      heart_eyes_cat: "\u{1F63B}",
      smirk_cat: "\u{1F63C}",
      kissing_cat: "\u{1F63D}",
      scream_cat: "\u{1F640}",
      crying_cat_face: "\u{1F63F}",
      pouting_cat: "\u{1F63E}",
      see_no_evil: "\u{1F648}",
      hear_no_evil: "\u{1F649}",
      speak_no_evil: "\u{1F64A}",
      kiss: "\u{1F48B}",
      love_letter: "\u{1F48C}",
      cupid: "\u{1F498}",
      gift_heart: "\u{1F49D}",
      sparkling_heart: "\u{1F496}",
      heartpulse: "\u{1F497}",
      heartbeat: "\u{1F493}",
      revolving_hearts: "\u{1F49E}",
      two_hearts: "\u{1F495}",
      heart_decoration: "\u{1F49F}",
      heavy_heart_exclamation: "\u2763\uFE0F",
      broken_heart: "\u{1F494}",
      heart: "\u2764\uFE0F",
      orange_heart: "\u{1F9E1}",
      yellow_heart: "\u{1F49B}",
      green_heart: "\u{1F49A}",
      blue_heart: "\u{1F499}",
      purple_heart: "\u{1F49C}",
      brown_heart: "\u{1F90E}",
      black_heart: "\u{1F5A4}",
      white_heart: "\u{1F90D}",
      anger: "\u{1F4A2}",
      boom: "\u{1F4A5}",
      collision: "\u{1F4A5}",
      dizzy: "\u{1F4AB}",
      sweat_drops: "\u{1F4A6}",
      dash: "\u{1F4A8}",
      hole: "\u{1F573}\uFE0F",
      bomb: "\u{1F4A3}",
      speech_balloon: "\u{1F4AC}",
      eye_speech_bubble: "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F",
      left_speech_bubble: "\u{1F5E8}\uFE0F",
      right_anger_bubble: "\u{1F5EF}\uFE0F",
      thought_balloon: "\u{1F4AD}",
      zzz: "\u{1F4A4}",
      wave: "\u{1F44B}",
      raised_back_of_hand: "\u{1F91A}",
      raised_hand_with_fingers_splayed: "\u{1F590}\uFE0F",
      hand: "\u270B",
      raised_hand: "\u270B",
      vulcan_salute: "\u{1F596}",
      ok_hand: "\u{1F44C}",
      pinched_fingers: "\u{1F90C}",
      pinching_hand: "\u{1F90F}",
      v: "\u270C\uFE0F",
      crossed_fingers: "\u{1F91E}",
      love_you_gesture: "\u{1F91F}",
      metal: "\u{1F918}",
      call_me_hand: "\u{1F919}",
      point_left: "\u{1F448}",
      point_right: "\u{1F449}",
      point_up_2: "\u{1F446}",
      middle_finger: "\u{1F595}",
      fu: "\u{1F595}",
      point_down: "\u{1F447}",
      point_up: "\u261D\uFE0F",
      "+1": "\u{1F44D}",
      thumbsup: "\u{1F44D}",
      "-1": "\u{1F44E}",
      thumbsdown: "\u{1F44E}",
      fist_raised: "\u270A",
      fist: "\u270A",
      fist_oncoming: "\u{1F44A}",
      facepunch: "\u{1F44A}",
      punch: "\u{1F44A}",
      fist_left: "\u{1F91B}",
      fist_right: "\u{1F91C}",
      clap: "\u{1F44F}",
      raised_hands: "\u{1F64C}",
      open_hands: "\u{1F450}",
      palms_up_together: "\u{1F932}",
      handshake: "\u{1F91D}",
      pray: "\u{1F64F}",
      writing_hand: "\u270D\uFE0F",
      nail_care: "\u{1F485}",
      selfie: "\u{1F933}",
      muscle: "\u{1F4AA}",
      mechanical_arm: "\u{1F9BE}",
      mechanical_leg: "\u{1F9BF}",
      leg: "\u{1F9B5}",
      foot: "\u{1F9B6}",
      ear: "\u{1F442}",
      ear_with_hearing_aid: "\u{1F9BB}",
      nose: "\u{1F443}",
      brain: "\u{1F9E0}",
      anatomical_heart: "\u{1FAC0}",
      lungs: "\u{1FAC1}",
      tooth: "\u{1F9B7}",
      bone: "\u{1F9B4}",
      eyes: "\u{1F440}",
      eye: "\u{1F441}\uFE0F",
      tongue: "\u{1F445}",
      lips: "\u{1F444}",
      baby: "\u{1F476}",
      child: "\u{1F9D2}",
      boy: "\u{1F466}",
      girl: "\u{1F467}",
      adult: "\u{1F9D1}",
      blond_haired_person: "\u{1F471}",
      man: "\u{1F468}",
      bearded_person: "\u{1F9D4}",
      red_haired_man: "\u{1F468}\u200D\u{1F9B0}",
      curly_haired_man: "\u{1F468}\u200D\u{1F9B1}",
      white_haired_man: "\u{1F468}\u200D\u{1F9B3}",
      bald_man: "\u{1F468}\u200D\u{1F9B2}",
      woman: "\u{1F469}",
      red_haired_woman: "\u{1F469}\u200D\u{1F9B0}",
      person_red_hair: "\u{1F9D1}\u200D\u{1F9B0}",
      curly_haired_woman: "\u{1F469}\u200D\u{1F9B1}",
      person_curly_hair: "\u{1F9D1}\u200D\u{1F9B1}",
      white_haired_woman: "\u{1F469}\u200D\u{1F9B3}",
      person_white_hair: "\u{1F9D1}\u200D\u{1F9B3}",
      bald_woman: "\u{1F469}\u200D\u{1F9B2}",
      person_bald: "\u{1F9D1}\u200D\u{1F9B2}",
      blond_haired_woman: "\u{1F471}\u200D\u2640\uFE0F",
      blonde_woman: "\u{1F471}\u200D\u2640\uFE0F",
      blond_haired_man: "\u{1F471}\u200D\u2642\uFE0F",
      older_adult: "\u{1F9D3}",
      older_man: "\u{1F474}",
      older_woman: "\u{1F475}",
      frowning_person: "\u{1F64D}",
      frowning_man: "\u{1F64D}\u200D\u2642\uFE0F",
      frowning_woman: "\u{1F64D}\u200D\u2640\uFE0F",
      pouting_face: "\u{1F64E}",
      pouting_man: "\u{1F64E}\u200D\u2642\uFE0F",
      pouting_woman: "\u{1F64E}\u200D\u2640\uFE0F",
      no_good: "\u{1F645}",
      no_good_man: "\u{1F645}\u200D\u2642\uFE0F",
      ng_man: "\u{1F645}\u200D\u2642\uFE0F",
      no_good_woman: "\u{1F645}\u200D\u2640\uFE0F",
      ng_woman: "\u{1F645}\u200D\u2640\uFE0F",
      ok_person: "\u{1F646}",
      ok_man: "\u{1F646}\u200D\u2642\uFE0F",
      ok_woman: "\u{1F646}\u200D\u2640\uFE0F",
      tipping_hand_person: "\u{1F481}",
      information_desk_person: "\u{1F481}",
      tipping_hand_man: "\u{1F481}\u200D\u2642\uFE0F",
      sassy_man: "\u{1F481}\u200D\u2642\uFE0F",
      tipping_hand_woman: "\u{1F481}\u200D\u2640\uFE0F",
      sassy_woman: "\u{1F481}\u200D\u2640\uFE0F",
      raising_hand: "\u{1F64B}",
      raising_hand_man: "\u{1F64B}\u200D\u2642\uFE0F",
      raising_hand_woman: "\u{1F64B}\u200D\u2640\uFE0F",
      deaf_person: "\u{1F9CF}",
      deaf_man: "\u{1F9CF}\u200D\u2642\uFE0F",
      deaf_woman: "\u{1F9CF}\u200D\u2640\uFE0F",
      bow: "\u{1F647}",
      bowing_man: "\u{1F647}\u200D\u2642\uFE0F",
      bowing_woman: "\u{1F647}\u200D\u2640\uFE0F",
      facepalm: "\u{1F926}",
      man_facepalming: "\u{1F926}\u200D\u2642\uFE0F",
      woman_facepalming: "\u{1F926}\u200D\u2640\uFE0F",
      shrug: "\u{1F937}",
      man_shrugging: "\u{1F937}\u200D\u2642\uFE0F",
      woman_shrugging: "\u{1F937}\u200D\u2640\uFE0F",
      health_worker: "\u{1F9D1}\u200D\u2695\uFE0F",
      man_health_worker: "\u{1F468}\u200D\u2695\uFE0F",
      woman_health_worker: "\u{1F469}\u200D\u2695\uFE0F",
      student: "\u{1F9D1}\u200D\u{1F393}",
      man_student: "\u{1F468}\u200D\u{1F393}",
      woman_student: "\u{1F469}\u200D\u{1F393}",
      teacher: "\u{1F9D1}\u200D\u{1F3EB}",
      man_teacher: "\u{1F468}\u200D\u{1F3EB}",
      woman_teacher: "\u{1F469}\u200D\u{1F3EB}",
      judge: "\u{1F9D1}\u200D\u2696\uFE0F",
      man_judge: "\u{1F468}\u200D\u2696\uFE0F",
      woman_judge: "\u{1F469}\u200D\u2696\uFE0F",
      farmer: "\u{1F9D1}\u200D\u{1F33E}",
      man_farmer: "\u{1F468}\u200D\u{1F33E}",
      woman_farmer: "\u{1F469}\u200D\u{1F33E}",
      cook: "\u{1F9D1}\u200D\u{1F373}",
      man_cook: "\u{1F468}\u200D\u{1F373}",
      woman_cook: "\u{1F469}\u200D\u{1F373}",
      mechanic: "\u{1F9D1}\u200D\u{1F527}",
      man_mechanic: "\u{1F468}\u200D\u{1F527}",
      woman_mechanic: "\u{1F469}\u200D\u{1F527}",
      factory_worker: "\u{1F9D1}\u200D\u{1F3ED}",
      man_factory_worker: "\u{1F468}\u200D\u{1F3ED}",
      woman_factory_worker: "\u{1F469}\u200D\u{1F3ED}",
      office_worker: "\u{1F9D1}\u200D\u{1F4BC}",
      man_office_worker: "\u{1F468}\u200D\u{1F4BC}",
      woman_office_worker: "\u{1F469}\u200D\u{1F4BC}",
      scientist: "\u{1F9D1}\u200D\u{1F52C}",
      man_scientist: "\u{1F468}\u200D\u{1F52C}",
      woman_scientist: "\u{1F469}\u200D\u{1F52C}",
      technologist: "\u{1F9D1}\u200D\u{1F4BB}",
      man_technologist: "\u{1F468}\u200D\u{1F4BB}",
      woman_technologist: "\u{1F469}\u200D\u{1F4BB}",
      singer: "\u{1F9D1}\u200D\u{1F3A4}",
      man_singer: "\u{1F468}\u200D\u{1F3A4}",
      woman_singer: "\u{1F469}\u200D\u{1F3A4}",
      artist: "\u{1F9D1}\u200D\u{1F3A8}",
      man_artist: "\u{1F468}\u200D\u{1F3A8}",
      woman_artist: "\u{1F469}\u200D\u{1F3A8}",
      pilot: "\u{1F9D1}\u200D\u2708\uFE0F",
      man_pilot: "\u{1F468}\u200D\u2708\uFE0F",
      woman_pilot: "\u{1F469}\u200D\u2708\uFE0F",
      astronaut: "\u{1F9D1}\u200D\u{1F680}",
      man_astronaut: "\u{1F468}\u200D\u{1F680}",
      woman_astronaut: "\u{1F469}\u200D\u{1F680}",
      firefighter: "\u{1F9D1}\u200D\u{1F692}",
      man_firefighter: "\u{1F468}\u200D\u{1F692}",
      woman_firefighter: "\u{1F469}\u200D\u{1F692}",
      police_officer: "\u{1F46E}",
      cop: "\u{1F46E}",
      policeman: "\u{1F46E}\u200D\u2642\uFE0F",
      policewoman: "\u{1F46E}\u200D\u2640\uFE0F",
      detective: "\u{1F575}\uFE0F",
      male_detective: "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
      female_detective: "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
      guard: "\u{1F482}",
      guardsman: "\u{1F482}\u200D\u2642\uFE0F",
      guardswoman: "\u{1F482}\u200D\u2640\uFE0F",
      ninja: "\u{1F977}",
      construction_worker: "\u{1F477}",
      construction_worker_man: "\u{1F477}\u200D\u2642\uFE0F",
      construction_worker_woman: "\u{1F477}\u200D\u2640\uFE0F",
      prince: "\u{1F934}",
      princess: "\u{1F478}",
      person_with_turban: "\u{1F473}",
      man_with_turban: "\u{1F473}\u200D\u2642\uFE0F",
      woman_with_turban: "\u{1F473}\u200D\u2640\uFE0F",
      man_with_gua_pi_mao: "\u{1F472}",
      woman_with_headscarf: "\u{1F9D5}",
      person_in_tuxedo: "\u{1F935}",
      man_in_tuxedo: "\u{1F935}\u200D\u2642\uFE0F",
      woman_in_tuxedo: "\u{1F935}\u200D\u2640\uFE0F",
      person_with_veil: "\u{1F470}",
      man_with_veil: "\u{1F470}\u200D\u2642\uFE0F",
      woman_with_veil: "\u{1F470}\u200D\u2640\uFE0F",
      bride_with_veil: "\u{1F470}\u200D\u2640\uFE0F",
      pregnant_woman: "\u{1F930}",
      breast_feeding: "\u{1F931}",
      woman_feeding_baby: "\u{1F469}\u200D\u{1F37C}",
      man_feeding_baby: "\u{1F468}\u200D\u{1F37C}",
      person_feeding_baby: "\u{1F9D1}\u200D\u{1F37C}",
      angel: "\u{1F47C}",
      santa: "\u{1F385}",
      mrs_claus: "\u{1F936}",
      mx_claus: "\u{1F9D1}\u200D\u{1F384}",
      superhero: "\u{1F9B8}",
      superhero_man: "\u{1F9B8}\u200D\u2642\uFE0F",
      superhero_woman: "\u{1F9B8}\u200D\u2640\uFE0F",
      supervillain: "\u{1F9B9}",
      supervillain_man: "\u{1F9B9}\u200D\u2642\uFE0F",
      supervillain_woman: "\u{1F9B9}\u200D\u2640\uFE0F",
      mage: "\u{1F9D9}",
      mage_man: "\u{1F9D9}\u200D\u2642\uFE0F",
      mage_woman: "\u{1F9D9}\u200D\u2640\uFE0F",
      fairy: "\u{1F9DA}",
      fairy_man: "\u{1F9DA}\u200D\u2642\uFE0F",
      fairy_woman: "\u{1F9DA}\u200D\u2640\uFE0F",
      vampire: "\u{1F9DB}",
      vampire_man: "\u{1F9DB}\u200D\u2642\uFE0F",
      vampire_woman: "\u{1F9DB}\u200D\u2640\uFE0F",
      merperson: "\u{1F9DC}",
      merman: "\u{1F9DC}\u200D\u2642\uFE0F",
      mermaid: "\u{1F9DC}\u200D\u2640\uFE0F",
      elf: "\u{1F9DD}",
      elf_man: "\u{1F9DD}\u200D\u2642\uFE0F",
      elf_woman: "\u{1F9DD}\u200D\u2640\uFE0F",
      genie: "\u{1F9DE}",
      genie_man: "\u{1F9DE}\u200D\u2642\uFE0F",
      genie_woman: "\u{1F9DE}\u200D\u2640\uFE0F",
      zombie: "\u{1F9DF}",
      zombie_man: "\u{1F9DF}\u200D\u2642\uFE0F",
      zombie_woman: "\u{1F9DF}\u200D\u2640\uFE0F",
      massage: "\u{1F486}",
      massage_man: "\u{1F486}\u200D\u2642\uFE0F",
      massage_woman: "\u{1F486}\u200D\u2640\uFE0F",
      haircut: "\u{1F487}",
      haircut_man: "\u{1F487}\u200D\u2642\uFE0F",
      haircut_woman: "\u{1F487}\u200D\u2640\uFE0F",
      walking: "\u{1F6B6}",
      walking_man: "\u{1F6B6}\u200D\u2642\uFE0F",
      walking_woman: "\u{1F6B6}\u200D\u2640\uFE0F",
      standing_person: "\u{1F9CD}",
      standing_man: "\u{1F9CD}\u200D\u2642\uFE0F",
      standing_woman: "\u{1F9CD}\u200D\u2640\uFE0F",
      kneeling_person: "\u{1F9CE}",
      kneeling_man: "\u{1F9CE}\u200D\u2642\uFE0F",
      kneeling_woman: "\u{1F9CE}\u200D\u2640\uFE0F",
      person_with_probing_cane: "\u{1F9D1}\u200D\u{1F9AF}",
      man_with_probing_cane: "\u{1F468}\u200D\u{1F9AF}",
      woman_with_probing_cane: "\u{1F469}\u200D\u{1F9AF}",
      person_in_motorized_wheelchair: "\u{1F9D1}\u200D\u{1F9BC}",
      man_in_motorized_wheelchair: "\u{1F468}\u200D\u{1F9BC}",
      woman_in_motorized_wheelchair: "\u{1F469}\u200D\u{1F9BC}",
      person_in_manual_wheelchair: "\u{1F9D1}\u200D\u{1F9BD}",
      man_in_manual_wheelchair: "\u{1F468}\u200D\u{1F9BD}",
      woman_in_manual_wheelchair: "\u{1F469}\u200D\u{1F9BD}",
      runner: "\u{1F3C3}",
      running: "\u{1F3C3}",
      running_man: "\u{1F3C3}\u200D\u2642\uFE0F",
      running_woman: "\u{1F3C3}\u200D\u2640\uFE0F",
      woman_dancing: "\u{1F483}",
      dancer: "\u{1F483}",
      man_dancing: "\u{1F57A}",
      business_suit_levitating: "\u{1F574}\uFE0F",
      dancers: "\u{1F46F}",
      dancing_men: "\u{1F46F}\u200D\u2642\uFE0F",
      dancing_women: "\u{1F46F}\u200D\u2640\uFE0F",
      sauna_person: "\u{1F9D6}",
      sauna_man: "\u{1F9D6}\u200D\u2642\uFE0F",
      sauna_woman: "\u{1F9D6}\u200D\u2640\uFE0F",
      climbing: "\u{1F9D7}",
      climbing_man: "\u{1F9D7}\u200D\u2642\uFE0F",
      climbing_woman: "\u{1F9D7}\u200D\u2640\uFE0F",
      person_fencing: "\u{1F93A}",
      horse_racing: "\u{1F3C7}",
      skier: "\u26F7\uFE0F",
      snowboarder: "\u{1F3C2}",
      golfing: "\u{1F3CC}\uFE0F",
      golfing_man: "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
      golfing_woman: "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
      surfer: "\u{1F3C4}",
      surfing_man: "\u{1F3C4}\u200D\u2642\uFE0F",
      surfing_woman: "\u{1F3C4}\u200D\u2640\uFE0F",
      rowboat: "\u{1F6A3}",
      rowing_man: "\u{1F6A3}\u200D\u2642\uFE0F",
      rowing_woman: "\u{1F6A3}\u200D\u2640\uFE0F",
      swimmer: "\u{1F3CA}",
      swimming_man: "\u{1F3CA}\u200D\u2642\uFE0F",
      swimming_woman: "\u{1F3CA}\u200D\u2640\uFE0F",
      bouncing_ball_person: "\u26F9\uFE0F",
      bouncing_ball_man: "\u26F9\uFE0F\u200D\u2642\uFE0F",
      basketball_man: "\u26F9\uFE0F\u200D\u2642\uFE0F",
      bouncing_ball_woman: "\u26F9\uFE0F\u200D\u2640\uFE0F",
      basketball_woman: "\u26F9\uFE0F\u200D\u2640\uFE0F",
      weight_lifting: "\u{1F3CB}\uFE0F",
      weight_lifting_man: "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
      weight_lifting_woman: "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
      bicyclist: "\u{1F6B4}",
      biking_man: "\u{1F6B4}\u200D\u2642\uFE0F",
      biking_woman: "\u{1F6B4}\u200D\u2640\uFE0F",
      mountain_bicyclist: "\u{1F6B5}",
      mountain_biking_man: "\u{1F6B5}\u200D\u2642\uFE0F",
      mountain_biking_woman: "\u{1F6B5}\u200D\u2640\uFE0F",
      cartwheeling: "\u{1F938}",
      man_cartwheeling: "\u{1F938}\u200D\u2642\uFE0F",
      woman_cartwheeling: "\u{1F938}\u200D\u2640\uFE0F",
      wrestling: "\u{1F93C}",
      men_wrestling: "\u{1F93C}\u200D\u2642\uFE0F",
      women_wrestling: "\u{1F93C}\u200D\u2640\uFE0F",
      water_polo: "\u{1F93D}",
      man_playing_water_polo: "\u{1F93D}\u200D\u2642\uFE0F",
      woman_playing_water_polo: "\u{1F93D}\u200D\u2640\uFE0F",
      handball_person: "\u{1F93E}",
      man_playing_handball: "\u{1F93E}\u200D\u2642\uFE0F",
      woman_playing_handball: "\u{1F93E}\u200D\u2640\uFE0F",
      juggling_person: "\u{1F939}",
      man_juggling: "\u{1F939}\u200D\u2642\uFE0F",
      woman_juggling: "\u{1F939}\u200D\u2640\uFE0F",
      lotus_position: "\u{1F9D8}",
      lotus_position_man: "\u{1F9D8}\u200D\u2642\uFE0F",
      lotus_position_woman: "\u{1F9D8}\u200D\u2640\uFE0F",
      bath: "\u{1F6C0}",
      sleeping_bed: "\u{1F6CC}",
      people_holding_hands: "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}",
      two_women_holding_hands: "\u{1F46D}",
      couple: "\u{1F46B}",
      two_men_holding_hands: "\u{1F46C}",
      couplekiss: "\u{1F48F}",
      couplekiss_man_woman: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      couplekiss_man_man: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      couplekiss_woman_woman: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
      couple_with_heart: "\u{1F491}",
      couple_with_heart_woman_man: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
      couple_with_heart_man_man: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
      couple_with_heart_woman_woman: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
      family: "\u{1F46A}",
      family_man_woman_boy: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
      family_man_woman_girl: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
      family_man_woman_girl_boy: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      family_man_woman_boy_boy: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      family_man_woman_girl_girl: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      family_man_man_boy: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
      family_man_man_girl: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
      family_man_man_girl_boy: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      family_man_man_boy_boy: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      family_man_man_girl_girl: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      family_woman_woman_boy: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
      family_woman_woman_girl: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
      family_woman_woman_girl_boy: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      family_woman_woman_boy_boy: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      family_woman_woman_girl_girl: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      family_man_boy: "\u{1F468}\u200D\u{1F466}",
      family_man_boy_boy: "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      family_man_girl: "\u{1F468}\u200D\u{1F467}",
      family_man_girl_boy: "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      family_man_girl_girl: "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      family_woman_boy: "\u{1F469}\u200D\u{1F466}",
      family_woman_boy_boy: "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      family_woman_girl: "\u{1F469}\u200D\u{1F467}",
      family_woman_girl_boy: "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      family_woman_girl_girl: "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      speaking_head: "\u{1F5E3}\uFE0F",
      bust_in_silhouette: "\u{1F464}",
      busts_in_silhouette: "\u{1F465}",
      people_hugging: "\u{1FAC2}",
      footprints: "\u{1F463}",
      monkey_face: "\u{1F435}",
      monkey: "\u{1F412}",
      gorilla: "\u{1F98D}",
      orangutan: "\u{1F9A7}",
      dog: "\u{1F436}",
      dog2: "\u{1F415}",
      guide_dog: "\u{1F9AE}",
      service_dog: "\u{1F415}\u200D\u{1F9BA}",
      poodle: "\u{1F429}",
      wolf: "\u{1F43A}",
      fox_face: "\u{1F98A}",
      raccoon: "\u{1F99D}",
      cat: "\u{1F431}",
      cat2: "\u{1F408}",
      black_cat: "\u{1F408}\u200D\u2B1B",
      lion: "\u{1F981}",
      tiger: "\u{1F42F}",
      tiger2: "\u{1F405}",
      leopard: "\u{1F406}",
      horse: "\u{1F434}",
      racehorse: "\u{1F40E}",
      unicorn: "\u{1F984}",
      zebra: "\u{1F993}",
      deer: "\u{1F98C}",
      bison: "\u{1F9AC}",
      cow: "\u{1F42E}",
      ox: "\u{1F402}",
      water_buffalo: "\u{1F403}",
      cow2: "\u{1F404}",
      pig: "\u{1F437}",
      pig2: "\u{1F416}",
      boar: "\u{1F417}",
      pig_nose: "\u{1F43D}",
      ram: "\u{1F40F}",
      sheep: "\u{1F411}",
      goat: "\u{1F410}",
      dromedary_camel: "\u{1F42A}",
      camel: "\u{1F42B}",
      llama: "\u{1F999}",
      giraffe: "\u{1F992}",
      elephant: "\u{1F418}",
      mammoth: "\u{1F9A3}",
      rhinoceros: "\u{1F98F}",
      hippopotamus: "\u{1F99B}",
      mouse: "\u{1F42D}",
      mouse2: "\u{1F401}",
      rat: "\u{1F400}",
      hamster: "\u{1F439}",
      rabbit: "\u{1F430}",
      rabbit2: "\u{1F407}",
      chipmunk: "\u{1F43F}\uFE0F",
      beaver: "\u{1F9AB}",
      hedgehog: "\u{1F994}",
      bat: "\u{1F987}",
      bear: "\u{1F43B}",
      polar_bear: "\u{1F43B}\u200D\u2744\uFE0F",
      koala: "\u{1F428}",
      panda_face: "\u{1F43C}",
      sloth: "\u{1F9A5}",
      otter: "\u{1F9A6}",
      skunk: "\u{1F9A8}",
      kangaroo: "\u{1F998}",
      badger: "\u{1F9A1}",
      feet: "\u{1F43E}",
      paw_prints: "\u{1F43E}",
      turkey: "\u{1F983}",
      chicken: "\u{1F414}",
      rooster: "\u{1F413}",
      hatching_chick: "\u{1F423}",
      baby_chick: "\u{1F424}",
      hatched_chick: "\u{1F425}",
      bird: "\u{1F426}",
      penguin: "\u{1F427}",
      dove: "\u{1F54A}\uFE0F",
      eagle: "\u{1F985}",
      duck: "\u{1F986}",
      swan: "\u{1F9A2}",
      owl: "\u{1F989}",
      dodo: "\u{1F9A4}",
      feather: "\u{1FAB6}",
      flamingo: "\u{1F9A9}",
      peacock: "\u{1F99A}",
      parrot: "\u{1F99C}",
      frog: "\u{1F438}",
      crocodile: "\u{1F40A}",
      turtle: "\u{1F422}",
      lizard: "\u{1F98E}",
      snake: "\u{1F40D}",
      dragon_face: "\u{1F432}",
      dragon: "\u{1F409}",
      sauropod: "\u{1F995}",
      "t-rex": "\u{1F996}",
      whale: "\u{1F433}",
      whale2: "\u{1F40B}",
      dolphin: "\u{1F42C}",
      flipper: "\u{1F42C}",
      seal: "\u{1F9AD}",
      fish: "\u{1F41F}",
      tropical_fish: "\u{1F420}",
      blowfish: "\u{1F421}",
      shark: "\u{1F988}",
      octopus: "\u{1F419}",
      shell: "\u{1F41A}",
      snail: "\u{1F40C}",
      butterfly: "\u{1F98B}",
      bug: "\u{1F41B}",
      ant: "\u{1F41C}",
      bee: "\u{1F41D}",
      honeybee: "\u{1F41D}",
      beetle: "\u{1FAB2}",
      lady_beetle: "\u{1F41E}",
      cricket: "\u{1F997}",
      cockroach: "\u{1FAB3}",
      spider: "\u{1F577}\uFE0F",
      spider_web: "\u{1F578}\uFE0F",
      scorpion: "\u{1F982}",
      mosquito: "\u{1F99F}",
      fly: "\u{1FAB0}",
      worm: "\u{1FAB1}",
      microbe: "\u{1F9A0}",
      bouquet: "\u{1F490}",
      cherry_blossom: "\u{1F338}",
      white_flower: "\u{1F4AE}",
      rosette: "\u{1F3F5}\uFE0F",
      rose: "\u{1F339}",
      wilted_flower: "\u{1F940}",
      hibiscus: "\u{1F33A}",
      sunflower: "\u{1F33B}",
      blossom: "\u{1F33C}",
      tulip: "\u{1F337}",
      seedling: "\u{1F331}",
      potted_plant: "\u{1FAB4}",
      evergreen_tree: "\u{1F332}",
      deciduous_tree: "\u{1F333}",
      palm_tree: "\u{1F334}",
      cactus: "\u{1F335}",
      ear_of_rice: "\u{1F33E}",
      herb: "\u{1F33F}",
      shamrock: "\u2618\uFE0F",
      four_leaf_clover: "\u{1F340}",
      maple_leaf: "\u{1F341}",
      fallen_leaf: "\u{1F342}",
      leaves: "\u{1F343}",
      grapes: "\u{1F347}",
      melon: "\u{1F348}",
      watermelon: "\u{1F349}",
      tangerine: "\u{1F34A}",
      orange: "\u{1F34A}",
      mandarin: "\u{1F34A}",
      lemon: "\u{1F34B}",
      banana: "\u{1F34C}",
      pineapple: "\u{1F34D}",
      mango: "\u{1F96D}",
      apple: "\u{1F34E}",
      green_apple: "\u{1F34F}",
      pear: "\u{1F350}",
      peach: "\u{1F351}",
      cherries: "\u{1F352}",
      strawberry: "\u{1F353}",
      blueberries: "\u{1FAD0}",
      kiwi_fruit: "\u{1F95D}",
      tomato: "\u{1F345}",
      olive: "\u{1FAD2}",
      coconut: "\u{1F965}",
      avocado: "\u{1F951}",
      eggplant: "\u{1F346}",
      potato: "\u{1F954}",
      carrot: "\u{1F955}",
      corn: "\u{1F33D}",
      hot_pepper: "\u{1F336}\uFE0F",
      bell_pepper: "\u{1FAD1}",
      cucumber: "\u{1F952}",
      leafy_green: "\u{1F96C}",
      broccoli: "\u{1F966}",
      garlic: "\u{1F9C4}",
      onion: "\u{1F9C5}",
      mushroom: "\u{1F344}",
      peanuts: "\u{1F95C}",
      chestnut: "\u{1F330}",
      bread: "\u{1F35E}",
      croissant: "\u{1F950}",
      baguette_bread: "\u{1F956}",
      flatbread: "\u{1FAD3}",
      pretzel: "\u{1F968}",
      bagel: "\u{1F96F}",
      pancakes: "\u{1F95E}",
      waffle: "\u{1F9C7}",
      cheese: "\u{1F9C0}",
      meat_on_bone: "\u{1F356}",
      poultry_leg: "\u{1F357}",
      cut_of_meat: "\u{1F969}",
      bacon: "\u{1F953}",
      hamburger: "\u{1F354}",
      fries: "\u{1F35F}",
      pizza: "\u{1F355}",
      hotdog: "\u{1F32D}",
      sandwich: "\u{1F96A}",
      taco: "\u{1F32E}",
      burrito: "\u{1F32F}",
      tamale: "\u{1FAD4}",
      stuffed_flatbread: "\u{1F959}",
      falafel: "\u{1F9C6}",
      egg: "\u{1F95A}",
      fried_egg: "\u{1F373}",
      shallow_pan_of_food: "\u{1F958}",
      stew: "\u{1F372}",
      fondue: "\u{1FAD5}",
      bowl_with_spoon: "\u{1F963}",
      green_salad: "\u{1F957}",
      popcorn: "\u{1F37F}",
      butter: "\u{1F9C8}",
      salt: "\u{1F9C2}",
      canned_food: "\u{1F96B}",
      bento: "\u{1F371}",
      rice_cracker: "\u{1F358}",
      rice_ball: "\u{1F359}",
      rice: "\u{1F35A}",
      curry: "\u{1F35B}",
      ramen: "\u{1F35C}",
      spaghetti: "\u{1F35D}",
      sweet_potato: "\u{1F360}",
      oden: "\u{1F362}",
      sushi: "\u{1F363}",
      fried_shrimp: "\u{1F364}",
      fish_cake: "\u{1F365}",
      moon_cake: "\u{1F96E}",
      dango: "\u{1F361}",
      dumpling: "\u{1F95F}",
      fortune_cookie: "\u{1F960}",
      takeout_box: "\u{1F961}",
      crab: "\u{1F980}",
      lobster: "\u{1F99E}",
      shrimp: "\u{1F990}",
      squid: "\u{1F991}",
      oyster: "\u{1F9AA}",
      icecream: "\u{1F366}",
      shaved_ice: "\u{1F367}",
      ice_cream: "\u{1F368}",
      doughnut: "\u{1F369}",
      cookie: "\u{1F36A}",
      birthday: "\u{1F382}",
      cake: "\u{1F370}",
      cupcake: "\u{1F9C1}",
      pie: "\u{1F967}",
      chocolate_bar: "\u{1F36B}",
      candy: "\u{1F36C}",
      lollipop: "\u{1F36D}",
      custard: "\u{1F36E}",
      honey_pot: "\u{1F36F}",
      baby_bottle: "\u{1F37C}",
      milk_glass: "\u{1F95B}",
      coffee: "\u2615",
      teapot: "\u{1FAD6}",
      tea: "\u{1F375}",
      sake: "\u{1F376}",
      champagne: "\u{1F37E}",
      wine_glass: "\u{1F377}",
      cocktail: "\u{1F378}",
      tropical_drink: "\u{1F379}",
      beer: "\u{1F37A}",
      beers: "\u{1F37B}",
      clinking_glasses: "\u{1F942}",
      tumbler_glass: "\u{1F943}",
      cup_with_straw: "\u{1F964}",
      bubble_tea: "\u{1F9CB}",
      beverage_box: "\u{1F9C3}",
      mate: "\u{1F9C9}",
      ice_cube: "\u{1F9CA}",
      chopsticks: "\u{1F962}",
      plate_with_cutlery: "\u{1F37D}\uFE0F",
      fork_and_knife: "\u{1F374}",
      spoon: "\u{1F944}",
      hocho: "\u{1F52A}",
      knife: "\u{1F52A}",
      amphora: "\u{1F3FA}",
      earth_africa: "\u{1F30D}",
      earth_americas: "\u{1F30E}",
      earth_asia: "\u{1F30F}",
      globe_with_meridians: "\u{1F310}",
      world_map: "\u{1F5FA}\uFE0F",
      japan: "\u{1F5FE}",
      compass: "\u{1F9ED}",
      mountain_snow: "\u{1F3D4}\uFE0F",
      mountain: "\u26F0\uFE0F",
      volcano: "\u{1F30B}",
      mount_fuji: "\u{1F5FB}",
      camping: "\u{1F3D5}\uFE0F",
      beach_umbrella: "\u{1F3D6}\uFE0F",
      desert: "\u{1F3DC}\uFE0F",
      desert_island: "\u{1F3DD}\uFE0F",
      national_park: "\u{1F3DE}\uFE0F",
      stadium: "\u{1F3DF}\uFE0F",
      classical_building: "\u{1F3DB}\uFE0F",
      building_construction: "\u{1F3D7}\uFE0F",
      bricks: "\u{1F9F1}",
      rock: "\u{1FAA8}",
      wood: "\u{1FAB5}",
      hut: "\u{1F6D6}",
      houses: "\u{1F3D8}\uFE0F",
      derelict_house: "\u{1F3DA}\uFE0F",
      house: "\u{1F3E0}",
      house_with_garden: "\u{1F3E1}",
      office: "\u{1F3E2}",
      post_office: "\u{1F3E3}",
      european_post_office: "\u{1F3E4}",
      hospital: "\u{1F3E5}",
      bank: "\u{1F3E6}",
      hotel: "\u{1F3E8}",
      love_hotel: "\u{1F3E9}",
      convenience_store: "\u{1F3EA}",
      school: "\u{1F3EB}",
      department_store: "\u{1F3EC}",
      factory: "\u{1F3ED}",
      japanese_castle: "\u{1F3EF}",
      european_castle: "\u{1F3F0}",
      wedding: "\u{1F492}",
      tokyo_tower: "\u{1F5FC}",
      statue_of_liberty: "\u{1F5FD}",
      church: "\u26EA",
      mosque: "\u{1F54C}",
      hindu_temple: "\u{1F6D5}",
      synagogue: "\u{1F54D}",
      shinto_shrine: "\u26E9\uFE0F",
      kaaba: "\u{1F54B}",
      fountain: "\u26F2",
      tent: "\u26FA",
      foggy: "\u{1F301}",
      night_with_stars: "\u{1F303}",
      cityscape: "\u{1F3D9}\uFE0F",
      sunrise_over_mountains: "\u{1F304}",
      sunrise: "\u{1F305}",
      city_sunset: "\u{1F306}",
      city_sunrise: "\u{1F307}",
      bridge_at_night: "\u{1F309}",
      hotsprings: "\u2668\uFE0F",
      carousel_horse: "\u{1F3A0}",
      ferris_wheel: "\u{1F3A1}",
      roller_coaster: "\u{1F3A2}",
      barber: "\u{1F488}",
      circus_tent: "\u{1F3AA}",
      steam_locomotive: "\u{1F682}",
      railway_car: "\u{1F683}",
      bullettrain_side: "\u{1F684}",
      bullettrain_front: "\u{1F685}",
      train2: "\u{1F686}",
      metro: "\u{1F687}",
      light_rail: "\u{1F688}",
      station: "\u{1F689}",
      tram: "\u{1F68A}",
      monorail: "\u{1F69D}",
      mountain_railway: "\u{1F69E}",
      train: "\u{1F68B}",
      bus: "\u{1F68C}",
      oncoming_bus: "\u{1F68D}",
      trolleybus: "\u{1F68E}",
      minibus: "\u{1F690}",
      ambulance: "\u{1F691}",
      fire_engine: "\u{1F692}",
      police_car: "\u{1F693}",
      oncoming_police_car: "\u{1F694}",
      taxi: "\u{1F695}",
      oncoming_taxi: "\u{1F696}",
      car: "\u{1F697}",
      red_car: "\u{1F697}",
      oncoming_automobile: "\u{1F698}",
      blue_car: "\u{1F699}",
      pickup_truck: "\u{1F6FB}",
      truck: "\u{1F69A}",
      articulated_lorry: "\u{1F69B}",
      tractor: "\u{1F69C}",
      racing_car: "\u{1F3CE}\uFE0F",
      motorcycle: "\u{1F3CD}\uFE0F",
      motor_scooter: "\u{1F6F5}",
      manual_wheelchair: "\u{1F9BD}",
      motorized_wheelchair: "\u{1F9BC}",
      auto_rickshaw: "\u{1F6FA}",
      bike: "\u{1F6B2}",
      kick_scooter: "\u{1F6F4}",
      skateboard: "\u{1F6F9}",
      roller_skate: "\u{1F6FC}",
      busstop: "\u{1F68F}",
      motorway: "\u{1F6E3}\uFE0F",
      railway_track: "\u{1F6E4}\uFE0F",
      oil_drum: "\u{1F6E2}\uFE0F",
      fuelpump: "\u26FD",
      rotating_light: "\u{1F6A8}",
      traffic_light: "\u{1F6A5}",
      vertical_traffic_light: "\u{1F6A6}",
      stop_sign: "\u{1F6D1}",
      construction: "\u{1F6A7}",
      anchor: "\u2693",
      boat: "\u26F5",
      sailboat: "\u26F5",
      canoe: "\u{1F6F6}",
      speedboat: "\u{1F6A4}",
      passenger_ship: "\u{1F6F3}\uFE0F",
      ferry: "\u26F4\uFE0F",
      motor_boat: "\u{1F6E5}\uFE0F",
      ship: "\u{1F6A2}",
      airplane: "\u2708\uFE0F",
      small_airplane: "\u{1F6E9}\uFE0F",
      flight_departure: "\u{1F6EB}",
      flight_arrival: "\u{1F6EC}",
      parachute: "\u{1FA82}",
      seat: "\u{1F4BA}",
      helicopter: "\u{1F681}",
      suspension_railway: "\u{1F69F}",
      mountain_cableway: "\u{1F6A0}",
      aerial_tramway: "\u{1F6A1}",
      artificial_satellite: "\u{1F6F0}\uFE0F",
      rocket: "\u{1F680}",
      flying_saucer: "\u{1F6F8}",
      bellhop_bell: "\u{1F6CE}\uFE0F",
      luggage: "\u{1F9F3}",
      hourglass: "\u231B",
      hourglass_flowing_sand: "\u23F3",
      watch: "\u231A",
      alarm_clock: "\u23F0",
      stopwatch: "\u23F1\uFE0F",
      timer_clock: "\u23F2\uFE0F",
      mantelpiece_clock: "\u{1F570}\uFE0F",
      clock12: "\u{1F55B}",
      clock1230: "\u{1F567}",
      clock1: "\u{1F550}",
      clock130: "\u{1F55C}",
      clock2: "\u{1F551}",
      clock230: "\u{1F55D}",
      clock3: "\u{1F552}",
      clock330: "\u{1F55E}",
      clock4: "\u{1F553}",
      clock430: "\u{1F55F}",
      clock5: "\u{1F554}",
      clock530: "\u{1F560}",
      clock6: "\u{1F555}",
      clock630: "\u{1F561}",
      clock7: "\u{1F556}",
      clock730: "\u{1F562}",
      clock8: "\u{1F557}",
      clock830: "\u{1F563}",
      clock9: "\u{1F558}",
      clock930: "\u{1F564}",
      clock10: "\u{1F559}",
      clock1030: "\u{1F565}",
      clock11: "\u{1F55A}",
      clock1130: "\u{1F566}",
      new_moon: "\u{1F311}",
      waxing_crescent_moon: "\u{1F312}",
      first_quarter_moon: "\u{1F313}",
      moon: "\u{1F314}",
      waxing_gibbous_moon: "\u{1F314}",
      full_moon: "\u{1F315}",
      waning_gibbous_moon: "\u{1F316}",
      last_quarter_moon: "\u{1F317}",
      waning_crescent_moon: "\u{1F318}",
      crescent_moon: "\u{1F319}",
      new_moon_with_face: "\u{1F31A}",
      first_quarter_moon_with_face: "\u{1F31B}",
      last_quarter_moon_with_face: "\u{1F31C}",
      thermometer: "\u{1F321}\uFE0F",
      sunny: "\u2600\uFE0F",
      full_moon_with_face: "\u{1F31D}",
      sun_with_face: "\u{1F31E}",
      ringed_planet: "\u{1FA90}",
      star: "\u2B50",
      star2: "\u{1F31F}",
      stars: "\u{1F320}",
      milky_way: "\u{1F30C}",
      cloud: "\u2601\uFE0F",
      partly_sunny: "\u26C5",
      cloud_with_lightning_and_rain: "\u26C8\uFE0F",
      sun_behind_small_cloud: "\u{1F324}\uFE0F",
      sun_behind_large_cloud: "\u{1F325}\uFE0F",
      sun_behind_rain_cloud: "\u{1F326}\uFE0F",
      cloud_with_rain: "\u{1F327}\uFE0F",
      cloud_with_snow: "\u{1F328}\uFE0F",
      cloud_with_lightning: "\u{1F329}\uFE0F",
      tornado: "\u{1F32A}\uFE0F",
      fog: "\u{1F32B}\uFE0F",
      wind_face: "\u{1F32C}\uFE0F",
      cyclone: "\u{1F300}",
      rainbow: "\u{1F308}",
      closed_umbrella: "\u{1F302}",
      open_umbrella: "\u2602\uFE0F",
      umbrella: "\u2614",
      parasol_on_ground: "\u26F1\uFE0F",
      zap: "\u26A1",
      snowflake: "\u2744\uFE0F",
      snowman_with_snow: "\u2603\uFE0F",
      snowman: "\u26C4",
      comet: "\u2604\uFE0F",
      fire: "\u{1F525}",
      droplet: "\u{1F4A7}",
      ocean: "\u{1F30A}",
      jack_o_lantern: "\u{1F383}",
      christmas_tree: "\u{1F384}",
      fireworks: "\u{1F386}",
      sparkler: "\u{1F387}",
      firecracker: "\u{1F9E8}",
      sparkles: "\u2728",
      balloon: "\u{1F388}",
      tada: "\u{1F389}",
      confetti_ball: "\u{1F38A}",
      tanabata_tree: "\u{1F38B}",
      bamboo: "\u{1F38D}",
      dolls: "\u{1F38E}",
      flags: "\u{1F38F}",
      wind_chime: "\u{1F390}",
      rice_scene: "\u{1F391}",
      red_envelope: "\u{1F9E7}",
      ribbon: "\u{1F380}",
      gift: "\u{1F381}",
      reminder_ribbon: "\u{1F397}\uFE0F",
      tickets: "\u{1F39F}\uFE0F",
      ticket: "\u{1F3AB}",
      medal_military: "\u{1F396}\uFE0F",
      trophy: "\u{1F3C6}",
      medal_sports: "\u{1F3C5}",
      "1st_place_medal": "\u{1F947}",
      "2nd_place_medal": "\u{1F948}",
      "3rd_place_medal": "\u{1F949}",
      soccer: "\u26BD",
      baseball: "\u26BE",
      softball: "\u{1F94E}",
      basketball: "\u{1F3C0}",
      volleyball: "\u{1F3D0}",
      football: "\u{1F3C8}",
      rugby_football: "\u{1F3C9}",
      tennis: "\u{1F3BE}",
      flying_disc: "\u{1F94F}",
      bowling: "\u{1F3B3}",
      cricket_game: "\u{1F3CF}",
      field_hockey: "\u{1F3D1}",
      ice_hockey: "\u{1F3D2}",
      lacrosse: "\u{1F94D}",
      ping_pong: "\u{1F3D3}",
      badminton: "\u{1F3F8}",
      boxing_glove: "\u{1F94A}",
      martial_arts_uniform: "\u{1F94B}",
      goal_net: "\u{1F945}",
      golf: "\u26F3",
      ice_skate: "\u26F8\uFE0F",
      fishing_pole_and_fish: "\u{1F3A3}",
      diving_mask: "\u{1F93F}",
      running_shirt_with_sash: "\u{1F3BD}",
      ski: "\u{1F3BF}",
      sled: "\u{1F6F7}",
      curling_stone: "\u{1F94C}",
      dart: "\u{1F3AF}",
      yo_yo: "\u{1FA80}",
      kite: "\u{1FA81}",
      "8ball": "\u{1F3B1}",
      crystal_ball: "\u{1F52E}",
      magic_wand: "\u{1FA84}",
      nazar_amulet: "\u{1F9FF}",
      video_game: "\u{1F3AE}",
      joystick: "\u{1F579}\uFE0F",
      slot_machine: "\u{1F3B0}",
      game_die: "\u{1F3B2}",
      jigsaw: "\u{1F9E9}",
      teddy_bear: "\u{1F9F8}",
      pinata: "\u{1FA85}",
      nesting_dolls: "\u{1FA86}",
      spades: "\u2660\uFE0F",
      hearts: "\u2665\uFE0F",
      diamonds: "\u2666\uFE0F",
      clubs: "\u2663\uFE0F",
      chess_pawn: "\u265F\uFE0F",
      black_joker: "\u{1F0CF}",
      mahjong: "\u{1F004}",
      flower_playing_cards: "\u{1F3B4}",
      performing_arts: "\u{1F3AD}",
      framed_picture: "\u{1F5BC}\uFE0F",
      art: "\u{1F3A8}",
      thread: "\u{1F9F5}",
      sewing_needle: "\u{1FAA1}",
      yarn: "\u{1F9F6}",
      knot: "\u{1FAA2}",
      eyeglasses: "\u{1F453}",
      dark_sunglasses: "\u{1F576}\uFE0F",
      goggles: "\u{1F97D}",
      lab_coat: "\u{1F97C}",
      safety_vest: "\u{1F9BA}",
      necktie: "\u{1F454}",
      shirt: "\u{1F455}",
      tshirt: "\u{1F455}",
      jeans: "\u{1F456}",
      scarf: "\u{1F9E3}",
      gloves: "\u{1F9E4}",
      coat: "\u{1F9E5}",
      socks: "\u{1F9E6}",
      dress: "\u{1F457}",
      kimono: "\u{1F458}",
      sari: "\u{1F97B}",
      one_piece_swimsuit: "\u{1FA71}",
      swim_brief: "\u{1FA72}",
      shorts: "\u{1FA73}",
      bikini: "\u{1F459}",
      womans_clothes: "\u{1F45A}",
      purse: "\u{1F45B}",
      handbag: "\u{1F45C}",
      pouch: "\u{1F45D}",
      shopping: "\u{1F6CD}\uFE0F",
      school_satchel: "\u{1F392}",
      thong_sandal: "\u{1FA74}",
      mans_shoe: "\u{1F45E}",
      shoe: "\u{1F45E}",
      athletic_shoe: "\u{1F45F}",
      hiking_boot: "\u{1F97E}",
      flat_shoe: "\u{1F97F}",
      high_heel: "\u{1F460}",
      sandal: "\u{1F461}",
      ballet_shoes: "\u{1FA70}",
      boot: "\u{1F462}",
      crown: "\u{1F451}",
      womans_hat: "\u{1F452}",
      tophat: "\u{1F3A9}",
      mortar_board: "\u{1F393}",
      billed_cap: "\u{1F9E2}",
      military_helmet: "\u{1FA96}",
      rescue_worker_helmet: "\u26D1\uFE0F",
      prayer_beads: "\u{1F4FF}",
      lipstick: "\u{1F484}",
      ring: "\u{1F48D}",
      gem: "\u{1F48E}",
      mute: "\u{1F507}",
      speaker: "\u{1F508}",
      sound: "\u{1F509}",
      loud_sound: "\u{1F50A}",
      loudspeaker: "\u{1F4E2}",
      mega: "\u{1F4E3}",
      postal_horn: "\u{1F4EF}",
      bell: "\u{1F514}",
      no_bell: "\u{1F515}",
      musical_score: "\u{1F3BC}",
      musical_note: "\u{1F3B5}",
      notes: "\u{1F3B6}",
      studio_microphone: "\u{1F399}\uFE0F",
      level_slider: "\u{1F39A}\uFE0F",
      control_knobs: "\u{1F39B}\uFE0F",
      microphone: "\u{1F3A4}",
      headphones: "\u{1F3A7}",
      radio: "\u{1F4FB}",
      saxophone: "\u{1F3B7}",
      accordion: "\u{1FA97}",
      guitar: "\u{1F3B8}",
      musical_keyboard: "\u{1F3B9}",
      trumpet: "\u{1F3BA}",
      violin: "\u{1F3BB}",
      banjo: "\u{1FA95}",
      drum: "\u{1F941}",
      long_drum: "\u{1FA98}",
      iphone: "\u{1F4F1}",
      calling: "\u{1F4F2}",
      phone: "\u260E\uFE0F",
      telephone: "\u260E\uFE0F",
      telephone_receiver: "\u{1F4DE}",
      pager: "\u{1F4DF}",
      fax: "\u{1F4E0}",
      battery: "\u{1F50B}",
      electric_plug: "\u{1F50C}",
      computer: "\u{1F4BB}",
      desktop_computer: "\u{1F5A5}\uFE0F",
      printer: "\u{1F5A8}\uFE0F",
      keyboard: "\u2328\uFE0F",
      computer_mouse: "\u{1F5B1}\uFE0F",
      trackball: "\u{1F5B2}\uFE0F",
      minidisc: "\u{1F4BD}",
      floppy_disk: "\u{1F4BE}",
      cd: "\u{1F4BF}",
      dvd: "\u{1F4C0}",
      abacus: "\u{1F9EE}",
      movie_camera: "\u{1F3A5}",
      film_strip: "\u{1F39E}\uFE0F",
      film_projector: "\u{1F4FD}\uFE0F",
      clapper: "\u{1F3AC}",
      tv: "\u{1F4FA}",
      camera: "\u{1F4F7}",
      camera_flash: "\u{1F4F8}",
      video_camera: "\u{1F4F9}",
      vhs: "\u{1F4FC}",
      mag: "\u{1F50D}",
      mag_right: "\u{1F50E}",
      candle: "\u{1F56F}\uFE0F",
      bulb: "\u{1F4A1}",
      flashlight: "\u{1F526}",
      izakaya_lantern: "\u{1F3EE}",
      lantern: "\u{1F3EE}",
      diya_lamp: "\u{1FA94}",
      notebook_with_decorative_cover: "\u{1F4D4}",
      closed_book: "\u{1F4D5}",
      book: "\u{1F4D6}",
      open_book: "\u{1F4D6}",
      green_book: "\u{1F4D7}",
      blue_book: "\u{1F4D8}",
      orange_book: "\u{1F4D9}",
      books: "\u{1F4DA}",
      notebook: "\u{1F4D3}",
      ledger: "\u{1F4D2}",
      page_with_curl: "\u{1F4C3}",
      scroll: "\u{1F4DC}",
      page_facing_up: "\u{1F4C4}",
      newspaper: "\u{1F4F0}",
      newspaper_roll: "\u{1F5DE}\uFE0F",
      bookmark_tabs: "\u{1F4D1}",
      bookmark: "\u{1F516}",
      label: "\u{1F3F7}\uFE0F",
      moneybag: "\u{1F4B0}",
      coin: "\u{1FA99}",
      yen: "\u{1F4B4}",
      dollar: "\u{1F4B5}",
      euro: "\u{1F4B6}",
      pound: "\u{1F4B7}",
      money_with_wings: "\u{1F4B8}",
      credit_card: "\u{1F4B3}",
      receipt: "\u{1F9FE}",
      chart: "\u{1F4B9}",
      envelope: "\u2709\uFE0F",
      email: "\u{1F4E7}",
      "e-mail": "\u{1F4E7}",
      incoming_envelope: "\u{1F4E8}",
      envelope_with_arrow: "\u{1F4E9}",
      outbox_tray: "\u{1F4E4}",
      inbox_tray: "\u{1F4E5}",
      package: "\u{1F4E6}",
      mailbox: "\u{1F4EB}",
      mailbox_closed: "\u{1F4EA}",
      mailbox_with_mail: "\u{1F4EC}",
      mailbox_with_no_mail: "\u{1F4ED}",
      postbox: "\u{1F4EE}",
      ballot_box: "\u{1F5F3}\uFE0F",
      pencil2: "\u270F\uFE0F",
      black_nib: "\u2712\uFE0F",
      fountain_pen: "\u{1F58B}\uFE0F",
      pen: "\u{1F58A}\uFE0F",
      paintbrush: "\u{1F58C}\uFE0F",
      crayon: "\u{1F58D}\uFE0F",
      memo: "\u{1F4DD}",
      pencil: "\u{1F4DD}",
      briefcase: "\u{1F4BC}",
      file_folder: "\u{1F4C1}",
      open_file_folder: "\u{1F4C2}",
      card_index_dividers: "\u{1F5C2}\uFE0F",
      date: "\u{1F4C5}",
      calendar: "\u{1F4C6}",
      spiral_notepad: "\u{1F5D2}\uFE0F",
      spiral_calendar: "\u{1F5D3}\uFE0F",
      card_index: "\u{1F4C7}",
      chart_with_upwards_trend: "\u{1F4C8}",
      chart_with_downwards_trend: "\u{1F4C9}",
      bar_chart: "\u{1F4CA}",
      clipboard: "\u{1F4CB}",
      pushpin: "\u{1F4CC}",
      round_pushpin: "\u{1F4CD}",
      paperclip: "\u{1F4CE}",
      paperclips: "\u{1F587}\uFE0F",
      straight_ruler: "\u{1F4CF}",
      triangular_ruler: "\u{1F4D0}",
      scissors: "\u2702\uFE0F",
      card_file_box: "\u{1F5C3}\uFE0F",
      file_cabinet: "\u{1F5C4}\uFE0F",
      wastebasket: "\u{1F5D1}\uFE0F",
      lock: "\u{1F512}",
      unlock: "\u{1F513}",
      lock_with_ink_pen: "\u{1F50F}",
      closed_lock_with_key: "\u{1F510}",
      key: "\u{1F511}",
      old_key: "\u{1F5DD}\uFE0F",
      hammer: "\u{1F528}",
      axe: "\u{1FA93}",
      pick: "\u26CF\uFE0F",
      hammer_and_pick: "\u2692\uFE0F",
      hammer_and_wrench: "\u{1F6E0}\uFE0F",
      dagger: "\u{1F5E1}\uFE0F",
      crossed_swords: "\u2694\uFE0F",
      gun: "\u{1F52B}",
      boomerang: "\u{1FA83}",
      bow_and_arrow: "\u{1F3F9}",
      shield: "\u{1F6E1}\uFE0F",
      carpentry_saw: "\u{1FA9A}",
      wrench: "\u{1F527}",
      screwdriver: "\u{1FA9B}",
      nut_and_bolt: "\u{1F529}",
      gear: "\u2699\uFE0F",
      clamp: "\u{1F5DC}\uFE0F",
      balance_scale: "\u2696\uFE0F",
      probing_cane: "\u{1F9AF}",
      link: "\u{1F517}",
      chains: "\u26D3\uFE0F",
      hook: "\u{1FA9D}",
      toolbox: "\u{1F9F0}",
      magnet: "\u{1F9F2}",
      ladder: "\u{1FA9C}",
      alembic: "\u2697\uFE0F",
      test_tube: "\u{1F9EA}",
      petri_dish: "\u{1F9EB}",
      dna: "\u{1F9EC}",
      microscope: "\u{1F52C}",
      telescope: "\u{1F52D}",
      satellite: "\u{1F4E1}",
      syringe: "\u{1F489}",
      drop_of_blood: "\u{1FA78}",
      pill: "\u{1F48A}",
      adhesive_bandage: "\u{1FA79}",
      stethoscope: "\u{1FA7A}",
      door: "\u{1F6AA}",
      elevator: "\u{1F6D7}",
      mirror: "\u{1FA9E}",
      window: "\u{1FA9F}",
      bed: "\u{1F6CF}\uFE0F",
      couch_and_lamp: "\u{1F6CB}\uFE0F",
      chair: "\u{1FA91}",
      toilet: "\u{1F6BD}",
      plunger: "\u{1FAA0}",
      shower: "\u{1F6BF}",
      bathtub: "\u{1F6C1}",
      mouse_trap: "\u{1FAA4}",
      razor: "\u{1FA92}",
      lotion_bottle: "\u{1F9F4}",
      safety_pin: "\u{1F9F7}",
      broom: "\u{1F9F9}",
      basket: "\u{1F9FA}",
      roll_of_paper: "\u{1F9FB}",
      bucket: "\u{1FAA3}",
      soap: "\u{1F9FC}",
      toothbrush: "\u{1FAA5}",
      sponge: "\u{1F9FD}",
      fire_extinguisher: "\u{1F9EF}",
      shopping_cart: "\u{1F6D2}",
      smoking: "\u{1F6AC}",
      coffin: "\u26B0\uFE0F",
      headstone: "\u{1FAA6}",
      funeral_urn: "\u26B1\uFE0F",
      moyai: "\u{1F5FF}",
      placard: "\u{1FAA7}",
      atm: "\u{1F3E7}",
      put_litter_in_its_place: "\u{1F6AE}",
      potable_water: "\u{1F6B0}",
      wheelchair: "\u267F",
      mens: "\u{1F6B9}",
      womens: "\u{1F6BA}",
      restroom: "\u{1F6BB}",
      baby_symbol: "\u{1F6BC}",
      wc: "\u{1F6BE}",
      passport_control: "\u{1F6C2}",
      customs: "\u{1F6C3}",
      baggage_claim: "\u{1F6C4}",
      left_luggage: "\u{1F6C5}",
      warning: "\u26A0\uFE0F",
      children_crossing: "\u{1F6B8}",
      no_entry: "\u26D4",
      no_entry_sign: "\u{1F6AB}",
      no_bicycles: "\u{1F6B3}",
      no_smoking: "\u{1F6AD}",
      do_not_litter: "\u{1F6AF}",
      "non-potable_water": "\u{1F6B1}",
      no_pedestrians: "\u{1F6B7}",
      no_mobile_phones: "\u{1F4F5}",
      underage: "\u{1F51E}",
      radioactive: "\u2622\uFE0F",
      biohazard: "\u2623\uFE0F",
      arrow_up: "\u2B06\uFE0F",
      arrow_upper_right: "\u2197\uFE0F",
      arrow_right: "\u27A1\uFE0F",
      arrow_lower_right: "\u2198\uFE0F",
      arrow_down: "\u2B07\uFE0F",
      arrow_lower_left: "\u2199\uFE0F",
      arrow_left: "\u2B05\uFE0F",
      arrow_upper_left: "\u2196\uFE0F",
      arrow_up_down: "\u2195\uFE0F",
      left_right_arrow: "\u2194\uFE0F",
      leftwards_arrow_with_hook: "\u21A9\uFE0F",
      arrow_right_hook: "\u21AA\uFE0F",
      arrow_heading_up: "\u2934\uFE0F",
      arrow_heading_down: "\u2935\uFE0F",
      arrows_clockwise: "\u{1F503}",
      arrows_counterclockwise: "\u{1F504}",
      back: "\u{1F519}",
      end: "\u{1F51A}",
      on: "\u{1F51B}",
      soon: "\u{1F51C}",
      top: "\u{1F51D}",
      place_of_worship: "\u{1F6D0}",
      atom_symbol: "\u269B\uFE0F",
      om: "\u{1F549}\uFE0F",
      star_of_david: "\u2721\uFE0F",
      wheel_of_dharma: "\u2638\uFE0F",
      yin_yang: "\u262F\uFE0F",
      latin_cross: "\u271D\uFE0F",
      orthodox_cross: "\u2626\uFE0F",
      star_and_crescent: "\u262A\uFE0F",
      peace_symbol: "\u262E\uFE0F",
      menorah: "\u{1F54E}",
      six_pointed_star: "\u{1F52F}",
      aries: "\u2648",
      taurus: "\u2649",
      gemini: "\u264A",
      cancer: "\u264B",
      leo: "\u264C",
      virgo: "\u264D",
      libra: "\u264E",
      scorpius: "\u264F",
      sagittarius: "\u2650",
      capricorn: "\u2651",
      aquarius: "\u2652",
      pisces: "\u2653",
      ophiuchus: "\u26CE",
      twisted_rightwards_arrows: "\u{1F500}",
      repeat: "\u{1F501}",
      repeat_one: "\u{1F502}",
      arrow_forward: "\u25B6\uFE0F",
      fast_forward: "\u23E9",
      next_track_button: "\u23ED\uFE0F",
      play_or_pause_button: "\u23EF\uFE0F",
      arrow_backward: "\u25C0\uFE0F",
      rewind: "\u23EA",
      previous_track_button: "\u23EE\uFE0F",
      arrow_up_small: "\u{1F53C}",
      arrow_double_up: "\u23EB",
      arrow_down_small: "\u{1F53D}",
      arrow_double_down: "\u23EC",
      pause_button: "\u23F8\uFE0F",
      stop_button: "\u23F9\uFE0F",
      record_button: "\u23FA\uFE0F",
      eject_button: "\u23CF\uFE0F",
      cinema: "\u{1F3A6}",
      low_brightness: "\u{1F505}",
      high_brightness: "\u{1F506}",
      signal_strength: "\u{1F4F6}",
      vibration_mode: "\u{1F4F3}",
      mobile_phone_off: "\u{1F4F4}",
      female_sign: "\u2640\uFE0F",
      male_sign: "\u2642\uFE0F",
      transgender_symbol: "\u26A7\uFE0F",
      heavy_multiplication_x: "\u2716\uFE0F",
      heavy_plus_sign: "\u2795",
      heavy_minus_sign: "\u2796",
      heavy_division_sign: "\u2797",
      infinity: "\u267E\uFE0F",
      bangbang: "\u203C\uFE0F",
      interrobang: "\u2049\uFE0F",
      question: "\u2753",
      grey_question: "\u2754",
      grey_exclamation: "\u2755",
      exclamation: "\u2757",
      heavy_exclamation_mark: "\u2757",
      wavy_dash: "\u3030\uFE0F",
      currency_exchange: "\u{1F4B1}",
      heavy_dollar_sign: "\u{1F4B2}",
      medical_symbol: "\u2695\uFE0F",
      recycle: "\u267B\uFE0F",
      fleur_de_lis: "\u269C\uFE0F",
      trident: "\u{1F531}",
      name_badge: "\u{1F4DB}",
      beginner: "\u{1F530}",
      o: "\u2B55",
      white_check_mark: "\u2705",
      ballot_box_with_check: "\u2611\uFE0F",
      heavy_check_mark: "\u2714\uFE0F",
      x: "\u274C",
      negative_squared_cross_mark: "\u274E",
      curly_loop: "\u27B0",
      loop: "\u27BF",
      part_alternation_mark: "\u303D\uFE0F",
      eight_spoked_asterisk: "\u2733\uFE0F",
      eight_pointed_black_star: "\u2734\uFE0F",
      sparkle: "\u2747\uFE0F",
      copyright: "\xA9\uFE0F",
      registered: "\xAE\uFE0F",
      tm: "\u2122\uFE0F",
      hash: "#\uFE0F\u20E3",
      asterisk: "*\uFE0F\u20E3",
      zero: "0\uFE0F\u20E3",
      one: "1\uFE0F\u20E3",
      two: "2\uFE0F\u20E3",
      three: "3\uFE0F\u20E3",
      four: "4\uFE0F\u20E3",
      five: "5\uFE0F\u20E3",
      six: "6\uFE0F\u20E3",
      seven: "7\uFE0F\u20E3",
      eight: "8\uFE0F\u20E3",
      nine: "9\uFE0F\u20E3",
      keycap_ten: "\u{1F51F}",
      capital_abcd: "\u{1F520}",
      abcd: "\u{1F521}",
      symbols: "\u{1F523}",
      abc: "\u{1F524}",
      a: "\u{1F170}\uFE0F",
      ab: "\u{1F18E}",
      b: "\u{1F171}\uFE0F",
      cl: "\u{1F191}",
      cool: "\u{1F192}",
      free: "\u{1F193}",
      information_source: "\u2139\uFE0F",
      id: "\u{1F194}",
      m: "\u24C2\uFE0F",
      new: "\u{1F195}",
      ng: "\u{1F196}",
      o2: "\u{1F17E}\uFE0F",
      ok: "\u{1F197}",
      parking: "\u{1F17F}\uFE0F",
      sos: "\u{1F198}",
      up: "\u{1F199}",
      vs: "\u{1F19A}",
      koko: "\u{1F201}",
      sa: "\u{1F202}\uFE0F",
      ideograph_advantage: "\u{1F250}",
      accept: "\u{1F251}",
      congratulations: "\u3297\uFE0F",
      secret: "\u3299\uFE0F",
      u6e80: "\u{1F235}",
      red_circle: "\u{1F534}",
      orange_circle: "\u{1F7E0}",
      yellow_circle: "\u{1F7E1}",
      green_circle: "\u{1F7E2}",
      large_blue_circle: "\u{1F535}",
      purple_circle: "\u{1F7E3}",
      brown_circle: "\u{1F7E4}",
      black_circle: "\u26AB",
      white_circle: "\u26AA",
      red_square: "\u{1F7E5}",
      orange_square: "\u{1F7E7}",
      yellow_square: "\u{1F7E8}",
      green_square: "\u{1F7E9}",
      blue_square: "\u{1F7E6}",
      purple_square: "\u{1F7EA}",
      brown_square: "\u{1F7EB}",
      black_large_square: "\u2B1B",
      white_large_square: "\u2B1C",
      black_medium_square: "\u25FC\uFE0F",
      white_medium_square: "\u25FB\uFE0F",
      black_medium_small_square: "\u25FE",
      white_medium_small_square: "\u25FD",
      black_small_square: "\u25AA\uFE0F",
      white_small_square: "\u25AB\uFE0F",
      large_orange_diamond: "\u{1F536}",
      large_blue_diamond: "\u{1F537}",
      small_orange_diamond: "\u{1F538}",
      small_blue_diamond: "\u{1F539}",
      small_red_triangle: "\u{1F53A}",
      small_red_triangle_down: "\u{1F53B}",
      diamond_shape_with_a_dot_inside: "\u{1F4A0}",
      radio_button: "\u{1F518}",
      white_square_button: "\u{1F533}",
      black_square_button: "\u{1F532}",
      checkered_flag: "\u{1F3C1}",
      triangular_flag_on_post: "\u{1F6A9}",
      crossed_flags: "\u{1F38C}",
      black_flag: "\u{1F3F4}",
      white_flag: "\u{1F3F3}\uFE0F",
      rainbow_flag: "\u{1F3F3}\uFE0F\u200D\u{1F308}",
      transgender_flag: "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F",
      pirate_flag: "\u{1F3F4}\u200D\u2620\uFE0F",
      ascension_island: "\u{1F1E6}\u{1F1E8}",
      andorra: "\u{1F1E6}\u{1F1E9}",
      united_arab_emirates: "\u{1F1E6}\u{1F1EA}",
      afghanistan: "\u{1F1E6}\u{1F1EB}",
      antigua_barbuda: "\u{1F1E6}\u{1F1EC}",
      anguilla: "\u{1F1E6}\u{1F1EE}",
      albania: "\u{1F1E6}\u{1F1F1}",
      armenia: "\u{1F1E6}\u{1F1F2}",
      angola: "\u{1F1E6}\u{1F1F4}",
      antarctica: "\u{1F1E6}\u{1F1F6}",
      argentina: "\u{1F1E6}\u{1F1F7}",
      american_samoa: "\u{1F1E6}\u{1F1F8}",
      austria: "\u{1F1E6}\u{1F1F9}",
      australia: "\u{1F1E6}\u{1F1FA}",
      aruba: "\u{1F1E6}\u{1F1FC}",
      aland_islands: "\u{1F1E6}\u{1F1FD}",
      azerbaijan: "\u{1F1E6}\u{1F1FF}",
      bosnia_herzegovina: "\u{1F1E7}\u{1F1E6}",
      barbados: "\u{1F1E7}\u{1F1E7}",
      bangladesh: "\u{1F1E7}\u{1F1E9}",
      belgium: "\u{1F1E7}\u{1F1EA}",
      burkina_faso: "\u{1F1E7}\u{1F1EB}",
      bulgaria: "\u{1F1E7}\u{1F1EC}",
      bahrain: "\u{1F1E7}\u{1F1ED}",
      burundi: "\u{1F1E7}\u{1F1EE}",
      benin: "\u{1F1E7}\u{1F1EF}",
      st_barthelemy: "\u{1F1E7}\u{1F1F1}",
      bermuda: "\u{1F1E7}\u{1F1F2}",
      brunei: "\u{1F1E7}\u{1F1F3}",
      bolivia: "\u{1F1E7}\u{1F1F4}",
      caribbean_netherlands: "\u{1F1E7}\u{1F1F6}",
      brazil: "\u{1F1E7}\u{1F1F7}",
      bahamas: "\u{1F1E7}\u{1F1F8}",
      bhutan: "\u{1F1E7}\u{1F1F9}",
      bouvet_island: "\u{1F1E7}\u{1F1FB}",
      botswana: "\u{1F1E7}\u{1F1FC}",
      belarus: "\u{1F1E7}\u{1F1FE}",
      belize: "\u{1F1E7}\u{1F1FF}",
      canada: "\u{1F1E8}\u{1F1E6}",
      cocos_islands: "\u{1F1E8}\u{1F1E8}",
      congo_kinshasa: "\u{1F1E8}\u{1F1E9}",
      central_african_republic: "\u{1F1E8}\u{1F1EB}",
      congo_brazzaville: "\u{1F1E8}\u{1F1EC}",
      switzerland: "\u{1F1E8}\u{1F1ED}",
      cote_divoire: "\u{1F1E8}\u{1F1EE}",
      cook_islands: "\u{1F1E8}\u{1F1F0}",
      chile: "\u{1F1E8}\u{1F1F1}",
      cameroon: "\u{1F1E8}\u{1F1F2}",
      cn: "\u{1F1E8}\u{1F1F3}",
      colombia: "\u{1F1E8}\u{1F1F4}",
      clipperton_island: "\u{1F1E8}\u{1F1F5}",
      costa_rica: "\u{1F1E8}\u{1F1F7}",
      cuba: "\u{1F1E8}\u{1F1FA}",
      cape_verde: "\u{1F1E8}\u{1F1FB}",
      curacao: "\u{1F1E8}\u{1F1FC}",
      christmas_island: "\u{1F1E8}\u{1F1FD}",
      cyprus: "\u{1F1E8}\u{1F1FE}",
      czech_republic: "\u{1F1E8}\u{1F1FF}",
      de: "\u{1F1E9}\u{1F1EA}",
      diego_garcia: "\u{1F1E9}\u{1F1EC}",
      djibouti: "\u{1F1E9}\u{1F1EF}",
      denmark: "\u{1F1E9}\u{1F1F0}",
      dominica: "\u{1F1E9}\u{1F1F2}",
      dominican_republic: "\u{1F1E9}\u{1F1F4}",
      algeria: "\u{1F1E9}\u{1F1FF}",
      ceuta_melilla: "\u{1F1EA}\u{1F1E6}",
      ecuador: "\u{1F1EA}\u{1F1E8}",
      estonia: "\u{1F1EA}\u{1F1EA}",
      egypt: "\u{1F1EA}\u{1F1EC}",
      western_sahara: "\u{1F1EA}\u{1F1ED}",
      eritrea: "\u{1F1EA}\u{1F1F7}",
      es: "\u{1F1EA}\u{1F1F8}",
      ethiopia: "\u{1F1EA}\u{1F1F9}",
      eu: "\u{1F1EA}\u{1F1FA}",
      european_union: "\u{1F1EA}\u{1F1FA}",
      finland: "\u{1F1EB}\u{1F1EE}",
      fiji: "\u{1F1EB}\u{1F1EF}",
      falkland_islands: "\u{1F1EB}\u{1F1F0}",
      micronesia: "\u{1F1EB}\u{1F1F2}",
      faroe_islands: "\u{1F1EB}\u{1F1F4}",
      fr: "\u{1F1EB}\u{1F1F7}",
      gabon: "\u{1F1EC}\u{1F1E6}",
      gb: "\u{1F1EC}\u{1F1E7}",
      uk: "\u{1F1EC}\u{1F1E7}",
      grenada: "\u{1F1EC}\u{1F1E9}",
      georgia: "\u{1F1EC}\u{1F1EA}",
      french_guiana: "\u{1F1EC}\u{1F1EB}",
      guernsey: "\u{1F1EC}\u{1F1EC}",
      ghana: "\u{1F1EC}\u{1F1ED}",
      gibraltar: "\u{1F1EC}\u{1F1EE}",
      greenland: "\u{1F1EC}\u{1F1F1}",
      gambia: "\u{1F1EC}\u{1F1F2}",
      guinea: "\u{1F1EC}\u{1F1F3}",
      guadeloupe: "\u{1F1EC}\u{1F1F5}",
      equatorial_guinea: "\u{1F1EC}\u{1F1F6}",
      greece: "\u{1F1EC}\u{1F1F7}",
      south_georgia_south_sandwich_islands: "\u{1F1EC}\u{1F1F8}",
      guatemala: "\u{1F1EC}\u{1F1F9}",
      guam: "\u{1F1EC}\u{1F1FA}",
      guinea_bissau: "\u{1F1EC}\u{1F1FC}",
      guyana: "\u{1F1EC}\u{1F1FE}",
      hong_kong: "\u{1F1ED}\u{1F1F0}",
      heard_mcdonald_islands: "\u{1F1ED}\u{1F1F2}",
      honduras: "\u{1F1ED}\u{1F1F3}",
      croatia: "\u{1F1ED}\u{1F1F7}",
      haiti: "\u{1F1ED}\u{1F1F9}",
      hungary: "\u{1F1ED}\u{1F1FA}",
      canary_islands: "\u{1F1EE}\u{1F1E8}",
      indonesia: "\u{1F1EE}\u{1F1E9}",
      ireland: "\u{1F1EE}\u{1F1EA}",
      israel: "\u{1F1EE}\u{1F1F1}",
      isle_of_man: "\u{1F1EE}\u{1F1F2}",
      india: "\u{1F1EE}\u{1F1F3}",
      british_indian_ocean_territory: "\u{1F1EE}\u{1F1F4}",
      iraq: "\u{1F1EE}\u{1F1F6}",
      iran: "\u{1F1EE}\u{1F1F7}",
      iceland: "\u{1F1EE}\u{1F1F8}",
      it: "\u{1F1EE}\u{1F1F9}",
      jersey: "\u{1F1EF}\u{1F1EA}",
      jamaica: "\u{1F1EF}\u{1F1F2}",
      jordan: "\u{1F1EF}\u{1F1F4}",
      jp: "\u{1F1EF}\u{1F1F5}",
      kenya: "\u{1F1F0}\u{1F1EA}",
      kyrgyzstan: "\u{1F1F0}\u{1F1EC}",
      cambodia: "\u{1F1F0}\u{1F1ED}",
      kiribati: "\u{1F1F0}\u{1F1EE}",
      comoros: "\u{1F1F0}\u{1F1F2}",
      st_kitts_nevis: "\u{1F1F0}\u{1F1F3}",
      north_korea: "\u{1F1F0}\u{1F1F5}",
      kr: "\u{1F1F0}\u{1F1F7}",
      kuwait: "\u{1F1F0}\u{1F1FC}",
      cayman_islands: "\u{1F1F0}\u{1F1FE}",
      kazakhstan: "\u{1F1F0}\u{1F1FF}",
      laos: "\u{1F1F1}\u{1F1E6}",
      lebanon: "\u{1F1F1}\u{1F1E7}",
      st_lucia: "\u{1F1F1}\u{1F1E8}",
      liechtenstein: "\u{1F1F1}\u{1F1EE}",
      sri_lanka: "\u{1F1F1}\u{1F1F0}",
      liberia: "\u{1F1F1}\u{1F1F7}",
      lesotho: "\u{1F1F1}\u{1F1F8}",
      lithuania: "\u{1F1F1}\u{1F1F9}",
      luxembourg: "\u{1F1F1}\u{1F1FA}",
      latvia: "\u{1F1F1}\u{1F1FB}",
      libya: "\u{1F1F1}\u{1F1FE}",
      morocco: "\u{1F1F2}\u{1F1E6}",
      monaco: "\u{1F1F2}\u{1F1E8}",
      moldova: "\u{1F1F2}\u{1F1E9}",
      montenegro: "\u{1F1F2}\u{1F1EA}",
      st_martin: "\u{1F1F2}\u{1F1EB}",
      madagascar: "\u{1F1F2}\u{1F1EC}",
      marshall_islands: "\u{1F1F2}\u{1F1ED}",
      macedonia: "\u{1F1F2}\u{1F1F0}",
      mali: "\u{1F1F2}\u{1F1F1}",
      myanmar: "\u{1F1F2}\u{1F1F2}",
      mongolia: "\u{1F1F2}\u{1F1F3}",
      macau: "\u{1F1F2}\u{1F1F4}",
      northern_mariana_islands: "\u{1F1F2}\u{1F1F5}",
      martinique: "\u{1F1F2}\u{1F1F6}",
      mauritania: "\u{1F1F2}\u{1F1F7}",
      montserrat: "\u{1F1F2}\u{1F1F8}",
      malta: "\u{1F1F2}\u{1F1F9}",
      mauritius: "\u{1F1F2}\u{1F1FA}",
      maldives: "\u{1F1F2}\u{1F1FB}",
      malawi: "\u{1F1F2}\u{1F1FC}",
      mexico: "\u{1F1F2}\u{1F1FD}",
      malaysia: "\u{1F1F2}\u{1F1FE}",
      mozambique: "\u{1F1F2}\u{1F1FF}",
      namibia: "\u{1F1F3}\u{1F1E6}",
      new_caledonia: "\u{1F1F3}\u{1F1E8}",
      niger: "\u{1F1F3}\u{1F1EA}",
      norfolk_island: "\u{1F1F3}\u{1F1EB}",
      nigeria: "\u{1F1F3}\u{1F1EC}",
      nicaragua: "\u{1F1F3}\u{1F1EE}",
      netherlands: "\u{1F1F3}\u{1F1F1}",
      norway: "\u{1F1F3}\u{1F1F4}",
      nepal: "\u{1F1F3}\u{1F1F5}",
      nauru: "\u{1F1F3}\u{1F1F7}",
      niue: "\u{1F1F3}\u{1F1FA}",
      new_zealand: "\u{1F1F3}\u{1F1FF}",
      oman: "\u{1F1F4}\u{1F1F2}",
      panama: "\u{1F1F5}\u{1F1E6}",
      peru: "\u{1F1F5}\u{1F1EA}",
      french_polynesia: "\u{1F1F5}\u{1F1EB}",
      papua_new_guinea: "\u{1F1F5}\u{1F1EC}",
      philippines: "\u{1F1F5}\u{1F1ED}",
      pakistan: "\u{1F1F5}\u{1F1F0}",
      poland: "\u{1F1F5}\u{1F1F1}",
      st_pierre_miquelon: "\u{1F1F5}\u{1F1F2}",
      pitcairn_islands: "\u{1F1F5}\u{1F1F3}",
      puerto_rico: "\u{1F1F5}\u{1F1F7}",
      palestinian_territories: "\u{1F1F5}\u{1F1F8}",
      portugal: "\u{1F1F5}\u{1F1F9}",
      palau: "\u{1F1F5}\u{1F1FC}",
      paraguay: "\u{1F1F5}\u{1F1FE}",
      qatar: "\u{1F1F6}\u{1F1E6}",
      reunion: "\u{1F1F7}\u{1F1EA}",
      romania: "\u{1F1F7}\u{1F1F4}",
      serbia: "\u{1F1F7}\u{1F1F8}",
      ru: "\u{1F1F7}\u{1F1FA}",
      rwanda: "\u{1F1F7}\u{1F1FC}",
      saudi_arabia: "\u{1F1F8}\u{1F1E6}",
      solomon_islands: "\u{1F1F8}\u{1F1E7}",
      seychelles: "\u{1F1F8}\u{1F1E8}",
      sudan: "\u{1F1F8}\u{1F1E9}",
      sweden: "\u{1F1F8}\u{1F1EA}",
      singapore: "\u{1F1F8}\u{1F1EC}",
      st_helena: "\u{1F1F8}\u{1F1ED}",
      slovenia: "\u{1F1F8}\u{1F1EE}",
      svalbard_jan_mayen: "\u{1F1F8}\u{1F1EF}",
      slovakia: "\u{1F1F8}\u{1F1F0}",
      sierra_leone: "\u{1F1F8}\u{1F1F1}",
      san_marino: "\u{1F1F8}\u{1F1F2}",
      senegal: "\u{1F1F8}\u{1F1F3}",
      somalia: "\u{1F1F8}\u{1F1F4}",
      suriname: "\u{1F1F8}\u{1F1F7}",
      south_sudan: "\u{1F1F8}\u{1F1F8}",
      sao_tome_principe: "\u{1F1F8}\u{1F1F9}",
      el_salvador: "\u{1F1F8}\u{1F1FB}",
      sint_maarten: "\u{1F1F8}\u{1F1FD}",
      syria: "\u{1F1F8}\u{1F1FE}",
      swaziland: "\u{1F1F8}\u{1F1FF}",
      tristan_da_cunha: "\u{1F1F9}\u{1F1E6}",
      turks_caicos_islands: "\u{1F1F9}\u{1F1E8}",
      chad: "\u{1F1F9}\u{1F1E9}",
      french_southern_territories: "\u{1F1F9}\u{1F1EB}",
      togo: "\u{1F1F9}\u{1F1EC}",
      thailand: "\u{1F1F9}\u{1F1ED}",
      tajikistan: "\u{1F1F9}\u{1F1EF}",
      tokelau: "\u{1F1F9}\u{1F1F0}",
      timor_leste: "\u{1F1F9}\u{1F1F1}",
      turkmenistan: "\u{1F1F9}\u{1F1F2}",
      tunisia: "\u{1F1F9}\u{1F1F3}",
      tonga: "\u{1F1F9}\u{1F1F4}",
      tr: "\u{1F1F9}\u{1F1F7}",
      trinidad_tobago: "\u{1F1F9}\u{1F1F9}",
      tuvalu: "\u{1F1F9}\u{1F1FB}",
      taiwan: "\u{1F1F9}\u{1F1FC}",
      tanzania: "\u{1F1F9}\u{1F1FF}",
      ukraine: "\u{1F1FA}\u{1F1E6}",
      uganda: "\u{1F1FA}\u{1F1EC}",
      us_outlying_islands: "\u{1F1FA}\u{1F1F2}",
      united_nations: "\u{1F1FA}\u{1F1F3}",
      us: "\u{1F1FA}\u{1F1F8}",
      uruguay: "\u{1F1FA}\u{1F1FE}",
      uzbekistan: "\u{1F1FA}\u{1F1FF}",
      vatican_city: "\u{1F1FB}\u{1F1E6}",
      st_vincent_grenadines: "\u{1F1FB}\u{1F1E8}",
      venezuela: "\u{1F1FB}\u{1F1EA}",
      british_virgin_islands: "\u{1F1FB}\u{1F1EC}",
      us_virgin_islands: "\u{1F1FB}\u{1F1EE}",
      vietnam: "\u{1F1FB}\u{1F1F3}",
      vanuatu: "\u{1F1FB}\u{1F1FA}",
      wallis_futuna: "\u{1F1FC}\u{1F1EB}",
      samoa: "\u{1F1FC}\u{1F1F8}",
      kosovo: "\u{1F1FD}\u{1F1F0}",
      yemen: "\u{1F1FE}\u{1F1EA}",
      mayotte: "\u{1F1FE}\u{1F1F9}",
      south_africa: "\u{1F1FF}\u{1F1E6}",
      zambia: "\u{1F1FF}\u{1F1F2}",
      zimbabwe: "\u{1F1FF}\u{1F1FC}",
      england: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
      scotland: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
      wales: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}"
    };
  }
});

// node_modules/markdown-it-emoji/lib/data/shortcuts.js
var require_shortcuts = __commonJS({
  "node_modules/markdown-it-emoji/lib/data/shortcuts.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = {
      angry: [">:(", ">:-("],
      blush: [':")', ':-")'],
      broken_heart: ["</3", "<\\3"],
      confused: [":/", ":-/"],
      cry: [":'(", ":'-(", ":,(", ":,-("],
      frowning: [":(", ":-("],
      heart: ["<3"],
      imp: ["]:(", "]:-("],
      innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
      joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
      kissing: [":*", ":-*"],
      laughing: ["x-)", "X-)"],
      neutral_face: [":|", ":-|"],
      open_mouth: [":o", ":-o", ":O", ":-O"],
      rage: [":@", ":-@"],
      smile: [":D", ":-D"],
      smiley: [":)", ":-)"],
      smiling_imp: ["]:)", "]:-)"],
      sob: [":,'(", ":,'-(", ";(", ";-("],
      stuck_out_tongue: [":P", ":-P"],
      sunglasses: ["8-)", "B-)"],
      sweat: [",:(", ",:-("],
      sweat_smile: [",:)", ",:-)"],
      unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
      wink: [";)", ";-)"]
    };
  }
});

// node_modules/markdown-it-emoji/lib/render.js
var require_render = __commonJS({
  "node_modules/markdown-it-emoji/lib/render.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function emoji_html(tokens, idx) {
      return tokens[idx].content;
    };
  }
});

// node_modules/markdown-it-emoji/lib/replace.js
var require_replace = __commonJS({
  "node_modules/markdown-it-emoji/lib/replace.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function create_rule(md, emojies, shortcuts, scanRE, replaceRE) {
      var arrayReplaceAt = md.utils.arrayReplaceAt, ucm = md.utils.lib.ucmicro, ZPCc = new RegExp([ucm.Z.source, ucm.P.source, ucm.Cc.source].join("|"));
      function splitTextToken(text, level, Token) {
        var token, last_pos = 0, nodes = [];
        text.replace(replaceRE, function(match, offset, src) {
          var emoji_name;
          if (shortcuts.hasOwnProperty(match)) {
            emoji_name = shortcuts[match];
            if (offset > 0 && !ZPCc.test(src[offset - 1])) {
              return;
            }
            if (offset + match.length < src.length && !ZPCc.test(src[offset + match.length])) {
              return;
            }
          } else {
            emoji_name = match.slice(1, -1);
          }
          if (offset > last_pos) {
            token = new Token("text", "", 0);
            token.content = text.slice(last_pos, offset);
            nodes.push(token);
          }
          token = new Token("emoji", "", 0);
          token.markup = emoji_name;
          token.content = emojies[emoji_name];
          nodes.push(token);
          last_pos = offset + match.length;
        });
        if (last_pos < text.length) {
          token = new Token("text", "", 0);
          token.content = text.slice(last_pos);
          nodes.push(token);
        }
        return nodes;
      }
      return function emoji_replace(state) {
        var i2, j, l2, tokens, token, blockTokens = state.tokens, autolinkLevel = 0;
        for (j = 0, l2 = blockTokens.length; j < l2; j++) {
          if (blockTokens[j].type !== "inline") {
            continue;
          }
          tokens = blockTokens[j].children;
          for (i2 = tokens.length - 1; i2 >= 0; i2--) {
            token = tokens[i2];
            if (token.type === "link_open" || token.type === "link_close") {
              if (token.info === "auto") {
                autolinkLevel -= token.nesting;
              }
            }
            if (token.type === "text" && autolinkLevel === 0 && scanRE.test(token.content)) {
              blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, splitTextToken(token.content, token.level, state.Token));
            }
          }
        }
      };
    };
  }
});

// node_modules/markdown-it-emoji/lib/normalize_opts.js
var require_normalize_opts = __commonJS({
  "node_modules/markdown-it-emoji/lib/normalize_opts.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function quoteRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    module2.exports = function normalize_opts(options2) {
      var emojies = options2.defs, shortcuts;
      if (options2.enabled.length) {
        emojies = Object.keys(emojies).reduce(function(acc, key) {
          if (options2.enabled.indexOf(key) >= 0) {
            acc[key] = emojies[key];
          }
          return acc;
        }, {});
      }
      shortcuts = Object.keys(options2.shortcuts).reduce(function(acc, key) {
        if (!emojies[key]) {
          return acc;
        }
        if (Array.isArray(options2.shortcuts[key])) {
          options2.shortcuts[key].forEach(function(alias) {
            acc[alias] = key;
          });
          return acc;
        }
        acc[options2.shortcuts[key]] = key;
        return acc;
      }, {});
      var keys = Object.keys(emojies), names;
      if (keys.length === 0) {
        names = "^$";
      } else {
        names = keys.map(function(name) {
          return ":" + name + ":";
        }).concat(Object.keys(shortcuts)).sort().reverse().map(function(name) {
          return quoteRE(name);
        }).join("|");
      }
      var scanRE = RegExp(names);
      var replaceRE = RegExp(names, "g");
      return {
        defs: emojies,
        shortcuts,
        scanRE,
        replaceRE
      };
    };
  }
});

// node_modules/markdown-it-emoji/bare.js
var require_bare = __commonJS({
  "node_modules/markdown-it-emoji/bare.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var emoji_html = require_render();
    var emoji_replace = require_replace();
    var normalize_opts = require_normalize_opts();
    module2.exports = function emoji_plugin(md, options2) {
      var defaults = {
        defs: {},
        shortcuts: {},
        enabled: []
      };
      var opts = normalize_opts(md.utils.assign({}, defaults, options2 || {}));
      md.renderer.rules.emoji = emoji_html;
      md.core.ruler.after("linkify", "emoji", emoji_replace(md, opts.defs, opts.shortcuts, opts.scanRE, opts.replaceRE));
    };
  }
});

// node_modules/markdown-it-emoji/index.js
var require_markdown_it_emoji = __commonJS({
  "node_modules/markdown-it-emoji/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var emojies_defs = require_full();
    var emojies_shortcuts = require_shortcuts();
    var bare_emoji_plugin = require_bare();
    module2.exports = function emoji_plugin(md, options2) {
      var defaults = {
        defs: emojies_defs,
        shortcuts: emojies_shortcuts,
        enabled: []
      };
      var opts = md.utils.assign({}, defaults, options2 || {});
      bare_emoji_plugin(md, opts);
    };
  }
});

// node_modules/@vuepress/markdown/lib/plugins/emojiPlugin.js
var require_emojiPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/emojiPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.emojiPlugin = void 0;
    var rawEmojiPlugin = require_markdown_it_emoji();
    exports2.emojiPlugin = rawEmojiPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/utils/resolveTitleFromToken.js
var require_resolveTitleFromToken = __commonJS({
  "node_modules/@vuepress/markdown/lib/utils/resolveTitleFromToken.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveTitleFromToken = void 0;
    var shared_1 = require_dist();
    var resolveTitleFromToken = (token, { allowHtml, escapeText }) => {
      var _a;
      const children = (_a = token.children) != null ? _a : [];
      const titleTokenTypes = ["text", "emoji", "code_inline"];
      if (allowHtml) {
        titleTokenTypes.push("html_inline");
      }
      const titleTokens = children.filter((item) => {
        var _a2;
        return titleTokenTypes.includes(item.type) && !((_a2 = item.meta) == null ? void 0 : _a2.isPermalinkSymbol);
      });
      return titleTokens.reduce((result, item) => {
        if (escapeText) {
          if (item.type === "code_inline" || item.type === "text") {
            return `${result}${(0, shared_1.htmlEscape)(item.content)}`;
          }
        }
        return `${result}${item.content}`;
      }, "").trim();
    };
    exports2.resolveTitleFromToken = resolveTitleFromToken;
  }
});

// node_modules/@vuepress/markdown/lib/utils/resolveHeadersFromTokens.js
var require_resolveHeadersFromTokens = __commonJS({
  "node_modules/@vuepress/markdown/lib/utils/resolveHeadersFromTokens.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveHeadersFromTokens = void 0;
    var shared_1 = require_dist();
    var resolveTitleFromToken_1 = require_resolveTitleFromToken();
    var resolveHeadersFromTokens = (tokens, { level, allowHtml, escapeText, slugify, format }) => {
      const headers = [];
      const stack = [];
      const push = (header) => {
        while (stack.length !== 0 && header.level <= stack[0].level) {
          stack.shift();
        }
        if (stack.length === 0) {
          headers.push(header);
          stack.push(header);
        } else {
          stack[0].children.push(header);
          stack.unshift(header);
        }
      };
      tokens.forEach((_, idx) => {
        var _a;
        const token = tokens[idx];
        if ((token == null ? void 0 : token.type) !== "heading_open") {
          return;
        }
        const headerLevel = Number.parseInt(token.tag.slice(1), 10);
        if (!level.includes(headerLevel)) {
          return;
        }
        const nextToken = tokens[idx + 1];
        if (!nextToken) {
          return;
        }
        const title = (0, resolveTitleFromToken_1.resolveTitleFromToken)(nextToken, {
          allowHtml,
          escapeText
        });
        const slug = (_a = token.attrGet("id")) != null ? _a : slugify(title);
        push({
          level: headerLevel,
          title: (0, shared_1.isFunction)(format) ? format(title) : title,
          slug,
          children: []
        });
      });
      return headers;
    };
    exports2.resolveHeadersFromTokens = resolveHeadersFromTokens;
  }
});

// node_modules/@vuepress/markdown/lib/utils/slugify.js
var require_slugify = __commonJS({
  "node_modules/@vuepress/markdown/lib/utils/slugify.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.slugify = void 0;
    var rControl = /[\u0000-\u001f]/g;
    var rSpecial = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g;
    var rCombining = /[\u0300-\u036F]/g;
    var slugify = (str2) => str2.normalize("NFKD").replace(rCombining, "").replace(rControl, "").replace(rSpecial, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase();
    exports2.slugify = slugify;
  }
});

// node_modules/@vuepress/markdown/lib/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/utils/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_resolveHeadersFromTokens(), exports2);
    __exportStar(require_resolveTitleFromToken(), exports2);
    __exportStar(require_slugify(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/extractHeadersPlugin.js
var require_extractHeadersPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/extractHeadersPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractHeadersPlugin = void 0;
    var utils_1 = require_utils2();
    var extractHeadersPlugin = (md, { level = [2, 3], slugify = utils_1.slugify, format } = {}) => {
      let headers;
      md.core.ruler.push("resolveExtractHeaders", (state) => {
        headers = (0, utils_1.resolveHeadersFromTokens)(state.tokens, {
          level,
          allowHtml: false,
          escapeText: false,
          slugify,
          format
        });
        return true;
      });
      const render = md.render.bind(md);
      md.render = (src, env = {}) => {
        const result = render(src, env);
        env.headers = headers;
        return result;
      };
    };
    exports2.extractHeadersPlugin = extractHeadersPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/extractTitlePlugin.js
var require_extractTitlePlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/extractTitlePlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractTitlePlugin = void 0;
    var utils_1 = require_utils2();
    var extractTitlePlugin = (md) => {
      let title;
      md.core.ruler.push("resolveExtractTitle", (state) => {
        const tokenIdx = state.tokens.findIndex((token) => token.tag === "h1");
        if (tokenIdx > -1) {
          title = (0, utils_1.resolveTitleFromToken)(state.tokens[tokenIdx + 1], {
            escapeText: false,
            allowHtml: false
          });
        } else {
          title = "";
        }
        return true;
      });
      const render = md.render.bind(md);
      md.render = (src, env = {}) => {
        var _a, _b;
        const result = render(src, env);
        env.title = (_b = (_a = env.frontmatter) == null ? void 0 : _a.title) != null ? _b : title;
        return result;
      };
    };
    exports2.extractTitlePlugin = extractTitlePlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/hoistTagsPlugin.js
var require_hoistTagsPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/hoistTagsPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hoistTagsPlugin = void 0;
    var hoistTagsPlugin = (md, { customBlocks = [] } = {}) => {
      const hoistTags = Array.from(/* @__PURE__ */ new Set(["script", "style", ...customBlocks]));
      const hoistTagsRegexp = new RegExp(`^<(${hoistTags.join("|")})(?=(\\s|>|$))`, "i");
      const rawRule = md.renderer.rules.html_block;
      md.renderer.rules.html_block = (tokens, idx, options2, env, self2) => {
        const content = tokens[idx].content;
        const hoistedTags = env.hoistedTags || (env.hoistedTags = []);
        if (hoistTagsRegexp.test(content.trim())) {
          hoistedTags.push(content);
          return "";
        }
        return rawRule(tokens, idx, options2, env, self2);
      };
    };
    exports2.hoistTagsPlugin = hoistTagsPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/createImportCodeBlockRule.js
var require_createImportCodeBlockRule = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/createImportCodeBlockRule.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createImportCodeBlockRule = void 0;
    var utils_1 = require_lib();
    var MIN_LENGTH = 9;
    var START_CODES = [64, 91, 99, 111, 100, 101];
    var SYNTAX_RE = /^@\[code(?:{(?:(\d+)?-(\d+)?)})?(?: ([^\]]+))?\]\(([^)]*)\)/;
    var createImportCodeBlockRule = ({ handleImportPath = (str2) => str2 }) => (state, startLine, endLine, silent) => {
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      const pos = state.bMarks[startLine] + state.tShift[startLine];
      const max = state.eMarks[startLine];
      if (pos + MIN_LENGTH > max)
        return false;
      for (let i2 = 0; i2 < START_CODES.length; i2 += 1) {
        if (state.src.charCodeAt(pos + i2) !== START_CODES[i2]) {
          return false;
        }
      }
      const match = state.src.slice(pos, max).match(SYNTAX_RE);
      if (!match)
        return false;
      if (silent)
        return true;
      const [, lineStart, lineEnd, info, importPath] = match;
      const meta = {
        importPath: handleImportPath(importPath),
        lineStart: lineStart ? Number.parseInt(lineStart, 10) : 0,
        lineEnd: lineEnd ? Number.parseInt(lineEnd, 10) : void 0
      };
      const token = state.push("import_code", "code", 0);
      token.info = info != null ? info : utils_1.path.extname(meta.importPath).slice(1);
      token.markup = "```";
      token.map = [startLine, startLine + 1];
      token.meta = meta;
      state.line = startLine + 1;
      return true;
    };
    exports2.createImportCodeBlockRule = createImportCodeBlockRule;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/resolveImportCode.js
var require_resolveImportCode = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/resolveImportCode.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveImportCode = void 0;
    var utils_1 = require_lib();
    var resolveImportCode = ({ importPath, lineStart, lineEnd }, { filePath }) => {
      let importFilePath = importPath;
      if (!utils_1.path.isAbsolute(importPath)) {
        if (!filePath) {
          return {
            importFilePath: null,
            importCode: "Error when resolving path"
          };
        }
        importFilePath = utils_1.path.resolve(filePath, "..", importPath);
      }
      if (!utils_1.fs.existsSync(importFilePath)) {
        return {
          importFilePath,
          importCode: "File not found"
        };
      }
      const fileContent = utils_1.fs.readFileSync(importFilePath).toString();
      return {
        importFilePath,
        importCode: fileContent.split("\n").slice(lineStart ? lineStart - 1 : lineStart, lineEnd).join("\n").replace(/\n?$/, "\n")
      };
    };
    exports2.resolveImportCode = resolveImportCode;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/importCodePlugin.js
var require_importCodePlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/importCodePlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.importCodePlugin = void 0;
    var createImportCodeBlockRule_1 = require_createImportCodeBlockRule();
    var resolveImportCode_1 = require_resolveImportCode();
    var importCodePlugin = (md, options2 = {}) => {
      md.block.ruler.before("fence", "import_code", (0, createImportCodeBlockRule_1.createImportCodeBlockRule)(options2), {
        alt: ["paragraph", "reference", "blockquote", "list"]
      });
      md.renderer.rules.import_code = (tokens, idx, options3, env, slf) => {
        const token = tokens[idx];
        const { importFilePath, importCode } = (0, resolveImportCode_1.resolveImportCode)(token.meta, env);
        token.content = importCode;
        if (importFilePath) {
          const importedFiles = env.importedFiles || (env.importedFiles = []);
          importedFiles.push(importFilePath);
        }
        return md.renderer.rules.fence(tokens, idx, options3, env, slf);
      };
    };
    exports2.importCodePlugin = importCodePlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/types.js
var require_types = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/types.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/index.js
var require_importCodePlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/importCodePlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createImportCodeBlockRule(), exports2);
    __exportStar(require_importCodePlugin(), exports2);
    __exportStar(require_resolveImportCode(), exports2);
    __exportStar(require_types(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/linksPlugin/resolvePaths.js
var require_resolvePaths = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/linksPlugin/resolvePaths.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePaths = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var resolvePaths = (rawPath, base, filePathRelative) => {
      let absolutePath;
      let relativePath;
      if (rawPath.startsWith("/")) {
        if (rawPath.endsWith(".md")) {
          absolutePath = utils_1.path.join(base, rawPath);
          relativePath = (0, shared_1.removeLeadingSlash)(rawPath);
        } else {
          absolutePath = rawPath;
          relativePath = utils_1.path.relative(base, absolutePath);
        }
      } else {
        if (filePathRelative) {
          relativePath = utils_1.path.join(utils_1.path.dirname(encodeURI(filePathRelative)), rawPath);
          absolutePath = utils_1.path.join(base, relativePath);
        } else {
          relativePath = rawPath.replace(/^(?:\.\/)?(.*)$/, "$1");
          absolutePath = relativePath;
        }
      }
      return {
        absolutePath,
        relativePath
      };
    };
    exports2.resolvePaths = resolvePaths;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/linksPlugin/linksPlugin.js
var require_linksPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/linksPlugin/linksPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.linksPlugin = void 0;
    var shared_1 = require_dist();
    var resolvePaths_1 = require_resolvePaths();
    var linksPlugin = (md, options2 = {}) => {
      const internalTag = options2.internalTag || "RouterLink";
      const externalAttrs = __spreadValues({
        target: "_blank",
        rel: "noopener noreferrer"
      }, options2.externalAttrs);
      let hasOpenInternalLink = false;
      const handleLinkOpen = (tokens, idx, env) => {
        const token = tokens[idx];
        const hrefIndex = token.attrIndex("href");
        if (hrefIndex < 0) {
          return;
        }
        const hrefAttr = token.attrs[hrefIndex];
        const hrefLink = hrefAttr[1];
        const { base = "/", filePathRelative = null } = env;
        if ((0, shared_1.isLinkExternal)(hrefLink, base)) {
          Object.entries(externalAttrs).forEach(([key, val]) => token.attrSet(key, val));
          return;
        }
        const internalLinkMatch = hrefLink.match(/^((?:.*)(?:\/|\.md|\.html))(#.*)?$/);
        if (!internalLinkMatch) {
          return;
        }
        const rawPath = internalLinkMatch[1];
        const rawHash = internalLinkMatch[2] || "";
        const { relativePath, absolutePath } = (0, resolvePaths_1.resolvePaths)(rawPath, base, filePathRelative);
        const normalizedPath = absolutePath.replace(new RegExp(`^${base}`), "/").replace(/(^|\/)(README|index).md$/i, "$1").replace(/\.md$/, ".html");
        if (internalTag === "RouterLink") {
          token.tag = internalTag;
          hrefAttr[0] = "to";
          hasOpenInternalLink = true;
        }
        hrefAttr[1] = `${normalizedPath}${rawHash}`;
        const links = env.links || (env.links = []);
        links.push({
          raw: hrefLink,
          relative: relativePath,
          absolute: absolutePath
        });
      };
      md.renderer.rules.link_open = (tokens, idx, options3, env, self2) => {
        handleLinkOpen(tokens, idx, env);
        return self2.renderToken(tokens, idx, options3);
      };
      md.renderer.rules.link_close = (tokens, idx, options3, env, self2) => {
        if (hasOpenInternalLink) {
          hasOpenInternalLink = false;
          tokens[idx].tag = internalTag;
        }
        return self2.renderToken(tokens, idx, options3);
      };
    };
    exports2.linksPlugin = linksPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/linksPlugin/index.js
var require_linksPlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/linksPlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_linksPlugin(), exports2);
    __exportStar(require_resolvePaths(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/tocPlugin/createRenderHeaders.js
var require_createRenderHeaders = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/tocPlugin/createRenderHeaders.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRenderHeaders = void 0;
    var shared_1 = require_dist();
    var createRenderHeaders = ({ listTag, listClass, itemClass, linkTag, linkClass }) => {
      const listTagString = (0, shared_1.htmlEscape)(listTag);
      const listClassString = listClass ? ` class="${(0, shared_1.htmlEscape)(listClass)}"` : "";
      const itemTagString = "li";
      const itemClassString = itemClass ? ` class="${(0, shared_1.htmlEscape)(itemClass)}"` : "";
      const linkTagString = (0, shared_1.htmlEscape)(linkTag);
      const linkClassString = linkClass ? ` class="${(0, shared_1.htmlEscape)(linkClass)}` : "";
      const linkTo = (slug) => linkTag === "RouterLink" ? ` to="#${slug}"` : ` href="#${slug}"`;
      const renderHeaders = (headers) => `<${listTagString}${listClassString}>${headers.map((header) => `<${itemTagString}${itemClassString}${itemClassString}><${linkTagString}${linkClassString}${linkTo(header.slug)}>${header.title}</${linkTagString}>${header.children.length > 0 ? renderHeaders(header.children) : ""}</${itemTagString}>`).join("")}</${listTagString}>`;
      return renderHeaders;
    };
    exports2.createRenderHeaders = createRenderHeaders;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/tocPlugin/createTocBlockRule.js
var require_createTocBlockRule = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/tocPlugin/createTocBlockRule.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTocBlockRule = void 0;
    var createTocBlockRule = ({ pattern, containerTag, containerClass }) => {
      return (state, startLine, endLine, silent) => {
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          return false;
        }
        const pos = state.bMarks[startLine] + state.tShift[startLine];
        const max = state.eMarks[startLine];
        const lineFirstToken = state.src.slice(pos, max).split(" ")[0];
        if (!pattern.test(lineFirstToken))
          return false;
        if (silent)
          return true;
        state.line = startLine + 1;
        const tokenOpen = state.push("toc_open", containerTag, 1);
        tokenOpen.markup = "";
        tokenOpen.map = [startLine, state.line];
        if (containerClass) {
          tokenOpen.attrSet("class", containerClass);
        }
        const tokenBody = state.push("toc_body", "", 0);
        tokenBody.markup = lineFirstToken;
        tokenBody.map = [startLine, state.line];
        tokenBody.hidden = true;
        const tokenClose = state.push("toc_close", containerTag, -1);
        tokenClose.markup = "";
        tokenBody.map = [startLine, state.line];
        return true;
      };
    };
    exports2.createTocBlockRule = createTocBlockRule;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/tocPlugin/tocPlugin.js
var require_tocPlugin = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/tocPlugin/tocPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tocPlugin = void 0;
    var utils_1 = require_utils2();
    var createRenderHeaders_1 = require_createRenderHeaders();
    var createTocBlockRule_1 = require_createTocBlockRule();
    var tocPlugin = (md, { pattern = /^\[\[toc\]\]$/i, slugify = utils_1.slugify, format, level = [2, 3], containerTag = "nav", containerClass = "table-of-contents", listTag = "ul", listClass = "", itemClass = "", linkTag = "a", linkClass = "" } = {}) => {
      let headers;
      md.core.ruler.push("resolveTocHeaders", (state) => {
        headers = (0, utils_1.resolveHeadersFromTokens)(state.tokens, {
          level,
          allowHtml: true,
          escapeText: true,
          slugify,
          format
        });
        return true;
      });
      md.block.ruler.before("heading", "toc", (0, createTocBlockRule_1.createTocBlockRule)({
        pattern,
        containerTag,
        containerClass
      }), {
        alt: ["paragraph", "reference", "blockquote"]
      });
      const renderHeaders = (0, createRenderHeaders_1.createRenderHeaders)({
        listTag,
        listClass,
        itemClass,
        linkTag,
        linkClass
      });
      md.renderer.rules.toc_body = () => {
        if (!headers) {
          return "";
        }
        return renderHeaders(headers);
      };
    };
    exports2.tocPlugin = tocPlugin;
  }
});

// node_modules/@vuepress/markdown/lib/plugins/tocPlugin/index.js
var require_tocPlugin2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/tocPlugin/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createRenderHeaders(), exports2);
    __exportStar(require_createTocBlockRule(), exports2);
    __exportStar(require_tocPlugin(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/@vuepress/markdown/lib/plugins/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_anchorPlugin(), exports2);
    __exportStar(require_assetsPlugin2(), exports2);
    __exportStar(require_codePlugin2(), exports2);
    __exportStar(require_customComponentPlugin2(), exports2);
    __exportStar(require_emojiPlugin(), exports2);
    __exportStar(require_extractHeadersPlugin(), exports2);
    __exportStar(require_extractTitlePlugin(), exports2);
    __exportStar(require_hoistTagsPlugin(), exports2);
    __exportStar(require_importCodePlugin2(), exports2);
    __exportStar(require_linksPlugin2(), exports2);
    __exportStar(require_tocPlugin2(), exports2);
  }
});

// node_modules/@vuepress/markdown/lib/markdown.js
var require_markdown = __commonJS({
  "node_modules/@vuepress/markdown/lib/markdown.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMarkdown = void 0;
    var MarkdownIt = require_markdown_it();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils2();
    var createMarkdown = (_a = {}) => {
      var _b = _a, { anchor, assets, code, customComponent, emoji, extractHeaders, extractTitle, hoistTags, importCode, links, toc } = _b, markdownItOptions = __objRest(_b, ["anchor", "assets", "code", "customComponent", "emoji", "extractHeaders", "extractTitle", "hoistTags", "importCode", "links", "toc"]);
      const md = MarkdownIt(__spreadProps(__spreadValues({}, markdownItOptions), {
        html: true
      }));
      if (emoji !== false) {
        md.use(plugins_1.emojiPlugin, emoji);
      }
      if (anchor !== false) {
        md.use(plugins_1.anchorPlugin, __spreadValues({
          level: [1, 2, 3, 4, 5, 6],
          slugify: utils_1.slugify,
          permalink: plugins_1.anchorPlugin.permalink.ariaHidden({
            class: "header-anchor",
            symbol: "#",
            space: true,
            placement: "before"
          })
        }, anchor));
      }
      if (toc !== false) {
        md.use(plugins_1.tocPlugin, __spreadValues({
          level: [2, 3],
          slugify: utils_1.slugify,
          linkTag: "RouterLink"
        }, toc));
      }
      if (extractHeaders !== false) {
        md.use(plugins_1.extractHeadersPlugin, __spreadValues({
          level: [2, 3],
          slugify: utils_1.slugify
        }, extractHeaders));
      }
      if (extractTitle !== false) {
        md.use(plugins_1.extractTitlePlugin);
      }
      if (customComponent !== false) {
        md.use(plugins_1.customComponentPlugin);
      }
      if (assets !== false) {
        md.use(plugins_1.assetsPlugin, assets);
      }
      if (hoistTags !== false) {
        md.use(plugins_1.hoistTagsPlugin, hoistTags);
      }
      if (links !== false) {
        md.use(plugins_1.linksPlugin, links);
      }
      if (code !== false) {
        md.use(plugins_1.codePlugin, code);
      }
      if (importCode !== false) {
        md.use(plugins_1.importCodePlugin, importCode);
      }
      return md;
    };
    exports2.createMarkdown = createMarkdown;
  }
});

// node_modules/@vuepress/markdown/lib/types.js
var require_types2 = __commonJS({
  "node_modules/@vuepress/markdown/lib/types.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/markdown/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@vuepress/markdown/lib/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_markdown(), exports2);
    __exportStar(require_plugins(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_utils2(), exports2);
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppMarkdown.js
var require_resolveAppMarkdown = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppMarkdown.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppMarkdown = void 0;
    var markdown_1 = require_lib3();
    var resolveAppMarkdown = async (app) => {
      await app.pluginApi.hooks.extendsMarkdownOptions.process(app.options.markdown, app);
      const markdown = (0, markdown_1.createMarkdown)(app.options.markdown);
      await app.pluginApi.hooks.extendsMarkdown.process(markdown, app);
      return markdown;
    };
    exports2.resolveAppMarkdown = resolveAppMarkdown;
  }
});

// node_modules/@vuepress/core/lib/page/inferPagePath.js
var require_inferPagePath = __commonJS({
  "node_modules/@vuepress/core/lib/page/inferPagePath.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inferPagePath = void 0;
    var shared_1 = require_dist();
    var inferPagePath = ({ app, filePathRelative }) => {
      if (!filePathRelative) {
        return {
          pathInferred: null,
          pathLocale: "/"
        };
      }
      const pathInferred = (0, shared_1.ensureLeadingSlash)(filePathRelative).replace(/\.md$/, ".html").replace(/\/(README|index).html$/i, "/");
      const pathLocale = (0, shared_1.resolveLocalePath)(app.siteData.locales, pathInferred);
      return {
        pathInferred,
        pathLocale
      };
    };
    exports2.inferPagePath = inferPagePath;
  }
});

// node_modules/@vuepress/core/lib/page/renderPageContent.js
var require_renderPageContent = __commonJS({
  "node_modules/@vuepress/core/lib/page/renderPageContent.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renderPageContent = void 0;
    var renderPageContent = async ({ app, content, frontmatter, filePath, filePathRelative }) => {
      const markdownEnv = {
        base: app.options.base,
        filePath,
        filePathRelative,
        frontmatter
      };
      const contentRendered = app.markdown.render(content, markdownEnv);
      const { headers = [], hoistedTags = [], importedFiles = [], links = [], title = "" } = markdownEnv;
      return {
        contentRendered,
        deps: importedFiles,
        headers,
        hoistedTags,
        links,
        title
      };
    };
    exports2.renderPageContent = renderPageContent;
  }
});

// node_modules/@vuepress/core/lib/page/renderPageExcerpt.js
var require_renderPageExcerpt = __commonJS({
  "node_modules/@vuepress/core/lib/page/renderPageExcerpt.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renderPageExcerpt = void 0;
    var renderPageExcerpt = ({ app, excerptRaw, frontmatter, filePath, filePathRelative }) => {
      const markdownEnv = {
        base: app.options.base,
        filePath,
        filePathRelative,
        frontmatter
      };
      const renderedExcerpt = app.markdown.render(excerptRaw, markdownEnv);
      return renderedExcerpt;
    };
    exports2.renderPageExcerpt = renderPageExcerpt;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageComponentInfo.js
var require_resolvePageComponentInfo = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageComponentInfo.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageComponentInfo = void 0;
    var utils_1 = require_lib();
    var resolvePageComponentInfo = async ({ app, htmlFilePathRelative, key }) => {
      const componentFilePathRelative = utils_1.path.join("pages", `${htmlFilePathRelative}.vue`);
      const componentFilePath = app.dir.temp(componentFilePathRelative);
      const componentFileChunkName = key;
      return {
        componentFilePath,
        componentFilePathRelative,
        componentFileChunkName
      };
    };
    exports2.resolvePageComponentInfo = resolvePageComponentInfo;
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/section-matter/node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/section-matter/node_modules/is-extendable/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/section-matter/node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/section-matter/node_modules/extend-shallow/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isObject = require_is_extendable();
    module2.exports = function extend(o2) {
      if (!isObject(o2)) {
        o2 = {};
      }
      var len = arguments.length;
      for (var i2 = 1; i2 < len; i2++) {
        var obj = arguments[i2];
        if (isObject(obj)) {
          assign(o2, obj);
        }
      }
      return o2;
    };
    function assign(a2, b2) {
      for (var key in b2) {
        if (hasOwn(b2, key)) {
          a2[key] = b2[key];
        }
      }
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/section-matter/index.js
var require_section_matter = __commonJS({
  "node_modules/section-matter/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var typeOf = require_kind_of();
    var extend = require_extend_shallow();
    module2.exports = function(input, options2) {
      if (typeof options2 === "function") {
        options2 = { parse: options2 };
      }
      var file = toObject(input);
      var defaults = { section_delimiter: "---", parse: identity };
      var opts = extend({}, defaults, options2);
      var delim = opts.section_delimiter;
      var lines = file.content.split(/\r?\n/);
      var sections = null;
      var section = createSection();
      var content = [];
      var stack = [];
      function initSections(val) {
        file.content = val;
        sections = [];
        content = [];
      }
      function closeSection(val) {
        if (stack.length) {
          section.key = getKey(stack[0], delim);
          section.content = val;
          opts.parse(section, sections);
          sections.push(section);
          section = createSection();
          content = [];
          stack = [];
        }
      }
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = lines[i2];
        var len = stack.length;
        var ln = line.trim();
        if (isDelimiter(ln, delim)) {
          if (ln.length === 3 && i2 !== 0) {
            if (len === 0 || len === 2) {
              content.push(line);
              continue;
            }
            stack.push(ln);
            section.data = content.join("\n");
            content = [];
            continue;
          }
          if (sections === null) {
            initSections(content.join("\n"));
          }
          if (len === 2) {
            closeSection(content.join("\n"));
          }
          stack.push(ln);
          continue;
        }
        content.push(line);
      }
      if (sections === null) {
        initSections(content.join("\n"));
      } else {
        closeSection(content.join("\n"));
      }
      file.sections = sections;
      return file;
    };
    function isDelimiter(line, delim) {
      if (line.slice(0, delim.length) !== delim) {
        return false;
      }
      if (line.charAt(delim.length + 1) === delim.slice(-1)) {
        return false;
      }
      return true;
    }
    function toObject(input) {
      if (typeOf(input) !== "object") {
        input = { content: input };
      }
      if (typeof input.content !== "string" && !isBuffer(input.content)) {
        throw new TypeError("expected a buffer or string");
      }
      input.content = input.content.toString();
      input.sections = [];
      return input;
    }
    function getKey(val, delim) {
      return val ? val.slice(delim.length).trim() : "";
    }
    function createSection() {
      return { key: "", data: "", content: "" };
    }
    function identity(val) {
      return val;
    }
    function isBuffer(val) {
      if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options2) {
      options2 = options2 || {};
      Object.keys(options2).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options2["kind"] || null;
      this.resolve = options2["resolve"] || function() {
        return true;
      };
      this.construct = options2["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options2["instanceOf"] || null;
      this.predicate = options2["predicate"] || null;
      this.represent = options2["represent"] || null;
      this.defaultStyle = options2["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types
      });
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    var Type = require_type();
    function isHexCode(c2) {
      return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
    }
    function isOctCode(c2) {
      return 48 <= c2 && c2 <= 55;
    }
    function isDecCode(c2) {
      return 48 <= c2 && c2 <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d2) {
          value += d2 * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d2) {
          value += d2 * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var NodeBuffer;
    try {
      _require = __require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var esprima;
    try {
      _require = __require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c2) {
      return c2 === 10 || c2 === 13;
    }
    function is_WHITE_SPACE(c2) {
      return c2 === 9 || c2 === 32;
    }
    function is_WS_OR_EOL(c2) {
      return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
    }
    function is_FLOW_INDICATOR(c2) {
      return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
    }
    function fromHexCode(c2) {
      var lc;
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      lc = c2 | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c2) {
      if (c2 === 120) {
        return 2;
      }
      if (c2 === 117) {
        return 4;
      }
      if (c2 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c2) {
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c2) {
      return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c2) {
      if (c2 <= 65535) {
        return String.fromCharCode(c2);
      }
      return String.fromCharCode((c2 - 65536 >> 10) + 55296, (c2 - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
      simpleEscapeMap[i2] = simpleEscapeSequence(i2);
    }
    var i2;
    function State(input, options2) {
      this.input = input;
      this.filename = options2["filename"] || null;
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options2["onWarning"] || null;
      this.legacy = options2["legacy"] || false;
      this.json = options2["json"] || false;
      this.listener = options2["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options2) {
      input = String(input);
      options2 = options2 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options2);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options2) {
      if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options2);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options2) {
      var documents = loadDocuments(input, options2);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options2) {
      if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    function safeLoad(input, options2) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options2) {
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options2["indent"] || 2);
      this.noArrayIndent = options2["noArrayIndent"] || false;
      this.skipInvalid = options2["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
      this.sortKeys = options2["sortKeys"] || false;
      this.lineWidth = options2["lineWidth"] || 80;
      this.noRefs = options2["noRefs"] || false;
      this.noCompatMode = options2["noCompatMode"] || false;
      this.condenseFlow = options2["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str2) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c2) {
      return c2 === CHAR_SPACE || c2 === CHAR_TAB;
    }
    function isPrintable(c2) {
      return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
    }
    function isNsChar(c2) {
      return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c2, prev) {
      return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c2) {
      return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i2;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i2 = 0; i2 < string.length; i2++) {
        char = string.charCodeAt(i2);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i2 + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i2++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i2] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (index !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options2) {
      options2 = options2 || {};
      var state = new State(options2);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options2) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var yaml2 = require_js_yaml();
    module2.exports = yaml2;
  }
});

// node_modules/gray-matter/lib/engines.js
var require_engines = __commonJS({
  "node_modules/gray-matter/lib/engines.js"(exports, module) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var yaml = require_js_yaml2();
    var engines = exports = module.exports;
    engines.yaml = {
      parse: yaml.safeLoad.bind(yaml),
      stringify: yaml.safeDump.bind(yaml)
    };
    engines.json = {
      parse: JSON.parse.bind(JSON),
      stringify: function(obj, options2) {
        const opts = Object.assign({ replacer: null, space: 2 }, options2);
        return JSON.stringify(obj, opts.replacer, opts.space);
      }
    };
    engines.javascript = {
      parse: function parse(str, options, wrap) {
        try {
          if (wrap !== false) {
            str = "(function() {\nreturn " + str.trim() + ";\n}());";
          }
          return eval(str) || {};
        } catch (err) {
          if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
            return parse(str, options, false);
          }
          throw new SyntaxError(err);
        }
      },
      stringify: function() {
        throw new Error("stringifying JavaScript is not supported");
      }
    };
  }
});

// node_modules/strip-bom-string/index.js
var require_strip_bom_string = __commonJS({
  "node_modules/strip-bom-string/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(str2) {
      if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
        return str2.slice(1);
      }
      return str2;
    };
  }
});

// node_modules/gray-matter/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/gray-matter/lib/utils.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var stripBom = require_strip_bom_string();
    var typeOf = require_kind_of();
    exports2.define = function(obj, key, val) {
      Reflect.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: val
      });
    };
    exports2.isBuffer = function(val) {
      return typeOf(val) === "buffer";
    };
    exports2.isObject = function(val) {
      return typeOf(val) === "object";
    };
    exports2.toBuffer = function(input) {
      return typeof input === "string" ? Buffer.from(input) : input;
    };
    exports2.toString = function(input) {
      if (exports2.isBuffer(input))
        return stripBom(String(input));
      if (typeof input !== "string") {
        throw new TypeError("expected input to be a string or buffer");
      }
      return stripBom(input);
    };
    exports2.arrayify = function(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    exports2.startsWith = function(str2, substr, len) {
      if (typeof len !== "number")
        len = substr.length;
      return str2.slice(0, len) === substr;
    };
  }
});

// node_modules/gray-matter/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/gray-matter/lib/defaults.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var engines2 = require_engines();
    var utils = require_utils3();
    module2.exports = function(options2) {
      const opts = Object.assign({}, options2);
      opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
      if (opts.delimiters.length === 1) {
        opts.delimiters.push(opts.delimiters[0]);
      }
      opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
      opts.engines = Object.assign({}, engines2, opts.parsers, opts.engines);
      return opts;
    };
  }
});

// node_modules/gray-matter/lib/engine.js
var require_engine = __commonJS({
  "node_modules/gray-matter/lib/engine.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(name, options2) {
      let engine = options2.engines[name] || options2.engines[aliase(name)];
      if (typeof engine === "undefined") {
        throw new Error('gray-matter engine "' + name + '" is not registered');
      }
      if (typeof engine === "function") {
        engine = { parse: engine };
      }
      return engine;
    };
    function aliase(name) {
      switch (name.toLowerCase()) {
        case "js":
        case "javascript":
          return "javascript";
        case "coffee":
        case "coffeescript":
        case "cson":
          return "coffee";
        case "yaml":
        case "yml":
          return "yaml";
        default: {
          return name;
        }
      }
    }
  }
});

// node_modules/gray-matter/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/gray-matter/lib/stringify.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var typeOf = require_kind_of();
    var getEngine = require_engine();
    var defaults = require_defaults();
    module2.exports = function(file, data, options2) {
      if (data == null && options2 == null) {
        switch (typeOf(file)) {
          case "object":
            data = file.data;
            options2 = {};
            break;
          case "string":
            return file;
          default: {
            throw new TypeError("expected file to be a string or object");
          }
        }
      }
      const str2 = file.content;
      const opts = defaults(options2);
      if (data == null) {
        if (!opts.data)
          return file;
        data = opts.data;
      }
      const language = file.language || opts.language;
      const engine = getEngine(language, opts);
      if (typeof engine.stringify !== "function") {
        throw new TypeError('expected "' + language + '.stringify" to be a function');
      }
      data = Object.assign({}, file.data, data);
      const open = opts.delimiters[0];
      const close = opts.delimiters[1];
      const matter = engine.stringify(data, options2).trim();
      let buf = "";
      if (matter !== "{}") {
        buf = newline(open) + newline(matter) + newline(close);
      }
      if (typeof file.excerpt === "string" && file.excerpt !== "") {
        if (str2.indexOf(file.excerpt.trim()) === -1) {
          buf += newline(file.excerpt) + newline(close);
        }
      }
      return buf + newline(str2);
    };
    function newline(str2) {
      return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
    }
  }
});

// node_modules/gray-matter/lib/excerpt.js
var require_excerpt = __commonJS({
  "node_modules/gray-matter/lib/excerpt.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var defaults = require_defaults();
    module2.exports = function(file, options2) {
      const opts = defaults(options2);
      if (file.data == null) {
        file.data = {};
      }
      if (typeof opts.excerpt === "function") {
        return opts.excerpt(file, opts);
      }
      const sep = file.data.excerpt_separator || opts.excerpt_separator;
      if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
        return file;
      }
      const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
      const idx = file.content.indexOf(delimiter);
      if (idx !== -1) {
        file.excerpt = file.content.slice(0, idx);
      }
      return file;
    };
  }
});

// node_modules/gray-matter/lib/to-file.js
var require_to_file = __commonJS({
  "node_modules/gray-matter/lib/to-file.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var typeOf = require_kind_of();
    var stringify = require_stringify();
    var utils = require_utils3();
    module2.exports = function(file) {
      if (typeOf(file) !== "object") {
        file = { content: file };
      }
      if (typeOf(file.data) !== "object") {
        file.data = {};
      }
      if (file.contents && file.content == null) {
        file.content = file.contents;
      }
      utils.define(file, "orig", utils.toBuffer(file.content));
      utils.define(file, "language", file.language || "");
      utils.define(file, "matter", file.matter || "");
      utils.define(file, "stringify", function(data, options2) {
        if (options2 && options2.language) {
          file.language = options2.language;
        }
        return stringify(file, data, options2);
      });
      file.content = utils.toString(file.content);
      file.isEmpty = false;
      file.excerpt = "";
      return file;
    };
  }
});

// node_modules/gray-matter/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/gray-matter/lib/parse.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var getEngine = require_engine();
    var defaults = require_defaults();
    module2.exports = function(language, str2, options2) {
      const opts = defaults(options2);
      const engine = getEngine(language, opts);
      if (typeof engine.parse !== "function") {
        throw new TypeError('expected "' + language + '.parse" to be a function');
      }
      return engine.parse(str2, opts);
    };
  }
});

// node_modules/gray-matter/index.js
var require_gray_matter = __commonJS({
  "node_modules/gray-matter/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var sections = require_section_matter();
    var defaults = require_defaults();
    var stringify = require_stringify();
    var excerpt = require_excerpt();
    var engines2 = require_engines();
    var toFile = require_to_file();
    var parse2 = require_parse2();
    var utils = require_utils3();
    function matter(input, options2) {
      if (input === "") {
        return { data: {}, content: input, excerpt: "", orig: input };
      }
      let file = toFile(input);
      const cached = matter.cache[file.content];
      if (!options2) {
        if (cached) {
          file = Object.assign({}, cached);
          file.orig = cached.orig;
          return file;
        }
        matter.cache[file.content] = file;
      }
      return parseMatter(file, options2);
    }
    function parseMatter(file, options2) {
      const opts = defaults(options2);
      const open = opts.delimiters[0];
      const close = "\n" + opts.delimiters[1];
      let str2 = file.content;
      if (opts.language) {
        file.language = opts.language;
      }
      const openLen = open.length;
      if (!utils.startsWith(str2, open, openLen)) {
        excerpt(file, opts);
        return file;
      }
      if (str2.charAt(openLen) === open.slice(-1)) {
        return file;
      }
      str2 = str2.slice(openLen);
      const len = str2.length;
      const language = matter.language(str2, opts);
      if (language.name) {
        file.language = language.name;
        str2 = str2.slice(language.raw.length);
      }
      let closeIndex = str2.indexOf(close);
      if (closeIndex === -1) {
        closeIndex = len;
      }
      file.matter = str2.slice(0, closeIndex);
      const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
      if (block === "") {
        file.isEmpty = true;
        file.empty = file.content;
        file.data = {};
      } else {
        file.data = parse2(file.language, file.matter, opts);
      }
      if (closeIndex === len) {
        file.content = "";
      } else {
        file.content = str2.slice(closeIndex + close.length);
        if (file.content[0] === "\r") {
          file.content = file.content.slice(1);
        }
        if (file.content[0] === "\n") {
          file.content = file.content.slice(1);
        }
      }
      excerpt(file, opts);
      if (opts.sections === true || typeof opts.section === "function") {
        sections(file, opts.section);
      }
      return file;
    }
    matter.engines = engines2;
    matter.stringify = function(file, data, options2) {
      if (typeof file === "string")
        file = matter(file, options2);
      return stringify(file, data, options2);
    };
    matter.read = function(filepath, options2) {
      const str2 = fs.readFileSync(filepath, "utf8");
      const file = matter(str2, options2);
      file.path = filepath;
      return file;
    };
    matter.test = function(str2, options2) {
      return utils.startsWith(str2, defaults(options2).delimiters[0]);
    };
    matter.language = function(str2, options2) {
      const opts = defaults(options2);
      const open = opts.delimiters[0];
      if (matter.test(str2)) {
        str2 = str2.slice(open.length);
      }
      const language = str2.slice(0, str2.search(/\r?\n/));
      return {
        raw: language,
        name: language ? language.trim() : ""
      };
    };
    matter.cache = {};
    matter.clearCache = function() {
      matter.cache = {};
    };
    module2.exports = matter;
  }
});

// node_modules/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/toml/lib/parser.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function() {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function SyntaxError2(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError2, Error);
      function parse2(input) {
        var options2 = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
          return nodes;
        }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
          addNode(node("ObjectPath", name, line, column));
        }, peg$c12 = function(name) {
          addNode(node("ArrayPath", name, line, column));
        }, peg$c13 = function(parts, name) {
          return parts.concat(name);
        }, peg$c14 = function(name) {
          return [name];
        }, peg$c15 = function(name) {
          return name;
        }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
          addNode(node("Assign", value, line, column, key));
        }, peg$c21 = function(chars) {
          return chars.join("");
        }, peg$c22 = function(node2) {
          return node2.value;
        }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
          return node("String", chars.join(""), line, column);
        }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
          return char;
        }, peg$c34 = function(char) {
          return char;
        }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
          return "";
        }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
          return node("Float", parseFloat(left + "e" + right), line, column);
        }, peg$c43 = function(text2) {
          return node("Float", parseFloat(text2), line, column);
        }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
          return digits.join("");
        }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
          return "-" + digits.join("");
        }, peg$c50 = function(text2) {
          return node("Integer", parseInt(text2, 10), line, column);
        }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
          return node("Boolean", true, line, column);
        }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
          return node("Boolean", false, line, column);
        }, peg$c57 = function() {
          return node("Array", [], line, column);
        }, peg$c58 = function(value) {
          return node("Array", value ? [value] : [], line, column);
        }, peg$c59 = function(values) {
          return node("Array", values, line, column);
        }, peg$c60 = function(values, value) {
          return node("Array", values.concat(value), line, column);
        }, peg$c61 = function(value) {
          return value;
        }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
          return node("InlineTable", values, line, column);
        }, peg$c69 = function(key, value) {
          return node("InlineTableValue", value, line, column, key);
        }, peg$c70 = function(digits) {
          return "." + digits;
        }, peg$c71 = function(date) {
          return date.join("");
        }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
          return time.join("");
        }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time) {
          return node("Date", new Date(date + "T" + time + "Z"), line, column);
        }, peg$c80 = function(date, time) {
          return node("Date", new Date(date + "T" + time), line, column);
        }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
          return "";
        }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d2) {
          return d2.join("");
        }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
          return '"';
        }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
          return "\\";
        }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
          return "\b";
        }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
          return "	";
        }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
          return "\n";
        }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
          return "\f";
        }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
          return "\r";
        }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
          return convertCodePoint(digits.join(""));
        }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }
        function offset() {
          return peg$reportedPos;
        }
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function expected(description) {
          throw peg$buildException(null, [{ type: "other", description }], peg$reportedPos);
        }
        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p, ch;
            for (p = startPos; p < endPos; p++) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, pos) {
          function cleanupExpected(expected3) {
            var i2 = 1;
            expected3.sort(function(a2, b2) {
              if (a2.description < b2.description) {
                return -1;
              } else if (a2.description > b2.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i2 < expected3.length) {
              if (expected3[i2 - 1] === expected3[i2]) {
                expected3.splice(i2, 1);
              } else {
                i2++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s2) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i2;
            for (i2 = 0; i2 < expected3.length; i2++) {
              expectedDescs[i2] = expected3[i2].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new SyntaxError2(message !== null ? message : buildMessage(expected2, found), expected2, found, pos, posDetails.line, posDetails.column);
        }
        function peg$parsestart() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 0, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseline();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1();
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseline() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 1, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpression();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsecomment();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsecomment();
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseNL();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseNL();
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseEOF();
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = [s1, s2, s3, s4, s5];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseNL();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseNL();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseEOF();
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseexpression() {
          var s0;
          var key = peg$currPos * 49 + 2, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsecomment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepath();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetablearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parseassignment();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 3, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 4, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetable_key();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c9;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetablearray() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 49 + 5, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsetable_key();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s6 = peg$c9;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s7 = peg$c9;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c12(s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 6, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsedot_ended_table_key_part();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsedot_ended_table_key_part();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetable_key_part();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetable_key_part();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c14(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key_part() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 7, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedot_ended_table_key_part() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 8, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseassignment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 9, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsekey();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequoted_key();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsekey() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 10, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseASCII_BASIC();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseASCII_BASIC();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsequoted_key() {
          var s0, s1;
          var key = peg$currPos * 49 + 11, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedouble_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesingle_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsevalue() {
          var s0;
          var key = peg$currPos * 49 + 12, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedatetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefloat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinteger();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsearray();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseinline_table();
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring() {
          var s0;
          var key = peg$currPos * 49 + 13, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsedouble_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_quoted_single_line_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_multiline_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_single_line_string();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 14, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_string_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_string_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s4 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 15, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestring_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestring_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c27;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 16, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_literal_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_literal_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c29) {
                  s4 = peg$c29;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 17, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c31;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseliteral_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseliteral_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c31;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 18, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c27;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseliteral_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 19, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 20, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemultiline_string_delim();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s2 = peg$c23;
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c34(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_delim() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 21, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseNLS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseNLS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_literal_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 22, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s2 = peg$c29;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 23, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger_text();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 101) {
              s2 = peg$c38;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c39);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 69) {
                s2 = peg$c40;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c41);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseinteger_text();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c42(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat_text() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 24, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger() {
          var s0, s1;
          var key = peg$currPos * 49 + 25, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseinteger_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger_text() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 26, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseboolean() {
          var s0, s1;
          var key = peg$currPos * 49 + 27, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c53();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c54) {
              s1 = peg$c54;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c56();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 28, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsearray_sep();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsearray_sep();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c57();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsearray_value();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c59(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsearray_value();
                    if (s3 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s4 = peg$c9;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s2, s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 29, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value_list() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 30, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c62;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsearray_sep();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsearray_sep();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c61(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_sep() {
          var s0;
          var key = peg$currPos * 49 + 31, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 32, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c64;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseinline_table_assignment();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseinline_table_assignment();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s5 = peg$c66;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c67);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table_assignment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 33, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s8 = peg$c62;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c69(s2, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesecfragment() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 34, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDIGITS();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c70(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedate() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
          var key = peg$currPos * 49 + 35, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseDIGIT_OR_UNDER();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s6 = peg$c47;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDIGIT_OR_UNDER();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s9 = peg$c47;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseDIGIT_OR_UNDER();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseDIGIT_OR_UNDER();
                            if (s11 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c71(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 36, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime_with_offset() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
          var key = peg$currPos * 49 + 37, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                              s11 = peg$c47;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                              }
                            }
                            if (s11 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 43) {
                                s11 = peg$c44;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c45);
                                }
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseDIGIT_OR_UNDER();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseDIGIT_OR_UNDER();
                                if (s13 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 58) {
                                    s14 = peg$c72;
                                    peg$currPos++;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c73);
                                    }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseDIGIT_OR_UNDER();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parseDIGIT_OR_UNDER();
                                      if (s16 !== peg$FAILED) {
                                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                        s1 = s2;
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedatetime() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 38, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 90) {
                  s4 = peg$c77;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c78);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c79(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime_with_offset();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseS() {
          var s0;
          var key = peg$currPos * 49 + 39, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c81.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNL() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 40, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c83;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 13) {
              s1 = peg$c85;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c83;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNLS() {
          var s0;
          var key = peg$currPos * 49 + 41, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseS();
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key = peg$currPos * 49 + 42, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = peg$c5;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          var key = peg$currPos * 49 + 43, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c87.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGIT_OR_UNDER() {
          var s0, s1;
          var key = peg$currPos * 49 + 44, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c89.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c91;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c93();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseASCII_BASIC() {
          var s0;
          var key = peg$currPos * 49 + 45, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGITS() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 46, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c96(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED() {
          var s0, s1;
          var key = peg$currPos * 49 + 47, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c99();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c100) {
              s1 = peg$c100;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c102();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c103) {
                s1 = peg$c103;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c105();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                  s1 = peg$c106;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c107);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c108();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c111();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c113);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c114();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c115) {
                        s1 = peg$c115;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c116);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c117();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseESCAPED_UNICODE();
                      }
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED_UNICODE() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 48, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c121) {
              s1 = peg$c121;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        var nodes = [];
        function genError(err, line2, col) {
          var ex = new Error(err);
          ex.line = line2;
          ex.column = col;
          throw ex;
        }
        function addNode(node2) {
          nodes.push(node2);
        }
        function node(type, value, line2, column2, key) {
          var obj = { type, value, line: line2(), column: column2() };
          if (key)
            obj.key = key;
          return obj;
        }
        function convertCodePoint(str2, line2, col) {
          var num = parseInt("0x" + str2);
          if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
            genError("Invalid Unicode escape code: " + str2, line2, col);
          } else {
            return fromCodePoint(num);
          }
        }
        function fromCodePoint() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += String.fromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError: SyntaxError2,
        parse: parse2
      };
    }();
  }
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/toml/lib/compiler.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    function compile(nodes) {
      var assignedPaths = [];
      var valueAssignments = [];
      var currentPath = "";
      var data = /* @__PURE__ */ Object.create(null);
      var context = data;
      var arrayMode = false;
      return reduce(nodes);
      function reduce(nodes2) {
        var node;
        for (var i2 = 0; i2 < nodes2.length; i2++) {
          node = nodes2[i2];
          switch (node.type) {
            case "Assign":
              assign(node);
              break;
            case "ObjectPath":
              setPath(node);
              break;
            case "ArrayPath":
              addTableArray(node);
              break;
          }
        }
        return data;
      }
      function genError(err, line, col) {
        var ex = new Error(err);
        ex.line = line;
        ex.column = col;
        throw ex;
      }
      function assign(node) {
        var key = node.key;
        var value = node.value;
        var line = node.line;
        var column = node.column;
        var fullPath;
        if (currentPath) {
          fullPath = currentPath + "." + key;
        } else {
          fullPath = key;
        }
        if (typeof context[key] !== "undefined") {
          genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
        }
        context[key] = reduceValueNode(value);
        if (!pathAssigned(fullPath)) {
          assignedPaths.push(fullPath);
          valueAssignments.push(fullPath);
        }
      }
      function pathAssigned(path) {
        return assignedPaths.indexOf(path) !== -1;
      }
      function reduceValueNode(node) {
        if (node.type === "Array") {
          return reduceArrayWithTypeChecking(node.value);
        } else if (node.type === "InlineTable") {
          return reduceInlineTableNode(node.value);
        } else {
          return node.value;
        }
      }
      function reduceInlineTableNode(values) {
        var obj = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < values.length; i2++) {
          var val = values[i2];
          if (val.value.type === "InlineTable") {
            obj[val.key] = reduceInlineTableNode(val.value.value);
          } else if (val.type === "InlineTableValue") {
            obj[val.key] = reduceValueNode(val.value);
          }
        }
        return obj;
      }
      function setPath(node) {
        var path = node.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (pathAssigned(quotedPath)) {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, /* @__PURE__ */ Object.create(null), line, column);
        currentPath = path;
      }
      function addTableArray(node) {
        var path = node.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (!pathAssigned(quotedPath)) {
          assignedPaths.push(quotedPath);
        }
        assignedPaths = assignedPaths.filter(function(p) {
          return p.indexOf(quotedPath) !== 0;
        });
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, [], line, column);
        currentPath = quotedPath;
        if (context instanceof Array) {
          var newObj = /* @__PURE__ */ Object.create(null);
          context.push(newObj);
          context = newObj;
        } else {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
      }
      function deepRef(start, keys, value, line, column) {
        var traversed = [];
        var traversedPath = "";
        var path = keys.join(".");
        var ctx = start;
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          traversed.push(key);
          traversedPath = traversed.join(".");
          if (typeof ctx[key] === "undefined") {
            if (i2 === keys.length - 1) {
              ctx[key] = value;
            } else {
              ctx[key] = /* @__PURE__ */ Object.create(null);
            }
          } else if (i2 !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
            genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
          }
          ctx = ctx[key];
          if (ctx instanceof Array && ctx.length && i2 < keys.length - 1) {
            ctx = ctx[ctx.length - 1];
          }
        }
        return ctx;
      }
      function reduceArrayWithTypeChecking(array) {
        var firstType = null;
        for (var i2 = 0; i2 < array.length; i2++) {
          var node = array[i2];
          if (firstType === null) {
            firstType = node.type;
          } else {
            if (node.type !== firstType) {
              genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
            }
          }
        }
        return array.map(reduceValueNode);
      }
      function quoteDottedString(str2) {
        if (str2.indexOf(".") > -1) {
          return '"' + str2 + '"';
        } else {
          return str2;
        }
      }
    }
    module2.exports = {
      compile
    };
  }
});

// node_modules/toml/index.js
var require_toml = __commonJS({
  "node_modules/toml/index.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var parser = require_parser();
    var compiler = require_compiler();
    module2.exports = {
      parse: function(input) {
        var nodes = parser.parse(input.toString());
        return compiler.compile(nodes);
      }
    };
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageContent.js
var require_resolvePageContent = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageContent.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageContent = void 0;
    var matter = require_gray_matter();
    var toml = require_toml();
    var resolvePageContent = ({ contentRaw }) => {
      if (!contentRaw) {
        return {
          content: "",
          frontmatterRaw: {},
          excerptRaw: ""
        };
      }
      const { data, content, excerpt = "" } = matter(contentRaw, {
        excerpt_separator: "<!-- more -->",
        engines: {
          toml: toml.parse.bind(toml)
        }
      });
      return {
        content,
        frontmatterRaw: data,
        excerptRaw: excerpt
      };
    };
    exports2.resolvePageContent = resolvePageContent;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageDataInfo.js
var require_resolvePageDataInfo = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageDataInfo.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageDataInfo = void 0;
    var utils_1 = require_lib();
    var resolvePageDataInfo = ({ app, htmlFilePathRelative, key }) => {
      const dataFilePathRelative = utils_1.path.join("pages", `${htmlFilePathRelative}.js`);
      const dataFilePath = app.dir.temp(dataFilePathRelative);
      const dataFileChunkName = key;
      return {
        dataFilePath,
        dataFilePathRelative,
        dataFileChunkName
      };
    };
    exports2.resolvePageDataInfo = resolvePageDataInfo;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageDate.js
var require_resolvePageDate = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageDate.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageDate = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var FILENAME_DATE_RE = /^(\d{4})-(\d{1,2})(?:-(\d{1,2}))?-(.*)$/;
    var DIRNAME_DATE_RE = /(\d{4})\/(\d{1,2})(?:\/(\d{1,2}))?(\/|$)/;
    var DEFAULT_DATE = "0000-00-00";
    var resolvePageDate = ({ frontmatter, filePathRelative }) => {
      var _a, _b;
      if (frontmatter.date instanceof Date) {
        return (0, shared_1.formatDateString)([
          frontmatter.date.getUTCFullYear(),
          frontmatter.date.getUTCMonth() + 1,
          frontmatter.date.getUTCDate()
        ].join("-"), DEFAULT_DATE);
      }
      if ((0, shared_1.isString)(frontmatter.date)) {
        return (0, shared_1.formatDateString)(frontmatter.date, DEFAULT_DATE);
      }
      if (filePathRelative === null) {
        return DEFAULT_DATE;
      }
      const filename = utils_1.path.parse(filePathRelative).name;
      if (filename) {
        const matches = filename.match(FILENAME_DATE_RE);
        if (matches) {
          return (0, shared_1.formatDateString)(`${matches[1]}-${matches[2]}-${(_a = matches[3]) != null ? _a : "01"}`, DEFAULT_DATE);
        }
      }
      const dirname = utils_1.path.dirname(filePathRelative);
      if (dirname !== ".") {
        const matches = dirname.match(DIRNAME_DATE_RE);
        if (matches) {
          return (0, shared_1.formatDateString)(`${matches[1]}-${matches[2]}-${(_b = matches[3]) != null ? _b : "01"}`, DEFAULT_DATE);
        }
      }
      return DEFAULT_DATE;
    };
    exports2.resolvePageDate = resolvePageDate;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageFileContent.js
var require_resolvePageFileContent = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageFileContent.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageFileContent = void 0;
    var utils_1 = require_lib();
    var log = (0, utils_1.debug)("vuepress:core/page");
    var resolvePageFileContent = async ({ filePath, options: options2 }) => {
      var _a;
      if (filePath) {
        try {
          const content = await utils_1.fs.readFile(filePath, "utf-8");
          return content;
        } catch (e2) {
          log(e2 instanceof Error ? e2.message : e2);
        }
      }
      return (_a = options2.content) != null ? _a : "";
    };
    exports2.resolvePageFileContent = resolvePageFileContent;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageFilePath.js
var require_resolvePageFilePath = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageFilePath.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageFilePath = void 0;
    var utils_1 = require_lib();
    var resolvePageFilePath = ({ app, options: options2 }) => {
      if (!options2.filePath) {
        return {
          filePath: null,
          filePathRelative: null
        };
      }
      if (!utils_1.path.isAbsolute(options2.filePath)) {
        throw utils_1.logger.createError(`filePath is not absolute file path: ${options2.filePath}}`);
      }
      return {
        filePath: options2.filePath,
        filePathRelative: utils_1.path.relative(app.dir.source(), options2.filePath)
      };
    };
    exports2.resolvePageFilePath = resolvePageFilePath;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageFrontmatter.js
var require_resolvePageFrontmatter = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageFrontmatter.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageFrontmatter = void 0;
    var resolvePageFrontmatter = ({ frontmatterRaw, options: options2 }) => __spreadValues(__spreadValues({}, options2.frontmatter), frontmatterRaw);
    exports2.resolvePageFrontmatter = resolvePageFrontmatter;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageHtmlInfo.js
var require_resolvePageHtmlInfo = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageHtmlInfo.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageHtmlInfo = void 0;
    var shared_1 = require_dist();
    var resolvePageHtmlInfo = ({ app, path: pagePath }) => {
      const htmlFilePathRelative = (0, shared_1.removeLeadingSlash)(decodeURI(pagePath.replace(/\/$/, "/index.html")));
      const htmlFilePath = app.dir.dest(htmlFilePathRelative);
      return {
        htmlFilePath,
        htmlFilePathRelative
      };
    };
    exports2.resolvePageHtmlInfo = resolvePageHtmlInfo;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageKey.js
var require_resolvePageKey = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageKey.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageKey = void 0;
    var utils_1 = require_lib();
    var resolvePageKey = ({ path }) => `v-${(0, utils_1.hash)(path)}`;
    exports2.resolvePageKey = resolvePageKey;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageLang.js
var require_resolvePageLang = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageLang.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageLang = void 0;
    var shared_1 = require_dist();
    var resolvePageLang = ({ app, frontmatter, pathLocale }) => {
      var _a, _b;
      if ((0, shared_1.isString)(frontmatter.lang) && frontmatter.lang) {
        return frontmatter.lang;
      }
      return (_b = (_a = app.siteData.locales[pathLocale]) == null ? void 0 : _a.lang) != null ? _b : app.siteData.lang;
    };
    exports2.resolvePageLang = resolvePageLang;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePagePath.js
var require_resolvePagePath = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePagePath.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePagePath = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var resolvePagePath = ({ permalink, pathInferred, options: options2 }) => {
      let pagePath = options2.path || permalink || pathInferred;
      if (!pagePath) {
        throw utils_1.logger.createError(`page path is empty, page options: ${JSON.stringify(options2, null, 2)}`);
      }
      if (!pagePath.endsWith(".html")) {
        pagePath = (0, shared_1.ensureEndingSlash)(pagePath);
      }
      return encodeURI(pagePath);
    };
    exports2.resolvePagePath = resolvePagePath;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePagePermalink.js
var require_resolvePagePermalink = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePagePermalink.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePagePermalink = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var resolvePagePermalink = ({ frontmatter, slug, date, pathInferred, pathLocale }) => {
      var _a;
      if ((0, shared_1.isString)(frontmatter.permalink)) {
        return frontmatter.permalink;
      }
      const pattern = (0, shared_1.isString)(frontmatter.permalinkPattern) ? frontmatter.permalinkPattern : null;
      if (!pattern) {
        return null;
      }
      const [year, month, day] = date.split("-");
      const link = utils_1.path.join(pathLocale, pattern.replace(/:year/, year).replace(/:month/, month).replace(/:day/, day).replace(/:slug/, slug).replace(/:raw/, (_a = pathInferred == null ? void 0 : pathInferred.replace(/^\//, "")) != null ? _a : ""));
      return (0, shared_1.ensureLeadingSlash)(link);
    };
    exports2.resolvePagePermalink = resolvePagePermalink;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageRouteMeta.js
var require_resolvePageRouteMeta = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageRouteMeta.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageRouteMeta = void 0;
    var resolvePageRouteMeta = ({ frontmatter }) => {
      var _a;
      return (_a = frontmatter.routeMeta) != null ? _a : {};
    };
    exports2.resolvePageRouteMeta = resolvePageRouteMeta;
  }
});

// node_modules/@vuepress/core/lib/page/resolvePageSlug.js
var require_resolvePageSlug = __commonJS({
  "node_modules/@vuepress/core/lib/page/resolvePageSlug.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePageSlug = void 0;
    var utils_1 = require_lib();
    var DATE_RE = /(\d{4}-\d{1,2}(-\d{1,2})?)-(.*)/;
    var resolvePageSlug = ({ filePathRelative }) => {
      if (!filePathRelative) {
        return "";
      }
      const filename = utils_1.path.parse(filePathRelative).name;
      const match = filename.match(DATE_RE);
      return match ? match[3] : filename;
    };
    exports2.resolvePageSlug = resolvePageSlug;
  }
});

// node_modules/@vuepress/core/lib/page/createPage.js
var require_createPage = __commonJS({
  "node_modules/@vuepress/core/lib/page/createPage.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPage = void 0;
    var inferPagePath_1 = require_inferPagePath();
    var renderPageContent_1 = require_renderPageContent();
    var renderPageExcerpt_1 = require_renderPageExcerpt();
    var resolvePageComponentInfo_1 = require_resolvePageComponentInfo();
    var resolvePageContent_1 = require_resolvePageContent();
    var resolvePageDataInfo_1 = require_resolvePageDataInfo();
    var resolvePageDate_1 = require_resolvePageDate();
    var resolvePageFileContent_1 = require_resolvePageFileContent();
    var resolvePageFilePath_1 = require_resolvePageFilePath();
    var resolvePageFrontmatter_1 = require_resolvePageFrontmatter();
    var resolvePageHtmlInfo_1 = require_resolvePageHtmlInfo();
    var resolvePageKey_1 = require_resolvePageKey();
    var resolvePageLang_1 = require_resolvePageLang();
    var resolvePagePath_1 = require_resolvePagePath();
    var resolvePagePermalink_1 = require_resolvePagePermalink();
    var resolvePageRouteMeta_1 = require_resolvePageRouteMeta();
    var resolvePageSlug_1 = require_resolvePageSlug();
    var createPage = async (app, options2) => {
      await app.pluginApi.hooks.extendsPageOptions.process(options2, app);
      const { filePath, filePathRelative } = (0, resolvePageFilePath_1.resolvePageFilePath)({
        app,
        options: options2
      });
      const contentRaw = await (0, resolvePageFileContent_1.resolvePageFileContent)({ filePath, options: options2 });
      const { content, frontmatterRaw, excerptRaw } = (0, resolvePageContent_1.resolvePageContent)({
        contentRaw
      });
      const frontmatter = (0, resolvePageFrontmatter_1.resolvePageFrontmatter)({ frontmatterRaw, options: options2 });
      const excerpt = (0, renderPageExcerpt_1.renderPageExcerpt)({
        app,
        excerptRaw,
        filePath,
        filePathRelative,
        frontmatter
      });
      const { contentRendered, deps, headers, hoistedTags, links, title } = await (0, renderPageContent_1.renderPageContent)({
        app,
        content,
        filePath,
        filePathRelative,
        frontmatter
      });
      const routeMeta = (0, resolvePageRouteMeta_1.resolvePageRouteMeta)({ frontmatter });
      const slug = (0, resolvePageSlug_1.resolvePageSlug)({ filePathRelative });
      const date = (0, resolvePageDate_1.resolvePageDate)({ frontmatter, filePathRelative });
      const { pathInferred, pathLocale } = (0, inferPagePath_1.inferPagePath)({ app, filePathRelative });
      const lang = (0, resolvePageLang_1.resolvePageLang)({ app, frontmatter, pathLocale });
      const permalink = (0, resolvePagePermalink_1.resolvePagePermalink)({
        frontmatter,
        slug,
        date,
        pathInferred,
        pathLocale
      });
      const path = (0, resolvePagePath_1.resolvePagePath)({ permalink, pathInferred, options: options2 });
      const key = (0, resolvePageKey_1.resolvePageKey)({ path });
      const { htmlFilePath, htmlFilePathRelative } = (0, resolvePageHtmlInfo_1.resolvePageHtmlInfo)({
        app,
        path
      });
      const { componentFilePath, componentFilePathRelative, componentFileChunkName } = await (0, resolvePageComponentInfo_1.resolvePageComponentInfo)({
        app,
        htmlFilePathRelative,
        key
      });
      const { dataFilePath, dataFilePathRelative, dataFileChunkName } = (0, resolvePageDataInfo_1.resolvePageDataInfo)({ app, htmlFilePathRelative, key });
      const page = {
        data: {
          key,
          path,
          title,
          lang,
          frontmatter,
          excerpt,
          headers
        },
        key,
        path,
        title,
        lang,
        frontmatter,
        excerpt,
        headers,
        content,
        contentRendered,
        date,
        deps,
        hoistedTags,
        links,
        pathInferred,
        pathLocale,
        permalink,
        routeMeta,
        slug,
        filePath,
        filePathRelative,
        componentFilePath,
        componentFilePathRelative,
        componentFileChunkName,
        dataFilePath,
        dataFilePathRelative,
        dataFileChunkName,
        htmlFilePath,
        htmlFilePathRelative
      };
      await app.pluginApi.hooks.extendsPage.process(page, app);
      return page;
    };
    exports2.createPage = createPage;
  }
});

// node_modules/@vuepress/core/lib/page/index.js
var require_page = __commonJS({
  "node_modules/@vuepress/core/lib/page/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createPage(), exports2);
    __exportStar(require_inferPagePath(), exports2);
    __exportStar(require_renderPageContent(), exports2);
    __exportStar(require_renderPageExcerpt(), exports2);
    __exportStar(require_resolvePageComponentInfo(), exports2);
    __exportStar(require_resolvePageContent(), exports2);
    __exportStar(require_resolvePageDataInfo(), exports2);
    __exportStar(require_resolvePageDate(), exports2);
    __exportStar(require_resolvePageFileContent(), exports2);
    __exportStar(require_resolvePageFilePath(), exports2);
    __exportStar(require_resolvePageFrontmatter(), exports2);
    __exportStar(require_resolvePageHtmlInfo(), exports2);
    __exportStar(require_resolvePageKey(), exports2);
    __exportStar(require_resolvePageLang(), exports2);
    __exportStar(require_resolvePagePath(), exports2);
    __exportStar(require_resolvePagePermalink(), exports2);
    __exportStar(require_resolvePageRouteMeta(), exports2);
    __exportStar(require_resolvePageSlug(), exports2);
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppPages.js
var require_resolveAppPages = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppPages.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppPages = void 0;
    var utils_1 = require_lib();
    var page_1 = require_page();
    var log = (0, utils_1.debug)("vuepress:core/app");
    var resolveAppPages = async (app) => {
      log("resolveAppPages start");
      const pageFilePaths = await (0, utils_1.globby)(app.options.pagePatterns, {
        absolute: true,
        cwd: app.dir.source()
      });
      const pages = await Promise.all(pageFilePaths.map((filePath) => (0, page_1.createPage)(app, { filePath })));
      if (!pages.some((page) => page.path === "/404.html")) {
        pages.push(await (0, page_1.createPage)(app, {
          path: "/404.html",
          frontmatter: {
            layout: "404"
          }
        }));
      }
      log("resolveAppPages finish");
      return pages;
    };
    exports2.resolveAppPages = resolveAppPages;
  }
});

// node_modules/@vuepress/core/lib/app/appInit.js
var require_appInit = __commonJS({
  "node_modules/@vuepress/core/lib/app/appInit.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.appInit = void 0;
    var utils_1 = require_lib();
    var resolveAppMarkdown_1 = require_resolveAppMarkdown();
    var resolveAppPages_1 = require_resolveAppPages();
    var log = (0, utils_1.debug)("vuepress:core/app");
    var appInit = async (app) => {
      log("init start");
      app.pluginApi.registerHooks();
      app.markdown = await (0, resolveAppMarkdown_1.resolveAppMarkdown)(app);
      app.pages = await (0, resolveAppPages_1.resolveAppPages)(app);
      await app.pluginApi.hooks.onInitialized.process(app);
      log("init finish");
    };
    exports2.appInit = appInit;
  }
});

// node_modules/@vuepress/core/lib/app/appPrepare.js
var require_appPrepare = __commonJS({
  "node_modules/@vuepress/core/lib/app/appPrepare.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.appPrepare = void 0;
    var utils_1 = require_lib();
    var prepare_1 = require_prepare();
    var log = (0, utils_1.debug)("vuepress:core/app");
    var appPrepare = async (app) => {
      log("prepare start");
      for (const page of app.pages) {
        await (0, prepare_1.preparePageComponent)(app, page);
      }
      await (0, prepare_1.preparePagesComponents)(app);
      for (const page of app.pages) {
        await (0, prepare_1.preparePageData)(app, page);
      }
      await (0, prepare_1.preparePagesData)(app);
      await (0, prepare_1.preparePagesRoutes)(app);
      await (0, prepare_1.prepareLayoutComponents)(app);
      await (0, prepare_1.prepareSiteData)(app);
      await (0, prepare_1.prepareClientConfigs)(app);
      await app.pluginApi.hooks.onPrepared.process(app);
      log("prepare finish");
    };
    exports2.appPrepare = appPrepare;
  }
});

// node_modules/@vuepress/core/lib/app/resolvePluginObject.js
var require_resolvePluginObject = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolvePluginObject.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePluginObject = void 0;
    var shared_1 = require_dist();
    var resolvePluginObject = (app, plugin) => (0, shared_1.isFunction)(plugin) ? plugin(app) : plugin;
    exports2.resolvePluginObject = resolvePluginObject;
  }
});

// node_modules/@vuepress/core/lib/app/appUse.js
var require_appUse = __commonJS({
  "node_modules/@vuepress/core/lib/app/appUse.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.appUse = void 0;
    var utils_1 = require_lib();
    var resolvePluginObject_1 = require_resolvePluginObject();
    var log = (0, utils_1.debug)("vuepress:core/app");
    var appUse = (app, rawPlugin) => {
      const pluginObject = (0, resolvePluginObject_1.resolvePluginObject)(app, rawPlugin);
      if (!pluginObject.name) {
        (0, utils_1.warn)(`an anonymous plugin or theme was detected and ignored`);
        return app;
      }
      log(`use plugin ${utils_1.chalk.magenta(pluginObject.name)}`);
      if (pluginObject.multiple !== true) {
        const duplicateIndex = app.pluginApi.plugins.findIndex(({ name }) => name === pluginObject.name);
        if (duplicateIndex !== -1) {
          app.pluginApi.plugins.splice(duplicateIndex, 1);
          (0, utils_1.warn)(`plugin ${utils_1.chalk.magenta(pluginObject.name)} has been used multiple times, only the last one will take effect`);
        }
      }
      app.pluginApi.plugins.push(pluginObject);
      return app;
    };
    exports2.appUse = appUse;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/createHookQueue.js
var require_createHookQueue = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/createHookQueue.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createHookQueue = void 0;
    var utils_1 = require_lib();
    var log = (0, utils_1.debug)("vuepress:core/plugin-api");
    var createHookQueue = (name) => {
      const items = [];
      const hookQueue = {
        name,
        items,
        add: (item) => {
          items.push(item);
        },
        process: async (...args) => {
          const results = [];
          for (const item of items) {
            log(`process ${utils_1.chalk.magenta(name)} from ${utils_1.chalk.magenta(item.pluginName)}`);
            try {
              const result = await item.hook(...args);
              if (result !== void 0) {
                results.push(result);
              }
            } catch (e2) {
              utils_1.logger.error(`error in hook ${utils_1.chalk.magenta(name)} from ${utils_1.chalk.magenta(item.pluginName)}`);
              throw e2;
            }
          }
          return results;
        }
      };
      return hookQueue;
    };
    exports2.createHookQueue = createHookQueue;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/createPluginApiHooks.js
var require_createPluginApiHooks = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/createPluginApiHooks.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPluginApiHooks = void 0;
    var createHookQueue_1 = require_createHookQueue();
    var createPluginApiHooks = () => ({
      onInitialized: (0, createHookQueue_1.createHookQueue)("onInitialized"),
      onPrepared: (0, createHookQueue_1.createHookQueue)("onPrepared"),
      onWatched: (0, createHookQueue_1.createHookQueue)("onWatched"),
      onGenerated: (0, createHookQueue_1.createHookQueue)("onGenerated"),
      extendsMarkdownOptions: (0, createHookQueue_1.createHookQueue)("extendsMarkdownOptions"),
      extendsMarkdown: (0, createHookQueue_1.createHookQueue)("extendsMarkdown"),
      extendsPageOptions: (0, createHookQueue_1.createHookQueue)("extendsPageOptions"),
      extendsPage: (0, createHookQueue_1.createHookQueue)("extendsPage"),
      extendsBundlerOptions: (0, createHookQueue_1.createHookQueue)("extendsBundlerOptions"),
      clientConfigFile: (0, createHookQueue_1.createHookQueue)("clientConfigFile"),
      alias: (0, createHookQueue_1.createHookQueue)("alias"),
      define: (0, createHookQueue_1.createHookQueue)("define")
    });
    exports2.createPluginApiHooks = createPluginApiHooks;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/normalizeClientConfigFileHook.js
var require_normalizeClientConfigFileHook = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/normalizeClientConfigFileHook.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeClientConfigFileHook = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var normalizeClientConfigFileHook = (hook) => async (app) => {
      const clientConfigFileResult = (0, shared_1.isFunction)(hook) ? await hook(app) : hook;
      const isExisted = await utils_1.fs.pathExists(clientConfigFileResult);
      if (!isExisted) {
        throw utils_1.logger.createError(`client config file does not exist: ${clientConfigFileResult}`);
      }
      return clientConfigFileResult;
    };
    exports2.normalizeClientConfigFileHook = normalizeClientConfigFileHook;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/normalizeReturnObjectHook.js
var require_normalizeReturnObjectHook = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/normalizeReturnObjectHook.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeReturnObjectHook = void 0;
    var shared_1 = require_dist();
    var normalizeReturnObjectHook = (hook) => async (app) => (0, shared_1.isFunction)(hook) ? hook(app) : hook;
    exports2.normalizeReturnObjectHook = normalizeReturnObjectHook;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/createPluginApiRegisterHooks.js
var require_createPluginApiRegisterHooks = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/createPluginApiRegisterHooks.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPluginApiRegisterHooks = void 0;
    var normalizeClientConfigFileHook_1 = require_normalizeClientConfigFileHook();
    var normalizeReturnObjectHook_1 = require_normalizeReturnObjectHook();
    var createPluginApiRegisterHooks = (plugins, hooks) => () => {
      plugins.forEach((_a) => {
        var _b = _a, { name: pluginName, alias, define, clientConfigFile } = _b, commonHooks = __objRest(_b, ["name", "alias", "define", "clientConfigFile"]);
        if (alias) {
          hooks.alias.add({
            pluginName,
            hook: (0, normalizeReturnObjectHook_1.normalizeReturnObjectHook)(alias)
          });
        }
        if (define) {
          hooks.define.add({
            pluginName,
            hook: (0, normalizeReturnObjectHook_1.normalizeReturnObjectHook)(define)
          });
        }
        if (clientConfigFile) {
          hooks.clientConfigFile.add({
            pluginName,
            hook: (0, normalizeClientConfigFileHook_1.normalizeClientConfigFileHook)(clientConfigFile)
          });
        }
        Object.entries(commonHooks).forEach(([key, hook]) => {
          if (hooks[key] && hook) {
            hooks[key].add({
              pluginName,
              hook
            });
          }
        });
      });
    };
    exports2.createPluginApiRegisterHooks = createPluginApiRegisterHooks;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/createPluginApi.js
var require_createPluginApi = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/createPluginApi.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPluginApi = void 0;
    var createPluginApiHooks_1 = require_createPluginApiHooks();
    var createPluginApiRegisterHooks_1 = require_createPluginApiRegisterHooks();
    var createPluginApi = () => {
      const plugins = [];
      const hooks = (0, createPluginApiHooks_1.createPluginApiHooks)();
      const registerHooks = (0, createPluginApiRegisterHooks_1.createPluginApiRegisterHooks)(plugins, hooks);
      return {
        plugins,
        hooks,
        registerHooks
      };
    };
    exports2.createPluginApi = createPluginApi;
  }
});

// node_modules/@vuepress/core/lib/pluginApi/index.js
var require_pluginApi = __commonJS({
  "node_modules/@vuepress/core/lib/pluginApi/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createHookQueue(), exports2);
    __exportStar(require_createPluginApi(), exports2);
    __exportStar(require_createPluginApiHooks(), exports2);
    __exportStar(require_createPluginApiRegisterHooks(), exports2);
    __exportStar(require_normalizeClientConfigFileHook(), exports2);
    __exportStar(require_normalizeReturnObjectHook(), exports2);
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppDir.js
var require_resolveAppDir = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppDir.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppDir = exports2.createAppDirFunction = void 0;
    var utils_1 = require_lib();
    var createAppDirFunction = (baseDir) => {
      return (...args) => utils_1.path.resolve(baseDir, ...args);
    };
    exports2.createAppDirFunction = createAppDirFunction;
    var resolveAppDir = (options2) => {
      const cache = (0, exports2.createAppDirFunction)(options2.cache);
      const temp = (0, exports2.createAppDirFunction)(options2.temp);
      const source = (0, exports2.createAppDirFunction)(options2.source);
      const dest = (0, exports2.createAppDirFunction)(options2.dest);
      const publicDir = (0, exports2.createAppDirFunction)(options2.public);
      const client = (0, exports2.createAppDirFunction)(utils_1.path.resolve(__require.resolve("@vuepress/client/package.json"), ".."));
      return {
        cache,
        temp,
        source,
        dest,
        client,
        public: publicDir
      };
    };
    exports2.resolveAppDir = resolveAppDir;
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppEnv.js
var require_resolveAppEnv = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppEnv.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppEnv = void 0;
    var resolveAppEnv = (options2, isBuild) => ({
      isBuild,
      isDev: !isBuild,
      isDebug: options2.debug
    });
    exports2.resolveAppEnv = resolveAppEnv;
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppOptions.js
var require_resolveAppOptions = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppOptions.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppOptions = void 0;
    var utils_1 = require_lib();
    var resolveAppOptions = ({
      base = "/",
      lang = "en-US",
      title = "",
      description = "",
      head = [],
      locales = {},
      source,
      dest = utils_1.path.resolve(source, ".vuepress/dist"),
      temp = utils_1.path.resolve(source, ".vuepress/.temp"),
      cache = utils_1.path.resolve(source, ".vuepress/.cache"),
      public: publicDir = utils_1.path.resolve(source, ".vuepress/public"),
      host = "0.0.0.0",
      port = 8080,
      open = false,
      templateDev = utils_1.path.normalize(__require.resolve("@vuepress/client/templates/dev.html")),
      shouldPreload = true,
      shouldPrefetch = true,
      templateBuild = utils_1.path.normalize(__require.resolve("@vuepress/client/templates/build.html")),
      bundler,
      debug = false,
      markdown = {},
      pagePatterns = ["**/*.md", "!.vuepress", "!node_modules"],
      plugins = [],
      theme
    }) => ({
      base,
      lang,
      title,
      description,
      head,
      locales,
      source,
      dest,
      temp,
      cache,
      public: publicDir,
      host,
      port,
      open,
      templateDev,
      shouldPreload,
      shouldPrefetch,
      templateBuild,
      bundler,
      debug,
      markdown,
      pagePatterns,
      plugins,
      theme
    });
    exports2.resolveAppOptions = resolveAppOptions;
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppSiteData.js
var require_resolveAppSiteData = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppSiteData.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppSiteData = void 0;
    var resolveAppSiteData = (options2) => ({
      base: options2.base,
      lang: options2.lang,
      title: options2.title,
      description: options2.description,
      head: options2.head,
      locales: options2.locales
    });
    exports2.resolveAppSiteData = resolveAppSiteData;
  }
});

// node_modules/@vuepress/core/package.json
var require_package = __commonJS({
  "node_modules/@vuepress/core/package.json"(exports2, module2) {
    module2.exports = {
      name: "@vuepress/core",
      version: "2.0.0-beta.46",
      description: "Core package of VuePress",
      keywords: [
        "vuepress",
        "core"
      ],
      homepage: "https://github.com/vuepress",
      bugs: {
        url: "https://github.com/vuepress/vuepress-next/issues"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/vuepress/vuepress-next.git"
      },
      license: "MIT",
      author: "meteorlxy",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "lib"
      ],
      dependencies: {
        "@vuepress/client": "2.0.0-beta.46",
        "@vuepress/markdown": "2.0.0-beta.46",
        "@vuepress/shared": "2.0.0-beta.46",
        "@vuepress/utils": "2.0.0-beta.46",
        "gray-matter": "^4.0.3",
        toml: "^3.0.0",
        vue: "^3.2.35"
      },
      publishConfig: {
        access: "public"
      },
      scripts: {
        build: "tsc -b tsconfig.build.json",
        clean: "rimraf lib *.tsbuildinfo"
      }
    };
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppVersion.js
var require_resolveAppVersion = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppVersion.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppVersion = void 0;
    var resolveAppVersion = () => {
      return require_package().version;
    };
    exports2.resolveAppVersion = resolveAppVersion;
  }
});

// node_modules/@vuepress/core/lib/app/resolveAppWriteTemp.js
var require_resolveAppWriteTemp = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveAppWriteTemp.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppWriteTemp = void 0;
    var utils_1 = require_lib();
    var resolveAppWriteTemp = (dir) => {
      const tempCache = /* @__PURE__ */ new Map();
      const writeTemp = async (file, content) => {
        const filePath = dir.temp(file);
        const contentCached = tempCache.get(filePath);
        if (contentCached !== content) {
          await utils_1.fs.outputFile(filePath, content);
          tempCache.set(filePath, content);
        }
        return filePath;
      };
      return writeTemp;
    };
    exports2.resolveAppWriteTemp = resolveAppWriteTemp;
  }
});

// node_modules/@vuepress/core/lib/app/resolveThemeLayouts.js
var require_resolveThemeLayouts = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveThemeLayouts.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveThemeLayouts = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var resolveThemeLayouts = (layouts = {}) => {
      if ((0, shared_1.isPlainObject)(layouts)) {
        return layouts;
      }
      if (!utils_1.fs.pathExistsSync(layouts)) {
        throw utils_1.logger.createError(`layouts directory does not exist: ${utils_1.chalk.magenta(layouts)}`);
      }
      return Object.fromEntries(utils_1.fs.readdirSync(layouts).filter((file) => /\.(vue|ts|js)$/.test(file)).map((file) => [utils_1.path.trimExt(file), utils_1.path.resolve(layouts, file)]));
    };
    exports2.resolveThemeLayouts = resolveThemeLayouts;
  }
});

// node_modules/@vuepress/core/lib/app/resolveThemeInfo.js
var require_resolveThemeInfo = __commonJS({
  "node_modules/@vuepress/core/lib/app/resolveThemeInfo.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveThemeInfo = void 0;
    var resolvePluginObject_1 = require_resolvePluginObject();
    var resolveThemeLayouts_1 = require_resolveThemeLayouts();
    var resolveThemeInfo = (app, theme) => {
      var _a, _b, _c;
      const themeObject = (0, resolvePluginObject_1.resolvePluginObject)(app, theme);
      const themeInfo = {
        layouts: (0, resolveThemeLayouts_1.resolveThemeLayouts)(themeObject.layouts),
        plugins: [...(_a = themeObject.plugins) != null ? _a : [], themeObject],
        templateBuild: themeObject.templateBuild,
        templateDev: themeObject.templateDev
      };
      if (!themeObject.extends) {
        return themeInfo;
      }
      const parentThemeInfo = (0, exports2.resolveThemeInfo)(app, themeObject.extends);
      return {
        layouts: __spreadValues(__spreadValues({}, parentThemeInfo.layouts), themeInfo.layouts),
        plugins: [...parentThemeInfo.plugins, ...themeInfo.plugins],
        templateBuild: (_b = themeObject.templateBuild) != null ? _b : parentThemeInfo.templateBuild,
        templateDev: (_c = themeObject.templateDev) != null ? _c : parentThemeInfo.templateDev
      };
    };
    exports2.resolveThemeInfo = resolveThemeInfo;
  }
});

// node_modules/@vuepress/core/lib/app/setupAppThemeAndPlugins.js
var require_setupAppThemeAndPlugins = __commonJS({
  "node_modules/@vuepress/core/lib/app/setupAppThemeAndPlugins.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAppThemeAndPlugins = void 0;
    var resolveThemeInfo_1 = require_resolveThemeInfo();
    var setupAppThemeAndPlugins = (app, config) => {
      var _a, _b, _c, _d;
      const themeInfo = (0, resolveThemeInfo_1.resolveThemeInfo)(app, app.options.theme);
      app.layouts = themeInfo.layouts;
      app.options.templateDev = (_b = (_a = config.templateDev) != null ? _a : themeInfo.templateDev) != null ? _b : app.options.templateDev;
      app.options.templateBuild = (_d = (_c = config.templateBuild) != null ? _c : themeInfo.templateBuild) != null ? _d : app.options.templateBuild;
      [...themeInfo.plugins, ...app.options.plugins].flat().forEach((plugin) => app.use(plugin));
    };
    exports2.setupAppThemeAndPlugins = setupAppThemeAndPlugins;
  }
});

// node_modules/@vuepress/core/lib/app/createBaseApp.js
var require_createBaseApp = __commonJS({
  "node_modules/@vuepress/core/lib/app/createBaseApp.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBaseApp = void 0;
    var pluginApi_1 = require_pluginApi();
    var appInit_1 = require_appInit();
    var appPrepare_1 = require_appPrepare();
    var appUse_1 = require_appUse();
    var resolveAppDir_1 = require_resolveAppDir();
    var resolveAppEnv_1 = require_resolveAppEnv();
    var resolveAppOptions_1 = require_resolveAppOptions();
    var resolveAppSiteData_1 = require_resolveAppSiteData();
    var resolveAppVersion_1 = require_resolveAppVersion();
    var resolveAppWriteTemp_1 = require_resolveAppWriteTemp();
    var setupAppThemeAndPlugins_1 = require_setupAppThemeAndPlugins();
    var createBaseApp = (config, isBuild = false) => {
      const options2 = (0, resolveAppOptions_1.resolveAppOptions)(config);
      const dir = (0, resolveAppDir_1.resolveAppDir)(options2);
      const env = (0, resolveAppEnv_1.resolveAppEnv)(options2, isBuild);
      const pluginApi = (0, pluginApi_1.createPluginApi)();
      const siteData = (0, resolveAppSiteData_1.resolveAppSiteData)(options2);
      const version = (0, resolveAppVersion_1.resolveAppVersion)();
      const writeTemp = (0, resolveAppWriteTemp_1.resolveAppWriteTemp)(dir);
      const app = {
        options: options2,
        siteData,
        version,
        dir,
        env,
        pluginApi,
        writeTemp,
        use: (...args) => (0, appUse_1.appUse)(app, ...args),
        init: () => (0, appInit_1.appInit)(app),
        prepare: () => (0, appPrepare_1.appPrepare)(app)
      };
      (0, setupAppThemeAndPlugins_1.setupAppThemeAndPlugins)(app, config);
      return app;
    };
    exports2.createBaseApp = createBaseApp;
  }
});

// node_modules/@vuepress/core/lib/app/createBuildApp.js
var require_createBuildApp = __commonJS({
  "node_modules/@vuepress/core/lib/app/createBuildApp.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBuildApp = void 0;
    var createBaseApp_1 = require_createBaseApp();
    var createBuildApp = (config) => {
      const app = (0, createBaseApp_1.createBaseApp)(config, true);
      app.build = () => app.options.bundler.build(app);
      return app;
    };
    exports2.createBuildApp = createBuildApp;
  }
});

// node_modules/@vuepress/core/lib/app/createDevApp.js
var require_createDevApp = __commonJS({
  "node_modules/@vuepress/core/lib/app/createDevApp.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDevApp = void 0;
    var createBaseApp_1 = require_createBaseApp();
    var createDevApp = (config) => {
      const app = (0, createBaseApp_1.createBaseApp)(config, false);
      app.dev = () => app.options.bundler.dev(app);
      return app;
    };
    exports2.createDevApp = createDevApp;
  }
});

// node_modules/@vuepress/core/lib/app/index.js
var require_app = __commonJS({
  "node_modules/@vuepress/core/lib/app/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_prepare(), exports2);
    __exportStar(require_appInit(), exports2);
    __exportStar(require_appPrepare(), exports2);
    __exportStar(require_appUse(), exports2);
    __exportStar(require_createBaseApp(), exports2);
    __exportStar(require_createBuildApp(), exports2);
    __exportStar(require_createDevApp(), exports2);
    __exportStar(require_resolveAppDir(), exports2);
    __exportStar(require_resolveAppEnv(), exports2);
    __exportStar(require_resolveAppOptions(), exports2);
    __exportStar(require_resolveAppPages(), exports2);
    __exportStar(require_resolveAppSiteData(), exports2);
    __exportStar(require_resolveAppVersion(), exports2);
    __exportStar(require_resolveAppWriteTemp(), exports2);
    __exportStar(require_resolvePluginObject(), exports2);
    __exportStar(require_resolveThemeInfo(), exports2);
    __exportStar(require_resolveThemeLayouts(), exports2);
  }
});

// node_modules/@vuepress/core/lib/types/app/app.js
var require_app2 = __commonJS({
  "node_modules/@vuepress/core/lib/types/app/app.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/app/options.js
var require_options = __commonJS({
  "node_modules/@vuepress/core/lib/types/app/options.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/app/utils.js
var require_utils4 = __commonJS({
  "node_modules/@vuepress/core/lib/types/app/utils.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/app/index.js
var require_app3 = __commonJS({
  "node_modules/@vuepress/core/lib/types/app/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_app2(), exports2);
    __exportStar(require_options(), exports2);
    __exportStar(require_utils4(), exports2);
  }
});

// node_modules/@vuepress/core/lib/types/bundler.js
var require_bundler = __commonJS({
  "node_modules/@vuepress/core/lib/types/bundler.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/page.js
var require_page2 = __commonJS({
  "node_modules/@vuepress/core/lib/types/page.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/plugin.js
var require_plugin = __commonJS({
  "node_modules/@vuepress/core/lib/types/plugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/pluginApi/hooks.js
var require_hooks = __commonJS({
  "node_modules/@vuepress/core/lib/types/pluginApi/hooks.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/pluginApi/pluginApi.js
var require_pluginApi2 = __commonJS({
  "node_modules/@vuepress/core/lib/types/pluginApi/pluginApi.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/pluginApi/index.js
var require_pluginApi3 = __commonJS({
  "node_modules/@vuepress/core/lib/types/pluginApi/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_hooks(), exports2);
    __exportStar(require_pluginApi2(), exports2);
  }
});

// node_modules/@vuepress/core/lib/types/theme.js
var require_theme = __commonJS({
  "node_modules/@vuepress/core/lib/types/theme.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/core/lib/types/index.js
var require_types3 = __commonJS({
  "node_modules/@vuepress/core/lib/types/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_app3(), exports2);
    __exportStar(require_bundler(), exports2);
    __exportStar(require_page2(), exports2);
    __exportStar(require_plugin(), exports2);
    __exportStar(require_pluginApi3(), exports2);
    __exportStar(require_theme(), exports2);
  }
});

// node_modules/@vuepress/core/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@vuepress/core/lib/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_app(), exports2);
    __exportStar(require_page(), exports2);
    __exportStar(require_pluginApi(), exports2);
    __exportStar(require_types3(), exports2);
  }
});

// node_modules/@vuepress/cli/lib/config/defineUserConfig.js
var require_defineUserConfig = __commonJS({
  "node_modules/@vuepress/cli/lib/config/defineUserConfig.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineUserConfig = void 0;
    var defineUserConfig = (config) => config;
    exports2.defineUserConfig = defineUserConfig;
  }
});

// node_modules/@vuepress/cli/lib/config/loadUserConfigCjs.js
var require_loadUserConfigCjs = __commonJS({
  "node_modules/@vuepress/cli/lib/config/loadUserConfigCjs.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadUserConfigCjs = void 0;
    var utils_1 = require_lib();
    var loadUserConfigCjs = async (userConfigPath) => {
      const required = __require(userConfigPath);
      return (0, utils_1.hasExportDefault)(required) ? required.default : required;
    };
    exports2.loadUserConfigCjs = loadUserConfigCjs;
  }
});

// node_modules/@vuepress/cli/lib/config/loadUserConfig.js
var require_loadUserConfig = __commonJS({
  "node_modules/@vuepress/cli/lib/config/loadUserConfig.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadUserConfig = void 0;
    var loadUserConfigCjs_1 = require_loadUserConfigCjs();
    var loaderMap = [
      [/\.(js|cjs|ts)$/, loadUserConfigCjs_1.loadUserConfigCjs]
    ];
    var loadUserConfig = async (userConfigPath) => {
      if (!userConfigPath)
        return {};
      for (const [condition, loader] of loaderMap) {
        if (condition.test(userConfigPath)) {
          return loader(userConfigPath);
        }
      }
      return {};
    };
    exports2.loadUserConfig = loadUserConfig;
  }
});

// node_modules/@vuepress/cli/lib/config/resolveUserConfigConventionalPath.js
var require_resolveUserConfigConventionalPath = __commonJS({
  "node_modules/@vuepress/cli/lib/config/resolveUserConfigConventionalPath.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveUserConfigConventionalPath = void 0;
    var utils_1 = require_lib();
    var resolveUserConfigConventionalPath = (source, cwd = process.cwd()) => [
      utils_1.path.resolve(cwd, "vuepress.config.ts"),
      utils_1.path.resolve(cwd, "vuepress.config.js"),
      utils_1.path.resolve(cwd, "vuepress.config.cjs"),
      utils_1.path.resolve(source, ".vuepress/config.ts"),
      utils_1.path.resolve(source, ".vuepress/config.js"),
      utils_1.path.resolve(source, ".vuepress/config.cjs")
    ].find((item) => utils_1.fs.pathExistsSync(item));
    exports2.resolveUserConfigConventionalPath = resolveUserConfigConventionalPath;
  }
});

// node_modules/@vuepress/cli/lib/config/resolveUserConfigPath.js
var require_resolveUserConfigPath = __commonJS({
  "node_modules/@vuepress/cli/lib/config/resolveUserConfigPath.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveUserConfigPath = void 0;
    var utils_1 = require_lib();
    var resolveUserConfigPath = (config, cwd = process.cwd()) => {
      const configPath = utils_1.path.resolve(cwd, config);
      if (!utils_1.fs.pathExistsSync(configPath)) {
        throw utils_1.logger.createError(`config file does not exist: ${utils_1.chalk.magenta(config)}`);
      }
      return configPath;
    };
    exports2.resolveUserConfigPath = resolveUserConfigPath;
  }
});

// node_modules/@vuepress/cli/lib/config/transformUserConfigToPlugin.js
var require_transformUserConfigToPlugin = __commonJS({
  "node_modules/@vuepress/cli/lib/config/transformUserConfigToPlugin.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformUserConfigToPlugin = void 0;
    var utils_1 = require_lib();
    var transformUserConfigToPlugin = (userConfig, source, cwd = process.cwd()) => {
      const userConfigPlugin = __spreadValues({
        name: "user-config"
      }, userConfig);
      if (userConfigPlugin.clientConfigFile === void 0) {
        userConfigPlugin.clientConfigFile = [
          utils_1.path.resolve(cwd, "vuepress.client.ts"),
          utils_1.path.resolve(cwd, "vuepress.client.js"),
          utils_1.path.resolve(cwd, "vuepress.client.mjs"),
          utils_1.path.resolve(source, ".vuepress/client.ts"),
          utils_1.path.resolve(source, ".vuepress/client.js"),
          utils_1.path.resolve(source, ".vuepress/client.mjs")
        ].find((item) => utils_1.fs.pathExistsSync(item));
      }
      return userConfigPlugin;
    };
    exports2.transformUserConfigToPlugin = transformUserConfigToPlugin;
  }
});

// node_modules/@vuepress/cli/lib/config/types.js
var require_types4 = __commonJS({
  "node_modules/@vuepress/cli/lib/config/types.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/cli/lib/config/index.js
var require_config = __commonJS({
  "node_modules/@vuepress/cli/lib/config/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_defineUserConfig(), exports2);
    __exportStar(require_loadUserConfig(), exports2);
    __exportStar(require_loadUserConfigCjs(), exports2);
    __exportStar(require_resolveUserConfigConventionalPath(), exports2);
    __exportStar(require_resolveUserConfigPath(), exports2);
    __exportStar(require_transformUserConfigToPlugin(), exports2);
    __exportStar(require_types4(), exports2);
  }
});

// node_modules/@vuepress/cli/lib/utils/esbuildUtils.js
var require_esbuildUtils = __commonJS({
  "node_modules/@vuepress/cli/lib/utils/esbuildUtils.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformTsFileToCodeSync = void 0;
    var utils_1 = require_lib();
    var esbuild_1 = require_main();
    var transformTsFileToCodeSync = (filename) => (0, esbuild_1.transformSync)(utils_1.fs.readFileSync(filename).toString(), {
      format: "cjs",
      loader: "ts",
      sourcefile: filename,
      sourcemap: "inline",
      target: "node14"
    }).code;
    exports2.transformTsFileToCodeSync = transformTsFileToCodeSync;
  }
});

// node_modules/@vuepress/cli/lib/utils/allowTs.js
var require_allowTs = __commonJS({
  "node_modules/@vuepress/cli/lib/utils/allowTs.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allowTs = void 0;
    var esbuildUtils_1 = require_esbuildUtils();
    var allowTs = () => {
      __require.extensions[".ts"] = (m, filename) => {
        m._compile((0, esbuildUtils_1.transformTsFileToCodeSync)(filename), filename);
      };
    };
    exports2.allowTs = allowTs;
  }
});

// node_modules/@vuepress/cli/lib/utils/resolveAppConfig.js
var require_resolveAppConfig = __commonJS({
  "node_modules/@vuepress/cli/lib/utils/resolveAppConfig.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAppConfig = void 0;
    var shared_1 = require_dist();
    var utils_1 = require_lib();
    var resolveAppConfig = ({ defaultAppConfig, cliAppConfig, userConfig }) => {
      const appConfig = __spreadValues(__spreadValues(__spreadValues({}, defaultAppConfig), userConfig), cliAppConfig);
      if (appConfig.bundler === void 0 || appConfig.theme === void 0) {
        utils_1.logger.error(`${utils_1.chalk.magenta("bundler")} and ${utils_1.chalk.magenta("theme")} are required`);
        return null;
      }
      if (appConfig.base && !(appConfig.base.startsWith("/") && appConfig.base.endsWith("/"))) {
        const rawBase = appConfig.base;
        appConfig.base = (0, shared_1.ensureLeadingSlash)((0, shared_1.ensureEndingSlash)(rawBase));
        utils_1.logger.warn(`${utils_1.chalk.magenta("base")} should start and end with a slash (/), so it has been normalized from ${utils_1.chalk.magenta(rawBase)} to ${utils_1.chalk.magenta(appConfig.base)}`);
      }
      if (appConfig.dest && utils_1.path.normalize(appConfig.source).includes(utils_1.path.normalize(appConfig.dest))) {
        utils_1.logger.warn(`${utils_1.chalk.magenta("dest")} directory would be emptied during build, so we fallback it to the default directory for the safety of your source files`);
        delete appConfig.dest;
      }
      return appConfig;
    };
    exports2.resolveAppConfig = resolveAppConfig;
  }
});

// node_modules/@vuepress/cli/lib/utils/resolveCliAppConfig.js
var require_resolveCliAppConfig = __commonJS({
  "node_modules/@vuepress/cli/lib/utils/resolveCliAppConfig.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveCliAppConfig = void 0;
    var utils_1 = require_lib();
    var OPTIONS_COMMON = ["debug", "open", "port", "host"];
    var OPTIONS_DIRECTORY = ["cache", "dest", "temp"];
    var resolveCliAppConfig = (sourceDir, commandOptions, cwd = process.cwd()) => {
      const source = utils_1.path.resolve(cwd, sourceDir);
      const appConfig = {
        source
      };
      OPTIONS_COMMON.forEach((name) => {
        if (commandOptions[name] !== void 0) {
          appConfig[name] = commandOptions[name];
        }
      });
      OPTIONS_DIRECTORY.forEach((name) => {
        if (commandOptions[name] !== void 0) {
          appConfig[name] = utils_1.path.resolve(cwd, commandOptions[name]);
        }
      });
      return appConfig;
    };
    exports2.resolveCliAppConfig = resolveCliAppConfig;
  }
});

// node_modules/@vuepress/cli/lib/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/@vuepress/cli/lib/utils/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_allowTs(), exports2);
    __exportStar(require_esbuildUtils(), exports2);
    __exportStar(require_resolveAppConfig(), exports2);
    __exportStar(require_resolveCliAppConfig(), exports2);
  }
});

// node_modules/@vuepress/cli/lib/commands/build/createBuild.js
var require_createBuild = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/build/createBuild.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBuild = void 0;
    var core_1 = require_lib4();
    var utils_1 = require_lib();
    var config_1 = require_config();
    var utils_2 = require_utils5();
    var log = (0, utils_1.debug)("vuepress:cli/build");
    var createBuild = (defaultAppConfig) => async (sourceDir = ".", commandOptions = {}) => {
      log(`commandOptions:`, commandOptions);
      if ("development" === void 0) {
        "development" = "production";
      }
      const cliAppConfig = (0, utils_2.resolveCliAppConfig)(sourceDir, commandOptions);
      const userConfigPath = commandOptions.config ? (0, config_1.resolveUserConfigPath)(commandOptions.config) : (0, config_1.resolveUserConfigConventionalPath)(cliAppConfig.source);
      log(`userConfigPath:`, userConfigPath);
      const userConfig = await (0, config_1.loadUserConfig)(userConfigPath);
      const appConfig = (0, utils_2.resolveAppConfig)({
        defaultAppConfig,
        cliAppConfig,
        userConfig
      });
      if (appConfig === null) {
        return;
      }
      const app = (0, core_1.createBuildApp)(appConfig);
      app.use((0, config_1.transformUserConfigToPlugin)(userConfig, cliAppConfig.source));
      if (commandOptions.cleanTemp === true) {
        utils_1.logger.info("Cleaning temp...");
        await utils_1.fs.remove(app.dir.temp());
      }
      if (commandOptions.cleanCache === true) {
        utils_1.logger.info("Cleaning cache...");
        await utils_1.fs.remove(app.dir.cache());
      }
      await utils_1.fs.emptyDir(app.dir.dest());
      utils_1.logger.info("Initializing VuePress and preparing data...");
      await app.init();
      await app.prepare();
      await app.build();
      await app.pluginApi.hooks.onGenerated.process(app);
      utils_1.logger.success("VuePress build successfully!");
    };
    exports2.createBuild = createBuild;
  }
});

// node_modules/@vuepress/cli/lib/commands/build/types.js
var require_types5 = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/build/types.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/cli/lib/commands/build/index.js
var require_build = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/build/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createBuild(), exports2);
    __exportStar(require_types5(), exports2);
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/resolveDevUserConfig.js
var require_resolveDevUserConfig = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/resolveDevUserConfig.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveDevUserConfig = void 0;
    var os = (init_os(), __toCommonJS(os_exports));
    var path_1 = (init_path(), __toCommonJS(path_exports));
    var config_1 = require_config();
    var normalizeRequireCacheKey = (key) => os.platform() === "win32" ? path_1.win32.normalize(key) : key;
    var resolveDeps = (filename, deps = /* @__PURE__ */ new Set(), seen = /* @__PURE__ */ new Set()) => {
      const mod = __require.cache[normalizeRequireCacheKey(filename)];
      if (!mod)
        return deps;
      if (seen.has(filename))
        return deps;
      seen.add(filename);
      mod.children.forEach(({ id }) => {
        if (!id.includes("node_modules")) {
          deps.add(id);
          resolveDeps(id, deps, seen);
        }
      });
      return deps;
    };
    var resolveDevUserConfig = async (userConfigPath) => {
      if (!userConfigPath) {
        return {
          userConfig: {},
          userConfigDeps: []
        };
      }
      resolveDeps(userConfigPath).forEach((item) => {
        delete __require.cache[normalizeRequireCacheKey(item)];
      });
      delete __require.cache[normalizeRequireCacheKey(userConfigPath)];
      const userConfig = await (0, config_1.loadUserConfig)(userConfigPath);
      const userConfigDeps = Array.from(resolveDeps(userConfigPath));
      return {
        userConfig,
        userConfigDeps
      };
    };
    exports2.resolveDevUserConfig = resolveDevUserConfig;
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var { Readable } = (init_stream(), __toCommonJS(stream_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var picomatch = require_picomatch();
    var readdir = promisify(fs.readdir);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n2) => Number.parseInt(n2, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const glob = picomatch(filter.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter)) {
        const positive = [];
        const negative = [];
        for (const item of filter) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f2) => f2(entry.basename)) && !negative.some((f2) => f2(entry.basename));
          }
          return (entry) => !negative.some((f2) => f2(entry.basename));
        }
        return (entry) => positive.some((f2) => f2(entry.basename));
      }
    };
    var ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          fileFilter: (path) => true,
          directoryFilter: (path) => true,
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = __spreadValues(__spreadValues({}, ReaddirpStream.defaultOptions), options2);
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        if (wantBigintFsStats) {
          this._stat = (path) => statMethod(path, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = "Dirent" in fs && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
              for (const entry of await Promise.all(slice)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path, depth) {
        let files;
        try {
          files = await readdir(path, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path };
      }
      async _formatEntry(dirent, path) {
        let entry;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path, basename));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath(full);
            const entryRealPathStats = await lstat(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options2.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root;
      return new ReaddirpStream(options2);
    };
    var readdirpPromise = (root, options2 = {}) => {
      return new Promise((resolve, reject) => {
        const files = [];
        readdirp(root, options2).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module2.exports = readdirp;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picomatch = require_picomatch();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options2) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options2);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path = normalizePath(_path);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path].concat(args.slice(1));
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module2.exports = anymatch;
  }
});

// node_modules/chokidar/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/chokidar/node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isGlob = require_is_glob();
    var pathPosixDirname = (init_path(), __toCommonJS(path_exports)).posix.dirname;
    var isWin32 = (init_os(), __toCommonJS(os_exports)).platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str2, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str2.indexOf(slash) < 0) {
        str2 = str2.replace(backslash, slash);
      }
      if (enclosure.test(str2)) {
        str2 += slash;
      }
      str2 += "a";
      do {
        str2 = pathPosixDirname(str2);
      } while (isGlob(str2) || globby.test(str2));
      return str2.replace(escaped, "$1");
    };
  }
});

// node_modules/chokidar/node_modules/braces/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n2 = 0, type) => {
      let node = block.nodes[n2];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i2 = 0; i2 < arr.length; i2++) {
          let ele = arr[i2];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/chokidar/node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var utils = require_utils6();
    module2.exports = (ast, options2 = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options2.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/chokidar/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/chokidar/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/chokidar/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/chokidar/node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options2) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = __spreadValues({ relaxZeros: true }, options2);
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a2 = Math.min(min, max);
      let b2 = Math.max(min, max);
      if (Math.abs(a2 - b2) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a: a2, b: b2 };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a2 < 0) {
        let newMin = b2 < 0 ? Math.abs(b2) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
        a2 = state.a = 0;
      }
      if (b2 >= 0) {
        positives = splitToPatterns(a2, b2, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options2) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options2) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options2) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options2) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options2) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options2);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options2.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options2) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2];
        let obj = rangeToPattern(String(start), String(max2), options2);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options2);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options2) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a2, b2) {
      let arr = [];
      for (let i2 = 0; i2 < a2.length; i2++)
        arr.push([a2[i2], b2[i2]]);
      return arr;
    }
    function compare(a2, b2) {
      return a2 > b2 ? 1 : b2 > a2 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a2, b2, options2) {
      return `[${a2}${b2 - a2 === 1 ? "" : "-"}${b2}]`;
    }
    function hasPadding(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros(value, tok, options2) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options2.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/chokidar/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/chokidar/node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var util = (init_util(), __toCommonJS(util_exports));
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options2) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options2) => {
      parts.negatives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      parts.positives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a2, b2, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a2, b2, __spreadValues({ wrap: false }, options2));
      }
      let start = String.fromCharCode(a2);
      if (a2 === b2)
        return start;
      let stop = String.fromCharCode(b2);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options2) => {
      if (Array.isArray(start)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options2);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options2) => {
      if (options2.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options2 = {}) => {
      let a2 = Number(start);
      let b2 = Number(end);
      if (!Number.isInteger(a2) || !Number.isInteger(b2)) {
        if (options2.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a2 === 0)
        a2 = 0;
      if (b2 === 0)
        b2 = 0;
      let descending = a2 > b2;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options2) === false;
      let format = options2.transform || transform(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        if (options2.toRegex === true && step > 1) {
          push(a2);
        } else {
          range.push(pad(format(a2, index), maxLen, toNumber));
        }
        a2 = descending ? a2 - step : a2 + step;
        index++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2) : toRegex(range, null, __spreadValues({ wrap: false }, options2));
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options2 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options2);
      }
      let format = options2.transform || ((val) => String.fromCharCode(val));
      let a2 = `${start}`.charCodeAt(0);
      let b2 = `${end}`.charCodeAt(0);
      let descending = a2 > b2;
      let min = Math.min(a2, b2);
      let max = Math.max(a2, b2);
      if (options2.toRegex && step === 1) {
        return toRange(min, max, false, options2);
      }
      let range = [];
      let index = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        range.push(format(a2, index));
        a2 = descending ? a2 - step : a2 + step;
        index++;
      }
      if (options2.toRegex === true) {
        return toRegex(range, null, { wrap: false, options: options2 });
      }
      return range;
    };
    var fill = (start, end, step, options2 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options2);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = __spreadValues({}, options2);
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/chokidar/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fill = require_fill_range();
    var utils = require_utils6();
    var compile = (ast, options2 = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options2.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, __spreadProps(__spreadValues({}, options2), { wrap: false, toRegex: true }));
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/chokidar/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fill = require_fill_range();
    var stringify = require_stringify2();
    var utils = require_utils6();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options2 = {}) => {
      let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options2)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options2);
          if (range.length === 0) {
            range = stringify(node, options2);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i2 = 0; i2 < node.nodes.length; i2++) {
          let child = node.nodes[i2];
          if (child.type === "comma" && node.type === "brace") {
            if (i2 === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/chokidar/node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/chokidar/node_modules/braces/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/chokidar/node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var stringify = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse2 = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options2 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options2.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options2.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse2;
  }
});

// node_modules/chokidar/node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/chokidar/node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var stringify = require_stringify2();
    var compile = require_compile();
    var expand = require_expand();
    var parse2 = require_parse3();
    var braces = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options2);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options2 = {}) => parse2(input, options2);
    braces.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options2), options2);
      }
      return stringify(input, options2);
    };
    braces.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options2);
      }
      let result = expand(input, options2);
      if (options2.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces.compile(input, options2) : braces.expand(input, options2);
    };
    module2.exports = braces;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports2, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var path = (init_path(), __toCommonJS(path_exports));
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module2.exports = (filePath) => extensions.has(path.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/chokidar/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/chokidar/lib/constants.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var { sep } = (init_path(), __toCommonJS(path_exports));
    var { platform } = process;
    var os = (init_os(), __toCommonJS(os_exports));
    exports2.EV_ALL = "all";
    exports2.EV_READY = "ready";
    exports2.EV_ADD = "add";
    exports2.EV_CHANGE = "change";
    exports2.EV_ADD_DIR = "addDir";
    exports2.EV_UNLINK = "unlink";
    exports2.EV_UNLINK_DIR = "unlinkDir";
    exports2.EV_RAW = "raw";
    exports2.EV_ERROR = "error";
    exports2.STR_DATA = "data";
    exports2.STR_END = "end";
    exports2.STR_CLOSE = "close";
    exports2.FSEVENT_CREATED = "created";
    exports2.FSEVENT_MODIFIED = "modified";
    exports2.FSEVENT_DELETED = "deleted";
    exports2.FSEVENT_MOVED = "moved";
    exports2.FSEVENT_CLONED = "cloned";
    exports2.FSEVENT_UNKNOWN = "unknown";
    exports2.FSEVENT_TYPE_FILE = "file";
    exports2.FSEVENT_TYPE_DIRECTORY = "directory";
    exports2.FSEVENT_TYPE_SYMLINK = "symlink";
    exports2.KEY_LISTENERS = "listeners";
    exports2.KEY_ERR = "errHandlers";
    exports2.KEY_RAW = "rawEmitters";
    exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
    exports2.DOT_SLASH = `.${sep}`;
    exports2.BACK_SLASH_RE = /\\/g;
    exports2.DOUBLE_SLASH_RE = /\/\//;
    exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports2.REPLACER_RE = /^\.[/\\]/;
    exports2.SLASH = "/";
    exports2.SLASH_SLASH = "//";
    exports2.BRACE_START = "{";
    exports2.BANG = "!";
    exports2.ONE_DOT = ".";
    exports2.TWO_DOTS = "..";
    exports2.STAR = "*";
    exports2.GLOBSTAR = "**";
    exports2.ROOT_GLOBSTAR = "/**/*";
    exports2.SLASH_GLOBSTAR = "/**";
    exports2.DIR_SUFFIX = "Dir";
    exports2.ANYMATCH_OPTS = { dot: true };
    exports2.STRING_TYPE = "string";
    exports2.FUNCTION_TYPE = "function";
    exports2.EMPTY_STR = "";
    exports2.EMPTY_FN = () => {
    };
    exports2.IDENTITY_FN = (val) => val;
    exports2.isWindows = platform === "win32";
    exports2.isMacos = platform === "darwin";
    exports2.isLinux = platform === "linux";
    exports2.isIBMi = os.type() === "OS400";
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows,
      isLinux,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants2();
    var THROTTLE_MODE_WATCH = "watch";
    var open = promisify(fs.open);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var close = promisify(fs.close);
    var fsrealpath = promisify(fs.realpath);
    var statMethods = { lstat, stat };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path, options2, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        if (evPath && path !== evPath) {
          fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
        }
      };
      try {
        return fs.watch(path, options2, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path, fullPath, options2, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(path, options2, listener, errHandler, rawEmitter);
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(path, options2, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
          return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows && error.code === "EPERM") {
            try {
              const fd = await open(path, "r");
              await close(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path, fullPath, options2, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options2 = { persistent: opts.persistent };
        if (!listener)
          listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path, absolutePath, options2, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path, absolutePath, options2, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        let prevStats = stats;
        if (parent.has(basename))
          return;
        const listener = async (path, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path);
                prevStats = newStats2;
                this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname, basename);
            }
          } else if (parent.has(basename)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0))
            return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path);
          } catch (e2) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path = sysPath.join(dir, sysPath.relative(dir, path));
            this._addToNodeFs(path, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise((resolve) => stream.once(STR_END, () => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const wasThrottled = throttler ? throttler.clear() : false;
          resolve();
          previous.getChildren().filter((item) => {
            return item !== directory && !current.has(item) && (!wh.hasGlob || wh.filterPath({
              fullPath: sysPath.resolve(directory, item)
            }));
          }).forEach((item) => {
            this.fsw._remove(directory, item);
          });
          stream = void 0;
          if (wasThrottled)
            this._handleRead(directory, false, wh, target, dir, depth, throttler);
        }));
      }
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path);
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path;
          }
        }
      }
    };
    module2.exports = NodeFsHandler;
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports2, module2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var fsevents;
    try {
      fsevents = __require("fsevents");
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants2();
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var statMethods = { stat, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path, callback) => {
      const stop = fsevents.watch(path, callback);
      return { stop };
    };
    function setFSEventsListener(path, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path, root) => {
      let i2 = 0;
      while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root)
        i2++;
      return i2;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path, stats)) {
          ipaths.add(path);
          if (stats && stats.isDirectory()) {
            ipaths.add(path + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path);
        ipaths.delete(path + ROOT_GLOBSTAR);
      }
      addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat(path);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path))
          return;
        if (event === EV_UNLINK) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path);
          if (eventName === EV_ADD_DIR)
            this._addToFsEvents(path, false, true);
        }
      }
      _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));
          if (globFilter && !globFilter(path))
            return;
          const parent = sysPath.dirname(path);
          const item = sysPath.basename(path);
          const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat(path);
              } catch (error) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
        this.fsw._emitReady();
        return closer;
      }
      async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path.replace(linkTarget, linkPath);
            } else if (path !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path);
            }
            return transform(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        if (isDir)
          this.fsw._getWatchedDir(pp);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
      initWatch(realPath, path, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
        this.fsw._addPathCloser(path, closer);
      }
      async _addToFsEvents(path, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, __spreadValues({
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry)
            }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry))
                return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform === FUNCTION_TYPE) {
            this.initWatch(void 0, path, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e2) {
            }
            this.initWatch(realPath, path, wh, processPath);
          }
        }
      }
    };
    module2.exports = FsEventsHandler;
    module2.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var { EventEmitter } = (init_events(), __toCommonJS(events_exports));
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var sysPath = (init_path(), __toCommonJS(path_exports));
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows,
      isMacos,
      isIBMi
    } = require_constants2();
    var stat = promisify(fs.stat);
    var readdir = promisify(fs.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str2 = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str2.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str2.match(DOUBLE_SLASH_RE)) {
        str2 = str2.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str2 = SLASH + str2;
      }
      return str2;
    };
    var normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
      if (typeof path !== STRING_TYPE)
        return path;
      return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    };
    var getAbsolutePath = (path, cwd) => {
      if (sysPath.isAbsolute(path)) {
        return path;
      }
      if (path.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path.slice(1));
      }
      return sysPath.join(cwd, path);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path;
        if (path === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
        expandedPath.forEach((path2) => {
          parts.push(sysPath.relative(this.watchPath, path2).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i2) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i2] || anymatch(part, entryParts[0][i2], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter {
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path) => {
            const absPath = getAbsolutePath(path, cwd);
            if (disableGlobbing || !isGlob(path)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path) => {
          if (path.startsWith(BANG)) {
            this._ignoredPaths.add(path.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path);
          this._ignoredPaths.delete(path + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(paths.map(async (path) => {
            const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
            if (res)
              this._emitReady();
            return res;
          })).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path) => {
          if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
            if (cwd)
              path = sysPath.join(cwd, path);
            path = sysPath.resolve(path);
          }
          this._closePath(path);
          this._ignoredPaths.add(path);
          if (this._watched.has(path)) {
            this._ignoredPaths.add(path + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      async _emit(event, path, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows)
          path = sysPath.normalize(path);
        if (opts.cwd)
          path = sysPath.relative(opts.cwd, path);
        const args = [event, path];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path2) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path2);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path);
          const count = item ? item.count : 0;
          action.delete(path);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      _awaitWriteFinish(path, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
          fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat) => {
          fs.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
            }
          });
        };
        if (!this._pendingWrites.has(path)) {
          this._pendingWrites.set(path, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path2) => typeof path2 === STRING_TYPE && !isGlob(path2)).map((path2) => path2 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path, stats]);
      }
      _isntIgnored(path, stat2) {
        return !this._isIgnored(path, stat2);
      }
      _getWatchHelpers(path, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path, watchPath, follow, this);
      }
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      _remove(directory, item, isDirectory) {
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        if (!this._throttle("remove", path, 100))
          return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path))
          this._emit(eventName, path);
        if (!this.options.useFsEvents) {
          this._closePath(path);
        }
      }
      _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
      }
      _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path);
      }
      _addPathCloser(path, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path);
        if (!list) {
          list = [];
          this._closers.set(path, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options2 = __spreadValues({ type: EV_ALL, alwaysStat: true, lstat: true }, opts);
        let stream = readdirp(root, options2);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports2.FSWatcher = FSWatcher;
    var watch = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    exports2.watch = watch;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/handlePageAdd.js
var require_handlePageAdd = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/handlePageAdd.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.handlePageAdd = void 0;
    var core_1 = require_lib4();
    var handlePageAdd = async (app, filePath) => {
      const pageIndex = app.pages.findIndex((page2) => page2.filePath === filePath);
      if (pageIndex !== -1) {
        return null;
      }
      const page = await (0, core_1.createPage)(app, {
        filePath
      });
      app.pages.push(page);
      await (0, core_1.preparePageComponent)(app, page);
      await (0, core_1.preparePageData)(app, page);
      await (0, core_1.preparePagesComponents)(app);
      await (0, core_1.preparePagesData)(app);
      await (0, core_1.preparePagesRoutes)(app);
      return page;
    };
    exports2.handlePageAdd = handlePageAdd;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/handlePageChange.js
var require_handlePageChange = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/handlePageChange.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.handlePageChange = void 0;
    var core_1 = require_lib4();
    var handlePageChange = async (app, filePath) => {
      const pageIndex = app.pages.findIndex((page) => page.filePath === filePath);
      if (pageIndex === -1) {
        return null;
      }
      const pageOld = app.pages[pageIndex];
      const pageNew = await (0, core_1.createPage)(app, {
        filePath
      });
      app.pages.splice(pageIndex, 1, pageNew);
      await (0, core_1.preparePageComponent)(app, pageNew);
      await (0, core_1.preparePageData)(app, pageNew);
      const isPathChanged = pageOld.path !== pageNew.path;
      const isRouteMetaChanged = JSON.stringify(pageOld.routeMeta) !== JSON.stringify(pageNew.routeMeta);
      if (isPathChanged) {
        await (0, core_1.preparePagesComponents)(app);
        await (0, core_1.preparePagesData)(app);
      }
      if (isPathChanged || isRouteMetaChanged) {
        await (0, core_1.preparePagesRoutes)(app);
      }
      return [pageOld, pageNew];
    };
    exports2.handlePageChange = handlePageChange;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/handlePageUnlink.js
var require_handlePageUnlink = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/handlePageUnlink.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.handlePageUnlink = void 0;
    var core_1 = require_lib4();
    var handlePageUnlink = async (app, filePath) => {
      const pageIndex = app.pages.findIndex((page2) => page2.filePath === filePath);
      if (pageIndex === -1) {
        return null;
      }
      const page = app.pages[pageIndex];
      app.pages.splice(pageIndex, 1);
      await (0, core_1.preparePagesComponents)(app);
      await (0, core_1.preparePagesData)(app);
      await (0, core_1.preparePagesRoutes)(app);
      return page;
    };
    exports2.handlePageUnlink = handlePageUnlink;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/pageDepsHelper.js
var require_pageDepsHelper = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/pageDepsHelper.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPageDepsHelper = void 0;
    var createPageDepsHelper = () => {
      const store = /* @__PURE__ */ new Map();
      return {
        add: ({ deps, filePathRelative }) => {
          const depsAdded = [];
          if (filePathRelative) {
            deps.forEach((item) => {
              var _a;
              if (!store.has(item)) {
                store.set(item, /* @__PURE__ */ new Set());
                depsAdded.push(item);
              }
              (_a = store.get(item)) == null ? void 0 : _a.add(filePathRelative);
            });
          }
          return depsAdded;
        },
        remove: ({ deps, filePathRelative }) => {
          const depsRemoved = [];
          if (filePathRelative) {
            deps.forEach((item) => {
              const pagePathsSet = store.get(item);
              pagePathsSet == null ? void 0 : pagePathsSet.delete(filePathRelative);
              if ((pagePathsSet == null ? void 0 : pagePathsSet.size) === 0) {
                store.delete(item);
                depsRemoved.push(item);
              }
            });
          }
          return depsRemoved;
        },
        get: (dep) => {
          const pagePathsSet = store.get(dep);
          return pagePathsSet ? [...pagePathsSet] : [];
        }
      };
    };
    exports2.createPageDepsHelper = createPageDepsHelper;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/watchPageFiles.js
var require_watchPageFiles = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/watchPageFiles.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchPageFiles = void 0;
    var utils_1 = require_lib();
    var chokidar = require_chokidar();
    var handlePageAdd_1 = require_handlePageAdd();
    var handlePageChange_1 = require_handlePageChange();
    var handlePageUnlink_1 = require_handlePageUnlink();
    var pageDepsHelper_1 = require_pageDepsHelper();
    var watchPageFiles = (app) => {
      const depsWatcher = chokidar.watch([], {
        disableGlobbing: true,
        ignoreInitial: true
      });
      const depsHelper = (0, pageDepsHelper_1.createPageDepsHelper)();
      const addDeps = (page) => {
        const depsToAdd = depsHelper.add(page);
        depsWatcher.add(depsToAdd);
      };
      const removeDeps = (page) => {
        const depsToRemove = depsHelper.remove(page);
        depsWatcher.unwatch(depsToRemove);
      };
      const depsListener = async (dep) => {
        const pagePaths = depsHelper.get(dep);
        if (!pagePaths)
          return;
        for (const filePathRelative of pagePaths) {
          utils_1.logger.info(`dependency of page ${utils_1.chalk.magenta(filePathRelative)} is modified`);
          await (0, handlePageChange_1.handlePageChange)(app, app.dir.source(filePathRelative));
        }
      };
      depsWatcher.on("add", depsListener);
      depsWatcher.on("change", depsListener);
      depsWatcher.on("unlink", depsListener);
      app.pages.forEach((page) => addDeps(page));
      const pagesWatcher = chokidar.watch(app.options.pagePatterns, {
        cwd: app.dir.source(),
        ignoreInitial: true
      });
      pagesWatcher.on("add", async (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is created`);
        const page = await (0, handlePageAdd_1.handlePageAdd)(app, app.dir.source(filePathRelative));
        if (page === null)
          return;
        addDeps(page);
      });
      pagesWatcher.on("change", async (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is modified`);
        const result = await (0, handlePageChange_1.handlePageChange)(app, app.dir.source(filePathRelative));
        if (result === null)
          return;
        const [pageOld, pageNew] = result;
        removeDeps(pageOld);
        addDeps(pageNew);
      });
      pagesWatcher.on("unlink", async (filePathRelative) => {
        utils_1.logger.info(`page ${utils_1.chalk.magenta(filePathRelative)} is removed`);
        const page = await (0, handlePageUnlink_1.handlePageUnlink)(app, app.dir.source(filePathRelative));
        if (page === null)
          return;
        removeDeps(page);
      });
      return [pagesWatcher, depsWatcher];
    };
    exports2.watchPageFiles = watchPageFiles;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/watchUserConfigFile.js
var require_watchUserConfigFile = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/watchUserConfigFile.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchUserConfigFile = void 0;
    var utils_1 = require_lib();
    var chokidar = require_chokidar();
    var watchUserConfigFile = ({ userConfigPath, userConfigDeps, restart }) => {
      const cwd = process.cwd();
      const configWatcher = chokidar.watch(userConfigPath, {
        cwd,
        ignoreInitial: true
      });
      configWatcher.on("change", (configFile) => {
        utils_1.logger.info(`config ${utils_1.chalk.magenta(configFile)} is modified`);
        restart();
      });
      const depsWatcher = chokidar.watch(userConfigDeps, {
        cwd,
        ignoreInitial: true
      });
      depsWatcher.on("change", (depFile) => {
        utils_1.logger.info(`config dependency ${utils_1.chalk.magenta(depFile)} is modified`);
        restart();
      });
      return [configWatcher, depsWatcher];
    };
    exports2.watchUserConfigFile = watchUserConfigFile;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/createDev.js
var require_createDev = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/createDev.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDev = void 0;
    var core_1 = require_lib4();
    var utils_1 = require_lib();
    var config_1 = require_config();
    var utils_2 = require_utils5();
    var resolveDevUserConfig_1 = require_resolveDevUserConfig();
    var watchPageFiles_1 = require_watchPageFiles();
    var watchUserConfigFile_1 = require_watchUserConfigFile();
    var log = (0, utils_1.debug)("vuepress:cli/dev");
    var createDev = (defaultAppConfig) => {
      const dev = async (sourceDir = ".", commandOptions = {}) => {
        log(`commandOptions:`, commandOptions);
        if ("development" === void 0) {
          "development" = "development";
        }
        const cliAppConfig = (0, utils_2.resolveCliAppConfig)(sourceDir, commandOptions);
        const userConfigPath = commandOptions.config ? (0, config_1.resolveUserConfigPath)(commandOptions.config) : (0, config_1.resolveUserConfigConventionalPath)(cliAppConfig.source);
        log(`userConfigPath:`, userConfigPath);
        const { userConfig, userConfigDeps } = await (0, resolveDevUserConfig_1.resolveDevUserConfig)(userConfigPath);
        const appConfig = (0, utils_2.resolveAppConfig)({
          defaultAppConfig,
          cliAppConfig,
          userConfig
        });
        if (appConfig === null) {
          return;
        }
        const app = (0, core_1.createDevApp)(appConfig);
        app.use((0, config_1.transformUserConfigToPlugin)(userConfig, cliAppConfig.source));
        if (commandOptions.cleanTemp === true) {
          utils_1.logger.info("Cleaning temp...");
          await utils_1.fs.remove(app.dir.temp());
        }
        if (commandOptions.cleanCache === true) {
          utils_1.logger.info("Cleaning cache...");
          await utils_1.fs.remove(app.dir.cache());
        }
        utils_1.logger.info("Initializing VuePress and preparing data...");
        await app.init();
        await app.prepare();
        const close = await app.dev();
        if (commandOptions.watch === false) {
          return;
        }
        const watchers = [];
        const restart = async () => {
          await Promise.all([
            ...watchers.map((item) => item.close()),
            close()
          ]);
          await dev(sourceDir, __spreadProps(__spreadValues({}, commandOptions), {
            cleanCache: false,
            cleanTemp: false
          }));
          utils_1.logger.tip(`dev server has restarted, please refresh your browser`);
        };
        watchers.push(...(0, watchPageFiles_1.watchPageFiles)(app));
        if (userConfigPath) {
          watchers.push(...(0, watchUserConfigFile_1.watchUserConfigFile)({
            userConfigPath,
            userConfigDeps,
            restart
          }));
        }
        await app.pluginApi.hooks.onWatched.process(app, watchers, restart);
      };
      return dev;
    };
    exports2.createDev = createDev;
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/types.js
var require_types6 = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/types.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@vuepress/cli/lib/commands/dev/index.js
var require_dev = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/dev/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_createDev(), exports2);
    __exportStar(require_handlePageAdd(), exports2);
    __exportStar(require_handlePageChange(), exports2);
    __exportStar(require_handlePageUnlink(), exports2);
    __exportStar(require_resolveDevUserConfig(), exports2);
    __exportStar(require_types6(), exports2);
    __exportStar(require_watchPageFiles(), exports2);
    __exportStar(require_watchUserConfigFile(), exports2);
  }
});

// node_modules/envinfo/dist/envinfo.js
var require_envinfo = __commonJS({
  "node_modules/envinfo/dist/envinfo.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    module2.exports = function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var o2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(o2.exports, o2, o2.exports, n2), o2.l = true, o2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && typeof e3 == "object" && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && typeof e3 != "string")
          for (var o2 in e3)
            n2.d(r2, o2, function(t4) {
              return e3[t4];
            }.bind(null, o2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "", n2(n2.s = 78);
    }([function(e2, t2) {
      e2.exports = (init_path(), __toCommonJS(path_exports));
    }, function(e2, t2, n2) {
      "use strict";
      n2(22), n2(101), n2(21), n2(103), n2(114), n2(16), n2(27), n2(74), n2(116), n2(2);
      var r2 = n2(0), o2 = n2(5), i2 = n2(17), s2 = n2(49), a2 = n2(76), c2 = n2(45), u2 = n2(121), l2 = function(e3) {
        var t3 = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).unify, n3 = t3 !== void 0 && t3;
        return new Promise(function(t4) {
          s2.exec(e3, { stdio: [0, "pipe", "ignore"] }, function(e4, r3, o3) {
            var i3 = "";
            i3 = n3 ? r3.toString() + o3.toString() : r3.toString(), t4((e4 ? "" : i3).trim());
          });
        });
      }, f2 = function(e3) {
        var t3 = Object.values(Array.prototype.slice.call(arguments).slice(1));
        (process.env.ENVINFO_DEBUG || "").toLowerCase() === e3 && console.log(e3, JSON.stringify(t3));
      }, p = function(e3) {
        return new Promise(function(t3) {
          o2.readFile(e3, "utf8", function(e4, n3) {
            return t3(n3 || null);
          });
        });
      }, h = function(e3) {
        return p(e3).then(function(e4) {
          return e4 ? JSON.parse(e4) : null;
        });
      }, d2 = /\d+\.[\d+|.]+/g, m = function(e3) {
        f2("trace", "findDarwinApplication", e3);
        var t3 = `mdfind "kMDItemCFBundleIdentifier=='${e3}'"`;
        return f2("trace", t3), l2(t3).then(function(e4) {
          return e4.replace(/(\s)/g, "\\ ");
        });
      }, g = function(e3, t3) {
        var n3 = (t3 || ["CFBundleShortVersionString"]).map(function(e4) {
          return "-c Print:" + e4;
        });
        return ["/usr/libexec/PlistBuddy"].concat(n3).concat([e3]).join(" ");
      }, v = function(e3, t3) {
        for (var n3 = [], r3 = null; (r3 = e3.exec(t3)) !== null; )
          n3.push(r3);
        return n3;
      };
      e2.exports = { run: l2, log: f2, fileExists: function(e3) {
        return new Promise(function(t3) {
          o2.stat(e3, function(n3) {
            return t3(n3 ? null : e3);
          });
        });
      }, readFile: p, requireJson: h, versionRegex: d2, findDarwinApplication: m, generatePlistBuddyCommand: g, matchAll: v, parseSDKManagerOutput: function(e3) {
        var t3 = e3.split("Available")[0];
        return { apiLevels: v(u2.androidAPILevels, t3).map(function(e4) {
          return e4[1];
        }), buildTools: v(u2.androidBuildTools, t3).map(function(e4) {
          return e4[1];
        }), systemImages: v(u2.androidSystemImages, t3).map(function(e4) {
          return e4[1].split("|").map(function(e5) {
            return e5.trim();
          });
        }).map(function(e4) {
          return e4[0].split(";")[0] + " | " + e4[2].split(" System Image")[0];
        }) };
      }, isLinux: process.platform === "linux", isMacOS: process.platform === "darwin", NA: "N/A", NotFound: "Not Found", isWindows: process.platform.startsWith("win"), isObject: function(e3) {
        return typeof e3 == "object" && !Array.isArray(e3);
      }, noop: function(e3) {
        return e3;
      }, pipe: function(e3) {
        return function(t3) {
          return e3.reduce(function(e4, t4) {
            return t4(e4);
          }, t3);
        };
      }, browserBundleIdentifiers: { "Brave Browser": "com.brave.Browser", Chrome: "com.google.Chrome", "Chrome Canary": "com.google.Chrome.canary", Firefox: "org.mozilla.firefox", "Firefox Developer Edition": "org.mozilla.firefoxdeveloperedition", "Firefox Nightly": "org.mozilla.nightly", "Microsoft Edge": "com.microsoft.edgemac", Safari: "com.apple.Safari", "Safari Technology Preview": "com.apple.SafariTechnologyPreview" }, ideBundleIdentifiers: { Atom: "com.github.atom", IntelliJ: "com.jetbrains.intellij", PhpStorm: "com.jetbrains.PhpStorm", "Sublime Text": "com.sublimetext.3", WebStorm: "com.jetbrains.WebStorm" }, runSync: function(e3) {
        return (s2.execSync(e3, { stdio: [0, "pipe", "ignore"] }).toString() || "").trim();
      }, which: function(e3) {
        return new Promise(function(t3) {
          return a2(e3, function(e4, n3) {
            return t3(n3);
          });
        });
      }, getDarwinApplicationVersion: function(e3) {
        var t3;
        return f2("trace", "getDarwinApplicationVersion", e3), t3 = process.platform !== "darwin" ? "N/A" : m(e3).then(function(e4) {
          return l2(g(r2.join(e4, "Contents", "Info.plist"), ["CFBundleShortVersionString"]));
        }), Promise.resolve(t3);
      }, uniq: function(e3) {
        return Array.from(new Set(e3));
      }, toReadableBytes: function(e3) {
        var t3 = Math.floor(Math.log(e3) / Math.log(1024));
        return e3 ? (e3 / Math.pow(1024, t3)).toFixed(2) + " " + ["B", "KB", "MB", "GB", "TB", "PB"][t3] : "0 Bytes";
      }, omit: function(e3, t3) {
        return Object.keys(e3).filter(function(e4) {
          return t3.indexOf(e4) < 0;
        }).reduce(function(t4, n3) {
          return Object.assign(t4, { [n3]: e3[n3] });
        }, {});
      }, pick: function(e3, t3) {
        return Object.keys(e3).filter(function(e4) {
          return t3.indexOf(e4) >= 0;
        }).reduce(function(t4, n3) {
          return Object.assign(t4, { [n3]: e3[n3] });
        }, {});
      }, getPackageJsonByName: function(e3) {
        return h(r2.join(process.cwd(), "node_modules", e3, "package.json"));
      }, getPackageJsonByPath: function(e3) {
        return h(r2.join(process.cwd(), e3));
      }, getPackageJsonByFullPath: function(e3) {
        return f2("trace", "getPackageJsonByFullPath", e3), h(e3);
      }, getAllPackageJsonPaths: function(e3) {
        return f2("trace", "getAllPackageJsonPaths", e3), new Promise(function(t3) {
          var n3 = function(e4, n4) {
            return t3(n4.map(r2.normalize) || []);
          };
          return c2(e3 ? r2.join("node_modules", e3, "package.json") : r2.join("node_modules", "**", "package.json"), n3);
        });
      }, sortObject: function(e3) {
        return Object.keys(e3).sort().reduce(function(t3, n3) {
          return t3[n3] = e3[n3], t3;
        }, {});
      }, findVersion: function(e3, t3, n3) {
        f2("trace", "findVersion", e3, t3, n3);
        var r3 = n3 || 0, o3 = t3 || d2, i3 = e3.match(o3);
        return i3 ? i3[r3] : e3;
      }, condensePath: function(e3) {
        return (e3 || "").replace(i2.homedir(), "~");
      }, determineFound: function(e3, t3, n3) {
        return f2("trace", "determineFound", e3, t3, n3), t3 === "N/A" ? Promise.resolve([e3, "N/A"]) : t3 && Object.keys(t3).length !== 0 ? n3 ? Promise.resolve([e3, t3, n3]) : Promise.resolve([e3, t3]) : Promise.resolve([e3, "Not Found"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      var r2, o2, i2, s2, a2 = n2(36), c2 = n2(4), u2 = n2(12), l2 = n2(56), f2 = n2(8), p = n2(6), h = n2(19), d2 = n2(37), m = n2(38), g = n2(81), v = n2(60).set, y = n2(83)(), b2 = n2(62), w = n2(84), x = n2(85), S = n2(86), P = c2.TypeError, O = c2.process, j = O && O.versions, E = j && j.v8 || "", I = c2.Promise, _ = l2(O) == "process", A = function() {
      }, k = o2 = b2.f, N = !!function() {
        try {
          var e3 = I.resolve(1), t3 = (e3.constructor = {})[n2(3)("species")] = function(e4) {
            e4(A, A);
          };
          return (_ || typeof PromiseRejectionEvent == "function") && e3.then(A) instanceof t3 && E.indexOf("6.6") !== 0 && x.indexOf("Chrome/66") === -1;
        } catch (e4) {
        }
      }(), F = function(e3) {
        var t3;
        return !(!p(e3) || typeof (t3 = e3.then) != "function") && t3;
      }, C = function(e3, t3) {
        if (!e3._n) {
          e3._n = true;
          var n3 = e3._c;
          y(function() {
            for (var r3 = e3._v, o3 = e3._s == 1, i3 = 0, s3 = function(t4) {
              var n4, i4, s4, a3 = o3 ? t4.ok : t4.fail, c3 = t4.resolve, u3 = t4.reject, l3 = t4.domain;
              try {
                a3 ? (o3 || (e3._h == 2 && V(e3), e3._h = 1), a3 === true ? n4 = r3 : (l3 && l3.enter(), n4 = a3(r3), l3 && (l3.exit(), s4 = true)), n4 === t4.promise ? u3(P("Promise-chain cycle")) : (i4 = F(n4)) ? i4.call(n4, c3, u3) : c3(n4)) : u3(r3);
              } catch (e4) {
                l3 && !s4 && l3.exit(), u3(e4);
              }
            }; n3.length > i3; )
              s3(n3[i3++]);
            e3._c = [], e3._n = false, t3 && !e3._h && M(e3);
          });
        }
      }, M = function(e3) {
        v.call(c2, function() {
          var t3, n3, r3, o3 = e3._v, i3 = T(e3);
          if (i3 && (t3 = w(function() {
            _ ? O.emit("unhandledRejection", o3, e3) : (n3 = c2.onunhandledrejection) ? n3({ promise: e3, reason: o3 }) : (r3 = c2.console) && r3.error && r3.error("Unhandled promise rejection", o3);
          }), e3._h = _ || T(e3) ? 2 : 1), e3._a = void 0, i3 && t3.e)
            throw t3.v;
        });
      }, T = function(e3) {
        return e3._h !== 1 && (e3._a || e3._c).length === 0;
      }, V = function(e3) {
        v.call(c2, function() {
          var t3;
          _ ? O.emit("rejectionHandled", e3) : (t3 = c2.onrejectionhandled) && t3({ promise: e3, reason: e3._v });
        });
      }, D = function(e3) {
        var t3 = this;
        t3._d || (t3._d = true, (t3 = t3._w || t3)._v = e3, t3._s = 2, t3._a || (t3._a = t3._c.slice()), C(t3, true));
      }, B = function(e3) {
        var t3, n3 = this;
        if (!n3._d) {
          n3._d = true, n3 = n3._w || n3;
          try {
            if (n3 === e3)
              throw P("Promise can't be resolved itself");
            (t3 = F(e3)) ? y(function() {
              var r3 = { _w: n3, _d: false };
              try {
                t3.call(e3, u2(B, r3, 1), u2(D, r3, 1));
              } catch (e4) {
                D.call(r3, e4);
              }
            }) : (n3._v = e3, n3._s = 1, C(n3, false));
          } catch (e4) {
            D.call({ _w: n3, _d: false }, e4);
          }
        }
      };
      N || (I = function(e3) {
        d2(this, I, "Promise", "_h"), h(e3), r2.call(this);
        try {
          e3(u2(B, this, 1), u2(D, this, 1));
        } catch (e4) {
          D.call(this, e4);
        }
      }, (r2 = function(e3) {
        this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
      }).prototype = n2(40)(I.prototype, { then: function(e3, t3) {
        var n3 = k(g(this, I));
        return n3.ok = typeof e3 != "function" || e3, n3.fail = typeof t3 == "function" && t3, n3.domain = _ ? O.domain : void 0, this._c.push(n3), this._a && this._a.push(n3), this._s && C(this, false), n3.promise;
      }, catch: function(e3) {
        return this.then(void 0, e3);
      } }), i2 = function() {
        var e3 = new r2();
        this.promise = e3, this.resolve = u2(B, e3, 1), this.reject = u2(D, e3, 1);
      }, b2.f = k = function(e3) {
        return e3 === I || e3 === s2 ? new i2(e3) : o2(e3);
      }), f2(f2.G + f2.W + f2.F * !N, { Promise: I }), n2(26)(I, "Promise"), n2(63)("Promise"), s2 = n2(18).Promise, f2(f2.S + f2.F * !N, "Promise", { reject: function(e3) {
        var t3 = k(this);
        return (0, t3.reject)(e3), t3.promise;
      } }), f2(f2.S + f2.F * (a2 || !N), "Promise", { resolve: function(e3) {
        return S(a2 && this === s2 ? I : this, e3);
      } }), f2(f2.S + f2.F * !(N && n2(41)(function(e3) {
        I.all(e3).catch(A);
      })), "Promise", { all: function(e3) {
        var t3 = this, n3 = k(t3), r3 = n3.resolve, o3 = n3.reject, i3 = w(function() {
          var n4 = [], i4 = 0, s3 = 1;
          m(e3, false, function(e4) {
            var a3 = i4++, c3 = false;
            n4.push(void 0), s3++, t3.resolve(e4).then(function(e5) {
              c3 || (c3 = true, n4[a3] = e5, --s3 || r3(n4));
            }, o3);
          }), --s3 || r3(n4);
        });
        return i3.e && o3(i3.v), n3.promise;
      }, race: function(e3) {
        var t3 = this, n3 = k(t3), r3 = n3.reject, o3 = w(function() {
          m(e3, false, function(e4) {
            t3.resolve(e4).then(n3.resolve, r3);
          });
        });
        return o3.e && r3(o3.v), n3.promise;
      } });
    }, function(e2, t2, n2) {
      var r2 = n2(55)("wks"), o2 = n2(24), i2 = n2(4).Symbol, s2 = typeof i2 == "function";
      (e2.exports = function(e3) {
        return r2[e3] || (r2[e3] = s2 && i2[e3] || (s2 ? i2 : o2)("Symbol." + e3));
      }).store = r2;
    }, function(e2, t2) {
      var n2 = e2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = n2);
    }, function(e2, t2) {
      e2.exports = (init_fs(), __toCommonJS(fs_exports));
    }, function(e2, t2) {
      e2.exports = function(e3) {
        return typeof e3 == "object" ? e3 !== null : typeof e3 == "function";
      };
    }, function(e2, t2, n2) {
      var r2 = n2(6);
      e2.exports = function(e3) {
        if (!r2(e3))
          throw TypeError(e3 + " is not an object!");
        return e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4), o2 = n2(18), i2 = n2(13), s2 = n2(14), a2 = n2(12), c2 = function(e3, t3, n3) {
        var u2, l2, f2, p, h = e3 & c2.F, d2 = e3 & c2.G, m = e3 & c2.S, g = e3 & c2.P, v = e3 & c2.B, y = d2 ? r2 : m ? r2[t3] || (r2[t3] = {}) : (r2[t3] || {}).prototype, b2 = d2 ? o2 : o2[t3] || (o2[t3] = {}), w = b2.prototype || (b2.prototype = {});
        for (u2 in d2 && (n3 = t3), n3)
          f2 = ((l2 = !h && y && y[u2] !== void 0) ? y : n3)[u2], p = v && l2 ? a2(f2, r2) : g && typeof f2 == "function" ? a2(Function.call, f2) : f2, y && s2(y, u2, f2, e3 & c2.U), b2[u2] != f2 && i2(b2, u2, p), g && w[u2] != f2 && (w[u2] = f2);
      };
      r2.core = o2, c2.F = 1, c2.G = 2, c2.S = 4, c2.P = 8, c2.B = 16, c2.W = 32, c2.U = 64, c2.R = 128, e2.exports = c2;
    }, function(e2, t2, n2) {
      e2.exports = !n2(10)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, function(e2, t2) {
      e2.exports = function(e3) {
        try {
          return !!e3();
        } catch (e4) {
          return true;
        }
      };
    }, function(e2, t2, n2) {
      var r2 = n2(7), o2 = n2(50), i2 = n2(51), s2 = Object.defineProperty;
      t2.f = n2(9) ? Object.defineProperty : function(e3, t3, n3) {
        if (r2(e3), t3 = i2(t3, true), r2(n3), o2)
          try {
            return s2(e3, t3, n3);
          } catch (e4) {
          }
        if ("get" in n3 || "set" in n3)
          throw TypeError("Accessors not supported!");
        return "value" in n3 && (e3[t3] = n3.value), e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(19);
      e2.exports = function(e3, t3, n3) {
        if (r2(e3), t3 === void 0)
          return e3;
        switch (n3) {
          case 1:
            return function(n4) {
              return e3.call(t3, n4);
            };
          case 2:
            return function(n4, r3) {
              return e3.call(t3, n4, r3);
            };
          case 3:
            return function(n4, r3, o2) {
              return e3.call(t3, n4, r3, o2);
            };
        }
        return function() {
          return e3.apply(t3, arguments);
        };
      };
    }, function(e2, t2, n2) {
      var r2 = n2(11), o2 = n2(23);
      e2.exports = n2(9) ? function(e3, t3, n3) {
        return r2.f(e3, t3, o2(1, n3));
      } : function(e3, t3, n3) {
        return e3[t3] = n3, e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4), o2 = n2(13), i2 = n2(15), s2 = n2(24)("src"), a2 = Function.toString, c2 = ("" + a2).split("toString");
      n2(18).inspectSource = function(e3) {
        return a2.call(e3);
      }, (e2.exports = function(e3, t3, n3, a3) {
        var u2 = typeof n3 == "function";
        u2 && (i2(n3, "name") || o2(n3, "name", t3)), e3[t3] !== n3 && (u2 && (i2(n3, s2) || o2(n3, s2, e3[t3] ? "" + e3[t3] : c2.join(String(t3)))), e3 === r2 ? e3[t3] = n3 : a3 ? e3[t3] ? e3[t3] = n3 : o2(e3, t3, n3) : (delete e3[t3], o2(e3, t3, n3)));
      })(Function.prototype, "toString", function() {
        return typeof this == "function" && this[s2] || a2.call(this);
      });
    }, function(e2, t2) {
      var n2 = {}.hasOwnProperty;
      e2.exports = function(e3, t3) {
        return n2.call(e3, t3);
      };
    }, function(e2, t2, n2) {
      n2(28)("split", 2, function(e3, t3, r2) {
        "use strict";
        var o2 = n2(92), i2 = r2, s2 = [].push;
        if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
          var a2 = /()??/.exec("")[1] === void 0;
          r2 = function(e4, t4) {
            var n3 = String(this);
            if (e4 === void 0 && t4 === 0)
              return [];
            if (!o2(e4))
              return i2.call(n3, e4, t4);
            var r3, c2, u2, l2, f2, p = [], h = (e4.ignoreCase ? "i" : "") + (e4.multiline ? "m" : "") + (e4.unicode ? "u" : "") + (e4.sticky ? "y" : ""), d2 = 0, m = t4 === void 0 ? 4294967295 : t4 >>> 0, g = new RegExp(e4.source, h + "g");
            for (a2 || (r3 = new RegExp("^" + g.source + "$(?!\\s)", h)); (c2 = g.exec(n3)) && !((u2 = c2.index + c2[0].length) > d2 && (p.push(n3.slice(d2, c2.index)), !a2 && c2.length > 1 && c2[0].replace(r3, function() {
              for (f2 = 1; f2 < arguments.length - 2; f2++)
                arguments[f2] === void 0 && (c2[f2] = void 0);
            }), c2.length > 1 && c2.index < n3.length && s2.apply(p, c2.slice(1)), l2 = c2[0].length, d2 = u2, p.length >= m)); )
              g.lastIndex === c2.index && g.lastIndex++;
            return d2 === n3.length ? !l2 && g.test("") || p.push("") : p.push(n3.slice(d2)), p.length > m ? p.slice(0, m) : p;
          };
        } else
          "0".split(void 0, 0).length && (r2 = function(e4, t4) {
            return e4 === void 0 && t4 === 0 ? [] : i2.call(this, e4, t4);
          });
        return [function(n3, o3) {
          var i3 = e3(this), s3 = n3 == null ? void 0 : n3[t3];
          return s3 !== void 0 ? s3.call(n3, i3, o3) : r2.call(String(i3), n3, o3);
        }, r2];
      });
    }, function(e2, t2) {
      e2.exports = (init_os(), __toCommonJS(os_exports));
    }, function(e2, t2) {
      var n2 = e2.exports = { version: "2.5.7" };
      typeof __e == "number" && (__e = n2);
    }, function(e2, t2) {
      e2.exports = function(e3) {
        if (typeof e3 != "function")
          throw TypeError(e3 + " is not a function!");
        return e3;
      };
    }, function(e2, t2) {
      var n2 = {}.toString;
      e2.exports = function(e3) {
        return n2.call(e3).slice(8, -1);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(8);
      r2(r2.S + r2.F, "Object", { assign: n2(88) });
    }, function(e2, t2, n2) {
      n2(28)("match", 1, function(e3, t3, n3) {
        return [function(n4) {
          "use strict";
          var r2 = e3(this), o2 = n4 == null ? void 0 : n4[t3];
          return o2 !== void 0 ? o2.call(n4, r2) : new RegExp(n4)[t3](String(r2));
        }, n3];
      });
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
      };
    }, function(e2, t2) {
      var n2 = 0, r2 = Math.random();
      e2.exports = function(e3) {
        return "Symbol(".concat(e3 === void 0 ? "" : e3, ")_", (++n2 + r2).toString(36));
      };
    }, function(e2, t2, n2) {
      var r2 = n2(53), o2 = n2(34);
      e2.exports = function(e3) {
        return r2(o2(e3));
      };
    }, function(e2, t2, n2) {
      var r2 = n2(11).f, o2 = n2(15), i2 = n2(3)("toStringTag");
      e2.exports = function(e3, t3, n3) {
        e3 && !o2(e3 = n3 ? e3 : e3.prototype, i2) && r2(e3, i2, { configurable: true, value: t3 });
      };
    }, function(e2, t2, n2) {
      n2(28)("replace", 2, function(e3, t3, n3) {
        return [function(r2, o2) {
          "use strict";
          var i2 = e3(this), s2 = r2 == null ? void 0 : r2[t3];
          return s2 !== void 0 ? s2.call(r2, i2, o2) : n3.call(String(i2), r2, o2);
        }, n3];
      });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(13), o2 = n2(14), i2 = n2(10), s2 = n2(34), a2 = n2(3);
      e2.exports = function(e3, t3, n3) {
        var c2 = a2(e3), u2 = n3(s2, c2, ""[e3]), l2 = u2[0], f2 = u2[1];
        i2(function() {
          var t4 = {};
          return t4[c2] = function() {
            return 7;
          }, ""[e3](t4) != 7;
        }) && (o2(String.prototype, e3, l2), r2(RegExp.prototype, c2, t3 == 2 ? function(e4, t4) {
          return f2.call(e4, this, t4);
        } : function(e4) {
          return f2.call(e4, this);
        }));
      };
    }, function(e2, t2, n2) {
      var r2 = n2(34);
      e2.exports = function(e3) {
        return Object(r2(e3));
      };
    }, function(e2, t2) {
      e2.exports = (init_util(), __toCommonJS(util_exports));
    }, function(e2, t2, n2) {
      var r2 = n2(70);
      function o2(e3) {
        var t3 = function() {
          return t3.called ? t3.value : (t3.called = true, t3.value = e3.apply(this, arguments));
        };
        return t3.called = false, t3;
      }
      function i2(e3) {
        var t3 = function() {
          if (t3.called)
            throw new Error(t3.onceError);
          return t3.called = true, t3.value = e3.apply(this, arguments);
        }, n3 = e3.name || "Function wrapped with `once`";
        return t3.onceError = n3 + " shouldn't be called more than once", t3.called = false, t3;
      }
      e2.exports = r2(o2), e2.exports.strict = r2(i2), o2.proto = o2(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return o2(this);
        }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return i2(this);
        }, configurable: true });
      });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(8), o2 = n2(52)(true);
      r2(r2.P, "Array", { includes: function(e3) {
        return o2(this, e3, arguments.length > 1 ? arguments[1] : void 0);
      } }), n2(80)("includes");
    }, function(e2, t2, n2) {
      var r2 = n2(6), o2 = n2(4).document, i2 = r2(o2) && r2(o2.createElement);
      e2.exports = function(e3) {
        return i2 ? o2.createElement(e3) : {};
      };
    }, function(e2, t2) {
      e2.exports = function(e3) {
        if (e3 == null)
          throw TypeError("Can't call method on  " + e3);
        return e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(54), o2 = Math.min;
      e2.exports = function(e3) {
        return e3 > 0 ? o2(r2(e3), 9007199254740991) : 0;
      };
    }, function(e2, t2) {
      e2.exports = false;
    }, function(e2, t2) {
      e2.exports = function(e3, t3, n2, r2) {
        if (!(e3 instanceof t3) || r2 !== void 0 && r2 in e3)
          throw TypeError(n2 + ": incorrect invocation!");
        return e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(12), o2 = n2(57), i2 = n2(58), s2 = n2(7), a2 = n2(35), c2 = n2(59), u2 = {}, l2 = {};
      (t2 = e2.exports = function(e3, t3, n3, f2, p) {
        var h, d2, m, g, v = p ? function() {
          return e3;
        } : c2(e3), y = r2(n3, f2, t3 ? 2 : 1), b2 = 0;
        if (typeof v != "function")
          throw TypeError(e3 + " is not iterable!");
        if (i2(v)) {
          for (h = a2(e3.length); h > b2; b2++)
            if ((g = t3 ? y(s2(d2 = e3[b2])[0], d2[1]) : y(e3[b2])) === u2 || g === l2)
              return g;
        } else
          for (m = v.call(e3); !(d2 = m.next()).done; )
            if ((g = o2(m, y, d2.value, t3)) === u2 || g === l2)
              return g;
      }).BREAK = u2, t2.RETURN = l2;
    }, function(e2, t2) {
      e2.exports = {};
    }, function(e2, t2, n2) {
      var r2 = n2(14);
      e2.exports = function(e3, t3, n3) {
        for (var o2 in t3)
          r2(e3, o2, t3[o2], n3);
        return e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(3)("iterator"), o2 = false;
      try {
        var i2 = [7][r2]();
        i2.return = function() {
          o2 = true;
        }, Array.from(i2, function() {
          throw 2;
        });
      } catch (e3) {
      }
      e2.exports = function(e3, t3) {
        if (!t3 && !o2)
          return false;
        var n3 = false;
        try {
          var i3 = [7], s2 = i3[r2]();
          s2.next = function() {
            return { done: n3 = true };
          }, i3[r2] = function() {
            return s2;
          }, e3(i3);
        } catch (e4) {
        }
        return n3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(87), o2 = n2(66);
      e2.exports = Object.keys || function(e3) {
        return r2(e3, o2);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(55)("keys"), o2 = n2(24);
      e2.exports = function(e3) {
        return r2[e3] || (r2[e3] = o2(e3));
      };
    }, function(e2, t2) {
      t2.f = {}.propertyIsEnumerable;
    }, function(e2, t2, n2) {
      e2.exports = b2;
      var r2 = n2(5), o2 = n2(67), i2 = n2(46), s2 = (i2.Minimatch, n2(97)), a2 = n2(68).EventEmitter, c2 = n2(0), u2 = n2(47), l2 = n2(48), f2 = n2(99), p = n2(69), h = (p.alphasort, p.alphasorti, p.setopts), d2 = p.ownProp, m = n2(100), g = (n2(30), p.childrenIgnored), v = p.isIgnored, y = n2(31);
      function b2(e3, t3, n3) {
        if (typeof t3 == "function" && (n3 = t3, t3 = {}), t3 || (t3 = {}), t3.sync) {
          if (n3)
            throw new TypeError("callback provided to sync glob");
          return f2(e3, t3);
        }
        return new x(e3, t3, n3);
      }
      b2.sync = f2;
      var w = b2.GlobSync = f2.GlobSync;
      function x(e3, t3, n3) {
        if (typeof t3 == "function" && (n3 = t3, t3 = null), t3 && t3.sync) {
          if (n3)
            throw new TypeError("callback provided to sync glob");
          return new w(e3, t3);
        }
        if (!(this instanceof x))
          return new x(e3, t3, n3);
        h(this, e3, t3), this._didRealPath = false;
        var r3 = this.minimatch.set.length;
        this.matches = new Array(r3), typeof n3 == "function" && (n3 = y(n3), this.on("error", n3), this.on("end", function(e4) {
          n3(null, e4);
        }));
        var o3 = this;
        if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = false, this.noprocess)
          return this;
        if (r3 === 0)
          return a3();
        for (var i3 = true, s3 = 0; s3 < r3; s3++)
          this._process(this.minimatch.set[s3], s3, false, a3);
        function a3() {
          --o3._processing, o3._processing <= 0 && (i3 ? process.nextTick(function() {
            o3._finish();
          }) : o3._finish());
        }
        i3 = false;
      }
      b2.glob = b2, b2.hasMagic = function(e3, t3) {
        var n3 = function(e4, t4) {
          if (t4 === null || typeof t4 != "object")
            return e4;
          for (var n4 = Object.keys(t4), r4 = n4.length; r4--; )
            e4[n4[r4]] = t4[n4[r4]];
          return e4;
        }({}, t3);
        n3.noprocess = true;
        var r3 = new x(e3, n3).minimatch.set;
        if (!e3)
          return false;
        if (r3.length > 1)
          return true;
        for (var o3 = 0; o3 < r3[0].length; o3++)
          if (typeof r3[0][o3] != "string")
            return true;
        return false;
      }, b2.Glob = x, s2(x, a2), x.prototype._finish = function() {
        if (u2(this instanceof x), !this.aborted) {
          if (this.realpath && !this._didRealpath)
            return this._realpath();
          p.finish(this), this.emit("end", this.found);
        }
      }, x.prototype._realpath = function() {
        if (!this._didRealpath) {
          this._didRealpath = true;
          var e3 = this.matches.length;
          if (e3 === 0)
            return this._finish();
          for (var t3 = this, n3 = 0; n3 < this.matches.length; n3++)
            this._realpathSet(n3, r3);
        }
        function r3() {
          --e3 == 0 && t3._finish();
        }
      }, x.prototype._realpathSet = function(e3, t3) {
        var n3 = this.matches[e3];
        if (!n3)
          return t3();
        var r3 = Object.keys(n3), i3 = this, s3 = r3.length;
        if (s3 === 0)
          return t3();
        var a3 = this.matches[e3] = /* @__PURE__ */ Object.create(null);
        r3.forEach(function(n4, r4) {
          n4 = i3._makeAbs(n4), o2.realpath(n4, i3.realpathCache, function(r5, o3) {
            r5 ? r5.syscall === "stat" ? a3[n4] = true : i3.emit("error", r5) : a3[o3] = true, --s3 == 0 && (i3.matches[e3] = a3, t3());
          });
        });
      }, x.prototype._mark = function(e3) {
        return p.mark(this, e3);
      }, x.prototype._makeAbs = function(e3) {
        return p.makeAbs(this, e3);
      }, x.prototype.abort = function() {
        this.aborted = true, this.emit("abort");
      }, x.prototype.pause = function() {
        this.paused || (this.paused = true, this.emit("pause"));
      }, x.prototype.resume = function() {
        if (this.paused) {
          if (this.emit("resume"), this.paused = false, this._emitQueue.length) {
            var e3 = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var t3 = 0; t3 < e3.length; t3++) {
              var n3 = e3[t3];
              this._emitMatch(n3[0], n3[1]);
            }
          }
          if (this._processQueue.length) {
            var r3 = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (t3 = 0; t3 < r3.length; t3++) {
              var o3 = r3[t3];
              this._processing--, this._process(o3[0], o3[1], o3[2], o3[3]);
            }
          }
        }
      }, x.prototype._process = function(e3, t3, n3, r3) {
        if (u2(this instanceof x), u2(typeof r3 == "function"), !this.aborted)
          if (this._processing++, this.paused)
            this._processQueue.push([e3, t3, n3, r3]);
          else {
            for (var o3, s3 = 0; typeof e3[s3] == "string"; )
              s3++;
            switch (s3) {
              case e3.length:
                return void this._processSimple(e3.join("/"), t3, r3);
              case 0:
                o3 = null;
                break;
              default:
                o3 = e3.slice(0, s3).join("/");
            }
            var a3, c3 = e3.slice(s3);
            o3 === null ? a3 = "." : l2(o3) || l2(e3.join("/")) ? (o3 && l2(o3) || (o3 = "/" + o3), a3 = o3) : a3 = o3;
            var f3 = this._makeAbs(a3);
            if (g(this, a3))
              return r3();
            c3[0] === i2.GLOBSTAR ? this._processGlobStar(o3, a3, f3, c3, t3, n3, r3) : this._processReaddir(o3, a3, f3, c3, t3, n3, r3);
          }
      }, x.prototype._processReaddir = function(e3, t3, n3, r3, o3, i3, s3) {
        var a3 = this;
        this._readdir(n3, i3, function(c3, u3) {
          return a3._processReaddir2(e3, t3, n3, r3, o3, i3, u3, s3);
        });
      }, x.prototype._processReaddir2 = function(e3, t3, n3, r3, o3, i3, s3, a3) {
        if (!s3)
          return a3();
        for (var u3 = r3[0], l3 = !!this.minimatch.negate, f3 = u3._glob, p2 = this.dot || f3.charAt(0) === ".", h2 = [], d3 = 0; d3 < s3.length; d3++) {
          if ((g2 = s3[d3]).charAt(0) !== "." || p2)
            (l3 && !e3 ? !g2.match(u3) : g2.match(u3)) && h2.push(g2);
        }
        var m2 = h2.length;
        if (m2 === 0)
          return a3();
        if (r3.length === 1 && !this.mark && !this.stat) {
          this.matches[o3] || (this.matches[o3] = /* @__PURE__ */ Object.create(null));
          for (d3 = 0; d3 < m2; d3++) {
            var g2 = h2[d3];
            e3 && (g2 = e3 !== "/" ? e3 + "/" + g2 : e3 + g2), g2.charAt(0) !== "/" || this.nomount || (g2 = c2.join(this.root, g2)), this._emitMatch(o3, g2);
          }
          return a3();
        }
        r3.shift();
        for (d3 = 0; d3 < m2; d3++) {
          g2 = h2[d3];
          e3 && (g2 = e3 !== "/" ? e3 + "/" + g2 : e3 + g2), this._process([g2].concat(r3), o3, i3, a3);
        }
        a3();
      }, x.prototype._emitMatch = function(e3, t3) {
        if (!this.aborted && !v(this, t3))
          if (this.paused)
            this._emitQueue.push([e3, t3]);
          else {
            var n3 = l2(t3) ? t3 : this._makeAbs(t3);
            if (this.mark && (t3 = this._mark(t3)), this.absolute && (t3 = n3), !this.matches[e3][t3]) {
              if (this.nodir) {
                var r3 = this.cache[n3];
                if (r3 === "DIR" || Array.isArray(r3))
                  return;
              }
              this.matches[e3][t3] = true;
              var o3 = this.statCache[n3];
              o3 && this.emit("stat", t3, o3), this.emit("match", t3);
            }
          }
      }, x.prototype._readdirInGlobStar = function(e3, t3) {
        if (!this.aborted) {
          if (this.follow)
            return this._readdir(e3, false, t3);
          var n3 = this, o3 = m("lstat\0" + e3, function(r3, o4) {
            if (r3 && r3.code === "ENOENT")
              return t3();
            var i3 = o4 && o4.isSymbolicLink();
            n3.symlinks[e3] = i3, i3 || !o4 || o4.isDirectory() ? n3._readdir(e3, false, t3) : (n3.cache[e3] = "FILE", t3());
          });
          o3 && r2.lstat(e3, o3);
        }
      }, x.prototype._readdir = function(e3, t3, n3) {
        if (!this.aborted && (n3 = m("readdir\0" + e3 + "\0" + t3, n3))) {
          if (t3 && !d2(this.symlinks, e3))
            return this._readdirInGlobStar(e3, n3);
          if (d2(this.cache, e3)) {
            var o3 = this.cache[e3];
            if (!o3 || o3 === "FILE")
              return n3();
            if (Array.isArray(o3))
              return n3(null, o3);
          }
          r2.readdir(e3, function(e4, t4, n4) {
            return function(r3, o4) {
              r3 ? e4._readdirError(t4, r3, n4) : e4._readdirEntries(t4, o4, n4);
            };
          }(this, e3, n3));
        }
      }, x.prototype._readdirEntries = function(e3, t3, n3) {
        if (!this.aborted) {
          if (!this.mark && !this.stat)
            for (var r3 = 0; r3 < t3.length; r3++) {
              var o3 = t3[r3];
              o3 = e3 === "/" ? e3 + o3 : e3 + "/" + o3, this.cache[o3] = true;
            }
          return this.cache[e3] = t3, n3(null, t3);
        }
      }, x.prototype._readdirError = function(e3, t3, n3) {
        if (!this.aborted) {
          switch (t3.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var r3 = this._makeAbs(e3);
              if (this.cache[r3] = "FILE", r3 === this.cwdAbs) {
                var o3 = new Error(t3.code + " invalid cwd " + this.cwd);
                o3.path = this.cwd, o3.code = t3.code, this.emit("error", o3), this.abort();
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(e3)] = false;
              break;
            default:
              this.cache[this._makeAbs(e3)] = false, this.strict && (this.emit("error", t3), this.abort()), this.silent || console.error("glob error", t3);
          }
          return n3();
        }
      }, x.prototype._processGlobStar = function(e3, t3, n3, r3, o3, i3, s3) {
        var a3 = this;
        this._readdir(n3, i3, function(c3, u3) {
          a3._processGlobStar2(e3, t3, n3, r3, o3, i3, u3, s3);
        });
      }, x.prototype._processGlobStar2 = function(e3, t3, n3, r3, o3, i3, s3, a3) {
        if (!s3)
          return a3();
        var c3 = r3.slice(1), u3 = e3 ? [e3] : [], l3 = u3.concat(c3);
        this._process(l3, o3, false, a3);
        var f3 = this.symlinks[n3], p2 = s3.length;
        if (f3 && i3)
          return a3();
        for (var h2 = 0; h2 < p2; h2++) {
          if (s3[h2].charAt(0) !== "." || this.dot) {
            var d3 = u3.concat(s3[h2], c3);
            this._process(d3, o3, true, a3);
            var m2 = u3.concat(s3[h2], r3);
            this._process(m2, o3, true, a3);
          }
        }
        a3();
      }, x.prototype._processSimple = function(e3, t3, n3) {
        var r3 = this;
        this._stat(e3, function(o3, i3) {
          r3._processSimple2(e3, t3, o3, i3, n3);
        });
      }, x.prototype._processSimple2 = function(e3, t3, n3, r3, o3) {
        if (this.matches[t3] || (this.matches[t3] = /* @__PURE__ */ Object.create(null)), !r3)
          return o3();
        if (e3 && l2(e3) && !this.nomount) {
          var i3 = /[\/\\]$/.test(e3);
          e3.charAt(0) === "/" ? e3 = c2.join(this.root, e3) : (e3 = c2.resolve(this.root, e3), i3 && (e3 += "/"));
        }
        process.platform === "win32" && (e3 = e3.replace(/\\/g, "/")), this._emitMatch(t3, e3), o3();
      }, x.prototype._stat = function(e3, t3) {
        var n3 = this._makeAbs(e3), o3 = e3.slice(-1) === "/";
        if (e3.length > this.maxLength)
          return t3();
        if (!this.stat && d2(this.cache, n3)) {
          var i3 = this.cache[n3];
          if (Array.isArray(i3) && (i3 = "DIR"), !o3 || i3 === "DIR")
            return t3(null, i3);
          if (o3 && i3 === "FILE")
            return t3();
        }
        var s3 = this.statCache[n3];
        if (s3 !== void 0) {
          if (s3 === false)
            return t3(null, s3);
          var a3 = s3.isDirectory() ? "DIR" : "FILE";
          return o3 && a3 === "FILE" ? t3() : t3(null, a3, s3);
        }
        var c3 = this, u3 = m("stat\0" + n3, function(o4, i4) {
          if (i4 && i4.isSymbolicLink())
            return r2.stat(n3, function(r3, o5) {
              r3 ? c3._stat2(e3, n3, null, i4, t3) : c3._stat2(e3, n3, r3, o5, t3);
            });
          c3._stat2(e3, n3, o4, i4, t3);
        });
        u3 && r2.lstat(n3, u3);
      }, x.prototype._stat2 = function(e3, t3, n3, r3, o3) {
        if (n3 && (n3.code === "ENOENT" || n3.code === "ENOTDIR"))
          return this.statCache[t3] = false, o3();
        var i3 = e3.slice(-1) === "/";
        if (this.statCache[t3] = r3, t3.slice(-1) === "/" && r3 && !r3.isDirectory())
          return o3(null, false, r3);
        var s3 = true;
        return r3 && (s3 = r3.isDirectory() ? "DIR" : "FILE"), this.cache[t3] = this.cache[t3] || s3, i3 && s3 === "FILE" ? o3() : o3(null, s3, r3);
      };
    }, function(e2, t2, n2) {
      e2.exports = d2, d2.Minimatch = m;
      var r2 = { sep: "/" };
      try {
        r2 = n2(0);
      } catch (e3) {
      }
      var o2 = d2.GLOBSTAR = m.GLOBSTAR = {}, i2 = n2(94), s2 = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, a2 = "[^/]", c2 = a2 + "*?", u2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", l2 = "(?:(?!(?:\\/|^)\\.).)*?", f2 = "().*{}+?[]^$\\!".split("").reduce(function(e3, t3) {
        return e3[t3] = true, e3;
      }, {});
      var p = /\/+/;
      function h(e3, t3) {
        e3 = e3 || {}, t3 = t3 || {};
        var n3 = {};
        return Object.keys(t3).forEach(function(e4) {
          n3[e4] = t3[e4];
        }), Object.keys(e3).forEach(function(t4) {
          n3[t4] = e3[t4];
        }), n3;
      }
      function d2(e3, t3, n3) {
        if (typeof t3 != "string")
          throw new TypeError("glob pattern string required");
        return n3 || (n3 = {}), !(!n3.nocomment && t3.charAt(0) === "#") && (t3.trim() === "" ? e3 === "" : new m(t3, n3).match(e3));
      }
      function m(e3, t3) {
        if (!(this instanceof m))
          return new m(e3, t3);
        if (typeof e3 != "string")
          throw new TypeError("glob pattern string required");
        t3 || (t3 = {}), e3 = e3.trim(), r2.sep !== "/" && (e3 = e3.split(r2.sep).join("/")), this.options = t3, this.set = [], this.pattern = e3, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.make();
      }
      function g(e3, t3) {
        if (t3 || (t3 = this instanceof m ? this.options : {}), (e3 = e3 === void 0 ? this.pattern : e3) === void 0)
          throw new TypeError("undefined pattern");
        return t3.nobrace || !e3.match(/\{.*\}/) ? [e3] : i2(e3);
      }
      d2.filter = function(e3, t3) {
        return t3 = t3 || {}, function(n3, r3, o3) {
          return d2(n3, e3, t3);
        };
      }, d2.defaults = function(e3) {
        if (!e3 || !Object.keys(e3).length)
          return d2;
        var t3 = d2, n3 = function(n4, r3, o3) {
          return t3.minimatch(n4, r3, h(e3, o3));
        };
        return n3.Minimatch = function(n4, r3) {
          return new t3.Minimatch(n4, h(e3, r3));
        }, n3;
      }, m.defaults = function(e3) {
        return e3 && Object.keys(e3).length ? d2.defaults(e3).Minimatch : m;
      }, m.prototype.debug = function() {
      }, m.prototype.make = function() {
        if (this._made)
          return;
        var e3 = this.pattern, t3 = this.options;
        if (!t3.nocomment && e3.charAt(0) === "#")
          return void (this.comment = true);
        if (!e3)
          return void (this.empty = true);
        this.parseNegate();
        var n3 = this.globSet = this.braceExpand();
        t3.debug && (this.debug = console.error);
        this.debug(this.pattern, n3), n3 = this.globParts = n3.map(function(e4) {
          return e4.split(p);
        }), this.debug(this.pattern, n3), n3 = n3.map(function(e4, t4, n4) {
          return e4.map(this.parse, this);
        }, this), this.debug(this.pattern, n3), n3 = n3.filter(function(e4) {
          return e4.indexOf(false) === -1;
        }), this.debug(this.pattern, n3), this.set = n3;
      }, m.prototype.parseNegate = function() {
        var e3 = this.pattern, t3 = false, n3 = this.options, r3 = 0;
        if (n3.nonegate)
          return;
        for (var o3 = 0, i3 = e3.length; o3 < i3 && e3.charAt(o3) === "!"; o3++)
          t3 = !t3, r3++;
        r3 && (this.pattern = e3.substr(r3));
        this.negate = t3;
      }, d2.braceExpand = function(e3, t3) {
        return g(e3, t3);
      }, m.prototype.braceExpand = g, m.prototype.parse = function(e3, t3) {
        if (e3.length > 65536)
          throw new TypeError("pattern is too long");
        var n3 = this.options;
        if (!n3.noglobstar && e3 === "**")
          return o2;
        if (e3 === "")
          return "";
        var r3, i3 = "", u3 = !!n3.nocase, l3 = false, p2 = [], h2 = [], d3 = false, m2 = -1, g2 = -1, y = e3.charAt(0) === "." ? "" : n3.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", b2 = this;
        function w() {
          if (r3) {
            switch (r3) {
              case "*":
                i3 += c2, u3 = true;
                break;
              case "?":
                i3 += a2, u3 = true;
                break;
              default:
                i3 += "\\" + r3;
            }
            b2.debug("clearStateChar %j %j", r3, i3), r3 = false;
          }
        }
        for (var x, S = 0, P = e3.length; S < P && (x = e3.charAt(S)); S++)
          if (this.debug("%s	%s %s %j", e3, S, i3, x), l3 && f2[x])
            i3 += "\\" + x, l3 = false;
          else
            switch (x) {
              case "/":
                return false;
              case "\\":
                w(), l3 = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                if (this.debug("%s	%s %s %j <-- stateChar", e3, S, i3, x), d3) {
                  this.debug("  in class"), x === "!" && S === g2 + 1 && (x = "^"), i3 += x;
                  continue;
                }
                b2.debug("call clearStateChar %j", r3), w(), r3 = x, n3.noext && w();
                continue;
              case "(":
                if (d3) {
                  i3 += "(";
                  continue;
                }
                if (!r3) {
                  i3 += "\\(";
                  continue;
                }
                p2.push({ type: r3, start: S - 1, reStart: i3.length, open: s2[r3].open, close: s2[r3].close }), i3 += r3 === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", r3, i3), r3 = false;
                continue;
              case ")":
                if (d3 || !p2.length) {
                  i3 += "\\)";
                  continue;
                }
                w(), u3 = true;
                var O = p2.pop();
                i3 += O.close, O.type === "!" && h2.push(O), O.reEnd = i3.length;
                continue;
              case "|":
                if (d3 || !p2.length || l3) {
                  i3 += "\\|", l3 = false;
                  continue;
                }
                w(), i3 += "|";
                continue;
              case "[":
                if (w(), d3) {
                  i3 += "\\" + x;
                  continue;
                }
                d3 = true, g2 = S, m2 = i3.length, i3 += x;
                continue;
              case "]":
                if (S === g2 + 1 || !d3) {
                  i3 += "\\" + x, l3 = false;
                  continue;
                }
                if (d3) {
                  var j = e3.substring(g2 + 1, S);
                  try {
                    RegExp("[" + j + "]");
                  } catch (e4) {
                    var E = this.parse(j, v);
                    i3 = i3.substr(0, m2) + "\\[" + E[0] + "\\]", u3 = u3 || E[1], d3 = false;
                    continue;
                  }
                }
                u3 = true, d3 = false, i3 += x;
                continue;
              default:
                w(), l3 ? l3 = false : !f2[x] || x === "^" && d3 || (i3 += "\\"), i3 += x;
            }
        d3 && (j = e3.substr(g2 + 1), E = this.parse(j, v), i3 = i3.substr(0, m2) + "\\[" + E[0], u3 = u3 || E[1]);
        for (O = p2.pop(); O; O = p2.pop()) {
          var I = i3.slice(O.reStart + O.open.length);
          this.debug("setting tail", i3, O), I = I.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(e4, t4, n4) {
            return n4 || (n4 = "\\"), t4 + t4 + n4 + "|";
          }), this.debug("tail=%j\n   %s", I, I, O, i3);
          var _ = O.type === "*" ? c2 : O.type === "?" ? a2 : "\\" + O.type;
          u3 = true, i3 = i3.slice(0, O.reStart) + _ + "\\(" + I;
        }
        w(), l3 && (i3 += "\\\\");
        var A = false;
        switch (i3.charAt(0)) {
          case ".":
          case "[":
          case "(":
            A = true;
        }
        for (var k = h2.length - 1; k > -1; k--) {
          var N = h2[k], F = i3.slice(0, N.reStart), C = i3.slice(N.reStart, N.reEnd - 8), M = i3.slice(N.reEnd - 8, N.reEnd), T = i3.slice(N.reEnd);
          M += T;
          var V = F.split("(").length - 1, D = T;
          for (S = 0; S < V; S++)
            D = D.replace(/\)[+*?]?/, "");
          var B = "";
          (T = D) === "" && t3 !== v && (B = "$");
          var L = F + C + T + B + M;
          i3 = L;
        }
        i3 !== "" && u3 && (i3 = "(?=.)" + i3);
        A && (i3 = y + i3);
        if (t3 === v)
          return [i3, u3];
        if (!u3)
          return e3.replace(/\\(.)/g, "$1");
        var $ = n3.nocase ? "i" : "";
        try {
          var R = new RegExp("^" + i3 + "$", $);
        } catch (e4) {
          return new RegExp("$.");
        }
        return R._glob = e3, R._src = i3, R;
      };
      var v = {};
      d2.makeRe = function(e3, t3) {
        return new m(e3, t3 || {}).makeRe();
      }, m.prototype.makeRe = function() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var e3 = this.set;
        if (!e3.length)
          return this.regexp = false, this.regexp;
        var t3 = this.options, n3 = t3.noglobstar ? c2 : t3.dot ? u2 : l2, r3 = t3.nocase ? "i" : "", i3 = e3.map(function(e4) {
          return e4.map(function(e5) {
            return e5 === o2 ? n3 : typeof e5 == "string" ? e5.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : e5._src;
          }).join("\\/");
        }).join("|");
        i3 = "^(?:" + i3 + ")$", this.negate && (i3 = "^(?!" + i3 + ").*$");
        try {
          this.regexp = new RegExp(i3, r3);
        } catch (e4) {
          this.regexp = false;
        }
        return this.regexp;
      }, d2.match = function(e3, t3, n3) {
        var r3 = new m(t3, n3 = n3 || {});
        return e3 = e3.filter(function(e4) {
          return r3.match(e4);
        }), r3.options.nonull && !e3.length && e3.push(t3), e3;
      }, m.prototype.match = function(e3, t3) {
        if (this.debug("match", e3, this.pattern), this.comment)
          return false;
        if (this.empty)
          return e3 === "";
        if (e3 === "/" && t3)
          return true;
        var n3 = this.options;
        r2.sep !== "/" && (e3 = e3.split(r2.sep).join("/"));
        e3 = e3.split(p), this.debug(this.pattern, "split", e3);
        var o3, i3, s3 = this.set;
        for (this.debug(this.pattern, "set", s3), i3 = e3.length - 1; i3 >= 0 && !(o3 = e3[i3]); i3--)
          ;
        for (i3 = 0; i3 < s3.length; i3++) {
          var a3 = s3[i3], c3 = e3;
          n3.matchBase && a3.length === 1 && (c3 = [o3]);
          var u3 = this.matchOne(c3, a3, t3);
          if (u3)
            return !!n3.flipNegate || !this.negate;
        }
        return !n3.flipNegate && this.negate;
      }, m.prototype.matchOne = function(e3, t3, n3) {
        var r3 = this.options;
        this.debug("matchOne", { this: this, file: e3, pattern: t3 }), this.debug("matchOne", e3.length, t3.length);
        for (var i3 = 0, s3 = 0, a3 = e3.length, c3 = t3.length; i3 < a3 && s3 < c3; i3++, s3++) {
          this.debug("matchOne loop");
          var u3, l3 = t3[s3], f3 = e3[i3];
          if (this.debug(t3, l3, f3), l3 === false)
            return false;
          if (l3 === o2) {
            this.debug("GLOBSTAR", [t3, l3, f3]);
            var p2 = i3, h2 = s3 + 1;
            if (h2 === c3) {
              for (this.debug("** at the end"); i3 < a3; i3++)
                if (e3[i3] === "." || e3[i3] === ".." || !r3.dot && e3[i3].charAt(0) === ".")
                  return false;
              return true;
            }
            for (; p2 < a3; ) {
              var d3 = e3[p2];
              if (this.debug("\nglobstar while", e3, p2, t3, h2, d3), this.matchOne(e3.slice(p2), t3.slice(h2), n3))
                return this.debug("globstar found match!", p2, a3, d3), true;
              if (d3 === "." || d3 === ".." || !r3.dot && d3.charAt(0) === ".") {
                this.debug("dot detected!", e3, p2, t3, h2);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), p2++;
            }
            return !(!n3 || (this.debug("\n>>> no match, partial?", e3, p2, t3, h2), p2 !== a3));
          }
          if (typeof l3 == "string" ? (u3 = r3.nocase ? f3.toLowerCase() === l3.toLowerCase() : f3 === l3, this.debug("string match", l3, f3, u3)) : (u3 = f3.match(l3), this.debug("pattern match", l3, f3, u3)), !u3)
            return false;
        }
        if (i3 === a3 && s3 === c3)
          return true;
        if (i3 === a3)
          return n3;
        if (s3 === c3)
          return i3 === a3 - 1 && e3[i3] === "";
        throw new Error("wtf?");
      };
    }, function(e2, t2) {
      e2.exports = (init_assert(), __toCommonJS(assert_exports));
    }, function(e2, t2, n2) {
      "use strict";
      function r2(e3) {
        return e3.charAt(0) === "/";
      }
      function o2(e3) {
        var t3 = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/.exec(e3), n3 = t3[1] || "", r3 = Boolean(n3 && n3.charAt(1) !== ":");
        return Boolean(t3[2] || r3);
      }
      e2.exports = process.platform === "win32" ? o2 : r2, e2.exports.posix = r2, e2.exports.win32 = o2;
    }, function(e2, t2) {
      e2.exports = (init_child_process(), __toCommonJS(child_process_exports));
    }, function(e2, t2, n2) {
      e2.exports = !n2(9) && !n2(10)(function() {
        return Object.defineProperty(n2(33)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, function(e2, t2, n2) {
      var r2 = n2(6);
      e2.exports = function(e3, t3) {
        if (!r2(e3))
          return e3;
        var n3, o2;
        if (t3 && typeof (n3 = e3.toString) == "function" && !r2(o2 = n3.call(e3)))
          return o2;
        if (typeof (n3 = e3.valueOf) == "function" && !r2(o2 = n3.call(e3)))
          return o2;
        if (!t3 && typeof (n3 = e3.toString) == "function" && !r2(o2 = n3.call(e3)))
          return o2;
        throw TypeError("Can't convert object to primitive value");
      };
    }, function(e2, t2, n2) {
      var r2 = n2(25), o2 = n2(35), i2 = n2(79);
      e2.exports = function(e3) {
        return function(t3, n3, s2) {
          var a2, c2 = r2(t3), u2 = o2(c2.length), l2 = i2(s2, u2);
          if (e3 && n3 != n3) {
            for (; u2 > l2; )
              if ((a2 = c2[l2++]) != a2)
                return true;
          } else
            for (; u2 > l2; l2++)
              if ((e3 || l2 in c2) && c2[l2] === n3)
                return e3 || l2 || 0;
          return !e3 && -1;
        };
      };
    }, function(e2, t2, n2) {
      var r2 = n2(20);
      e2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e3) {
        return r2(e3) == "String" ? e3.split("") : Object(e3);
      };
    }, function(e2, t2) {
      var n2 = Math.ceil, r2 = Math.floor;
      e2.exports = function(e3) {
        return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? r2 : n2)(e3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(18), o2 = n2(4), i2 = o2["__core-js_shared__"] || (o2["__core-js_shared__"] = {});
      (e2.exports = function(e3, t3) {
        return i2[e3] || (i2[e3] = t3 !== void 0 ? t3 : {});
      })("versions", []).push({ version: r2.version, mode: n2(36) ? "pure" : "global", copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)" });
    }, function(e2, t2, n2) {
      var r2 = n2(20), o2 = n2(3)("toStringTag"), i2 = r2(function() {
        return arguments;
      }()) == "Arguments";
      e2.exports = function(e3) {
        var t3, n3, s2;
        return e3 === void 0 ? "Undefined" : e3 === null ? "Null" : typeof (n3 = function(e4, t4) {
          try {
            return e4[t4];
          } catch (e5) {
          }
        }(t3 = Object(e3), o2)) == "string" ? n3 : i2 ? r2(t3) : (s2 = r2(t3)) == "Object" && typeof t3.callee == "function" ? "Arguments" : s2;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(7);
      e2.exports = function(e3, t3, n3, o2) {
        try {
          return o2 ? t3(r2(n3)[0], n3[1]) : t3(n3);
        } catch (t4) {
          var i2 = e3.return;
          throw i2 !== void 0 && r2(i2.call(e3)), t4;
        }
      };
    }, function(e2, t2, n2) {
      var r2 = n2(39), o2 = n2(3)("iterator"), i2 = Array.prototype;
      e2.exports = function(e3) {
        return e3 !== void 0 && (r2.Array === e3 || i2[o2] === e3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(56), o2 = n2(3)("iterator"), i2 = n2(39);
      e2.exports = n2(18).getIteratorMethod = function(e3) {
        if (e3 != null)
          return e3[o2] || e3["@@iterator"] || i2[r2(e3)];
      };
    }, function(e2, t2, n2) {
      var r2, o2, i2, s2 = n2(12), a2 = n2(82), c2 = n2(61), u2 = n2(33), l2 = n2(4), f2 = l2.process, p = l2.setImmediate, h = l2.clearImmediate, d2 = l2.MessageChannel, m = l2.Dispatch, g = 0, v = {}, y = function() {
        var e3 = +this;
        if (v.hasOwnProperty(e3)) {
          var t3 = v[e3];
          delete v[e3], t3();
        }
      }, b2 = function(e3) {
        y.call(e3.data);
      };
      p && h || (p = function(e3) {
        for (var t3 = [], n3 = 1; arguments.length > n3; )
          t3.push(arguments[n3++]);
        return v[++g] = function() {
          a2(typeof e3 == "function" ? e3 : Function(e3), t3);
        }, r2(g), g;
      }, h = function(e3) {
        delete v[e3];
      }, n2(20)(f2) == "process" ? r2 = function(e3) {
        f2.nextTick(s2(y, e3, 1));
      } : m && m.now ? r2 = function(e3) {
        m.now(s2(y, e3, 1));
      } : d2 ? (i2 = (o2 = new d2()).port2, o2.port1.onmessage = b2, r2 = s2(i2.postMessage, i2, 1)) : l2.addEventListener && typeof postMessage == "function" && !l2.importScripts ? (r2 = function(e3) {
        l2.postMessage(e3 + "", "*");
      }, l2.addEventListener("message", b2, false)) : r2 = "onreadystatechange" in u2("script") ? function(e3) {
        c2.appendChild(u2("script")).onreadystatechange = function() {
          c2.removeChild(this), y.call(e3);
        };
      } : function(e3) {
        setTimeout(s2(y, e3, 1), 0);
      }), e2.exports = { set: p, clear: h };
    }, function(e2, t2, n2) {
      var r2 = n2(4).document;
      e2.exports = r2 && r2.documentElement;
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(19);
      function o2(e3) {
        var t3, n3;
        this.promise = new e3(function(e4, r3) {
          if (t3 !== void 0 || n3 !== void 0)
            throw TypeError("Bad Promise constructor");
          t3 = e4, n3 = r3;
        }), this.resolve = r2(t3), this.reject = r2(n3);
      }
      e2.exports.f = function(e3) {
        return new o2(e3);
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(4), o2 = n2(11), i2 = n2(9), s2 = n2(3)("species");
      e2.exports = function(e3) {
        var t3 = r2[e3];
        i2 && t3 && !t3[s2] && o2.f(t3, s2, { configurable: true, get: function() {
          return this;
        } });
      };
    }, function(e2, t2, n2) {
      var r2 = n2(8), o2 = n2(65)(true);
      r2(r2.S, "Object", { entries: function(e3) {
        return o2(e3);
      } });
    }, function(e2, t2, n2) {
      var r2 = n2(42), o2 = n2(25), i2 = n2(44).f;
      e2.exports = function(e3) {
        return function(t3) {
          for (var n3, s2 = o2(t3), a2 = r2(s2), c2 = a2.length, u2 = 0, l2 = []; c2 > u2; )
            i2.call(s2, n3 = a2[u2++]) && l2.push(e3 ? [n3, s2[n3]] : s2[n3]);
          return l2;
        };
      };
    }, function(e2, t2) {
      e2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, function(e2, t2, n2) {
      e2.exports = l2, l2.realpath = l2, l2.sync = f2, l2.realpathSync = f2, l2.monkeypatch = function() {
        r2.realpath = l2, r2.realpathSync = f2;
      }, l2.unmonkeypatch = function() {
        r2.realpath = o2, r2.realpathSync = i2;
      };
      var r2 = n2(5), o2 = r2.realpath, i2 = r2.realpathSync, s2 = process.version, a2 = /^v[0-5]\./.test(s2), c2 = n2(93);
      function u2(e3) {
        return e3 && e3.syscall === "realpath" && (e3.code === "ELOOP" || e3.code === "ENOMEM" || e3.code === "ENAMETOOLONG");
      }
      function l2(e3, t3, n3) {
        if (a2)
          return o2(e3, t3, n3);
        typeof t3 == "function" && (n3 = t3, t3 = null), o2(e3, t3, function(r3, o3) {
          u2(r3) ? c2.realpath(e3, t3, n3) : n3(r3, o3);
        });
      }
      function f2(e3, t3) {
        if (a2)
          return i2(e3, t3);
        try {
          return i2(e3, t3);
        } catch (n3) {
          if (u2(n3))
            return c2.realpathSync(e3, t3);
          throw n3;
        }
      }
    }, function(e2, t2) {
      e2.exports = (init_events(), __toCommonJS(events_exports));
    }, function(e2, t2, n2) {
      function r2(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }
      t2.alphasort = u2, t2.alphasorti = c2, t2.setopts = function(e3, t3, n3) {
        n3 || (n3 = {});
        if (n3.matchBase && t3.indexOf("/") === -1) {
          if (n3.noglobstar)
            throw new Error("base matching requires globstar");
          t3 = "**/" + t3;
        }
        e3.silent = !!n3.silent, e3.pattern = t3, e3.strict = n3.strict !== false, e3.realpath = !!n3.realpath, e3.realpathCache = n3.realpathCache || /* @__PURE__ */ Object.create(null), e3.follow = !!n3.follow, e3.dot = !!n3.dot, e3.mark = !!n3.mark, e3.nodir = !!n3.nodir, e3.nodir && (e3.mark = true);
        e3.sync = !!n3.sync, e3.nounique = !!n3.nounique, e3.nonull = !!n3.nonull, e3.nosort = !!n3.nosort, e3.nocase = !!n3.nocase, e3.stat = !!n3.stat, e3.noprocess = !!n3.noprocess, e3.absolute = !!n3.absolute, e3.maxLength = n3.maxLength || 1 / 0, e3.cache = n3.cache || /* @__PURE__ */ Object.create(null), e3.statCache = n3.statCache || /* @__PURE__ */ Object.create(null), e3.symlinks = n3.symlinks || /* @__PURE__ */ Object.create(null), function(e4, t4) {
          e4.ignore = t4.ignore || [], Array.isArray(e4.ignore) || (e4.ignore = [e4.ignore]);
          e4.ignore.length && (e4.ignore = e4.ignore.map(l2));
        }(e3, n3), e3.changedCwd = false;
        var i3 = process.cwd();
        r2(n3, "cwd") ? (e3.cwd = o2.resolve(n3.cwd), e3.changedCwd = e3.cwd !== i3) : e3.cwd = i3;
        e3.root = n3.root || o2.resolve(e3.cwd, "/"), e3.root = o2.resolve(e3.root), process.platform === "win32" && (e3.root = e3.root.replace(/\\/g, "/"));
        e3.cwdAbs = s2(e3.cwd) ? e3.cwd : f2(e3, e3.cwd), process.platform === "win32" && (e3.cwdAbs = e3.cwdAbs.replace(/\\/g, "/"));
        e3.nomount = !!n3.nomount, n3.nonegate = true, n3.nocomment = true, e3.minimatch = new a2(t3, n3), e3.options = e3.minimatch.options;
      }, t2.ownProp = r2, t2.makeAbs = f2, t2.finish = function(e3) {
        for (var t3 = e3.nounique, n3 = t3 ? [] : /* @__PURE__ */ Object.create(null), r3 = 0, o3 = e3.matches.length; r3 < o3; r3++) {
          var i3 = e3.matches[r3];
          if (i3 && Object.keys(i3).length !== 0) {
            var s3 = Object.keys(i3);
            t3 ? n3.push.apply(n3, s3) : s3.forEach(function(e4) {
              n3[e4] = true;
            });
          } else if (e3.nonull) {
            var a3 = e3.minimatch.globSet[r3];
            t3 ? n3.push(a3) : n3[a3] = true;
          }
        }
        t3 || (n3 = Object.keys(n3));
        e3.nosort || (n3 = n3.sort(e3.nocase ? c2 : u2));
        if (e3.mark) {
          for (var r3 = 0; r3 < n3.length; r3++)
            n3[r3] = e3._mark(n3[r3]);
          e3.nodir && (n3 = n3.filter(function(t4) {
            var n4 = !/\/$/.test(t4), r4 = e3.cache[t4] || e3.cache[f2(e3, t4)];
            return n4 && r4 && (n4 = r4 !== "DIR" && !Array.isArray(r4)), n4;
          }));
        }
        e3.ignore.length && (n3 = n3.filter(function(t4) {
          return !p(e3, t4);
        }));
        e3.found = n3;
      }, t2.mark = function(e3, t3) {
        var n3 = f2(e3, t3), r3 = e3.cache[n3], o3 = t3;
        if (r3) {
          var i3 = r3 === "DIR" || Array.isArray(r3), s3 = t3.slice(-1) === "/";
          if (i3 && !s3 ? o3 += "/" : !i3 && s3 && (o3 = o3.slice(0, -1)), o3 !== t3) {
            var a3 = f2(e3, o3);
            e3.statCache[a3] = e3.statCache[n3], e3.cache[a3] = e3.cache[n3];
          }
        }
        return o3;
      }, t2.isIgnored = p, t2.childrenIgnored = function(e3, t3) {
        return !!e3.ignore.length && e3.ignore.some(function(e4) {
          return !(!e4.gmatcher || !e4.gmatcher.match(t3));
        });
      };
      var o2 = n2(0), i2 = n2(46), s2 = n2(48), a2 = i2.Minimatch;
      function c2(e3, t3) {
        return e3.toLowerCase().localeCompare(t3.toLowerCase());
      }
      function u2(e3, t3) {
        return e3.localeCompare(t3);
      }
      function l2(e3) {
        var t3 = null;
        if (e3.slice(-3) === "/**") {
          var n3 = e3.replace(/(\/\*\*)+$/, "");
          t3 = new a2(n3, { dot: true });
        }
        return { matcher: new a2(e3, { dot: true }), gmatcher: t3 };
      }
      function f2(e3, t3) {
        var n3 = t3;
        return n3 = t3.charAt(0) === "/" ? o2.join(e3.root, t3) : s2(t3) || t3 === "" ? t3 : e3.changedCwd ? o2.resolve(e3.cwd, t3) : o2.resolve(t3), process.platform === "win32" && (n3 = n3.replace(/\\/g, "/")), n3;
      }
      function p(e3, t3) {
        return !!e3.ignore.length && e3.ignore.some(function(e4) {
          return e4.matcher.match(t3) || !(!e4.gmatcher || !e4.gmatcher.match(t3));
        });
      }
    }, function(e2, t2) {
      e2.exports = function e3(t3, n2) {
        if (t3 && n2)
          return e3(t3)(n2);
        if (typeof t3 != "function")
          throw new TypeError("need wrapper function");
        Object.keys(t3).forEach(function(e4) {
          r2[e4] = t3[e4];
        });
        return r2;
        function r2() {
          for (var e4 = new Array(arguments.length), n3 = 0; n3 < e4.length; n3++)
            e4[n3] = arguments[n3];
          var r3 = t3.apply(this, e4), o2 = e4[e4.length - 1];
          return typeof r3 == "function" && r3 !== o2 && Object.keys(o2).forEach(function(e5) {
            r3[e5] = o2[e5];
          }), r3;
        }
      };
    }, function(e2, t2, n2) {
      var r2 = n2(7), o2 = n2(105), i2 = n2(66), s2 = n2(43)("IE_PROTO"), a2 = function() {
      }, c2 = function() {
        var e3, t3 = n2(33)("iframe"), r3 = i2.length;
        for (t3.style.display = "none", n2(61).appendChild(t3), t3.src = "javascript:", (e3 = t3.contentWindow.document).open(), e3.write("<script>document.F=Object<\/script>"), e3.close(), c2 = e3.F; r3--; )
          delete c2.prototype[i2[r3]];
        return c2();
      };
      e2.exports = Object.create || function(e3, t3) {
        var n3;
        return e3 !== null ? (a2.prototype = r2(e3), n3 = new a2(), a2.prototype = null, n3[s2] = e3) : n3 = c2(), t3 === void 0 ? n3 : o2(n3, t3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(24)("meta"), o2 = n2(6), i2 = n2(15), s2 = n2(11).f, a2 = 0, c2 = Object.isExtensible || function() {
        return true;
      }, u2 = !n2(10)(function() {
        return c2(Object.preventExtensions({}));
      }), l2 = function(e3) {
        s2(e3, r2, { value: { i: "O" + ++a2, w: {} } });
      }, f2 = e2.exports = { KEY: r2, NEED: false, fastKey: function(e3, t3) {
        if (!o2(e3))
          return typeof e3 == "symbol" ? e3 : (typeof e3 == "string" ? "S" : "P") + e3;
        if (!i2(e3, r2)) {
          if (!c2(e3))
            return "F";
          if (!t3)
            return "E";
          l2(e3);
        }
        return e3[r2].i;
      }, getWeak: function(e3, t3) {
        if (!i2(e3, r2)) {
          if (!c2(e3))
            return true;
          if (!t3)
            return false;
          l2(e3);
        }
        return e3[r2].w;
      }, onFreeze: function(e3) {
        return u2 && f2.NEED && c2(e3) && !i2(e3, r2) && l2(e3), e3;
      } };
    }, function(e2, t2, n2) {
      var r2 = n2(6);
      e2.exports = function(e3, t3) {
        if (!r2(e3) || e3._t !== t3)
          throw TypeError("Incompatible receiver, " + t3 + " required!");
        return e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(8), o2 = n2(65)(false);
      r2(r2.S, "Object", { values: function(e3) {
        return o2(e3);
      } });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(7);
      e2.exports = function() {
        var e3 = r2(this), t3 = "";
        return e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.unicode && (t3 += "u"), e3.sticky && (t3 += "y"), t3;
      };
    }, function(e2, t2, n2) {
      e2.exports = u2, u2.sync = function(e3, t3) {
        for (var n3 = c2(e3, t3 = t3 || {}), r3 = n3.env, i3 = n3.ext, u3 = n3.extExe, l2 = [], f2 = 0, p = r3.length; f2 < p; f2++) {
          var h = r3[f2];
          h.charAt(0) === '"' && h.slice(-1) === '"' && (h = h.slice(1, -1));
          var d2 = o2.join(h, e3);
          !h && /^\.[\\\/]/.test(e3) && (d2 = e3.slice(0, 2) + d2);
          for (var m = 0, g = i3.length; m < g; m++) {
            var v = d2 + i3[m];
            try {
              if (s2.sync(v, { pathExt: u3 })) {
                if (!t3.all)
                  return v;
                l2.push(v);
              }
            } catch (e4) {
            }
          }
        }
        if (t3.all && l2.length)
          return l2;
        if (t3.nothrow)
          return null;
        throw a2(e3);
      };
      var r2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", o2 = n2(0), i2 = r2 ? ";" : ":", s2 = n2(118);
      function a2(e3) {
        var t3 = new Error("not found: " + e3);
        return t3.code = "ENOENT", t3;
      }
      function c2(e3, t3) {
        var n3 = t3.colon || i2, o3 = t3.path || process.env.PATH || "", s3 = [""];
        o3 = o3.split(n3);
        var a3 = "";
        return r2 && (o3.unshift(process.cwd()), s3 = (a3 = t3.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(n3), e3.indexOf(".") !== -1 && s3[0] !== "" && s3.unshift("")), (e3.match(/\//) || r2 && e3.match(/\\/)) && (o3 = [""]), { env: o3, ext: s3, extExe: a3 };
      }
      function u2(e3, t3, n3) {
        typeof t3 == "function" && (n3 = t3, t3 = {});
        var r3 = c2(e3, t3), i3 = r3.env, u3 = r3.ext, l2 = r3.extExe, f2 = [];
        !function r4(c3, p) {
          if (c3 === p)
            return t3.all && f2.length ? n3(null, f2) : n3(a2(e3));
          var h = i3[c3];
          h.charAt(0) === '"' && h.slice(-1) === '"' && (h = h.slice(1, -1));
          var d2 = o2.join(h, e3);
          !h && /^\.[\\\/]/.test(e3) && (d2 = e3.slice(0, 2) + d2), function e4(o3, i4) {
            if (o3 === i4)
              return r4(c3 + 1, p);
            var a3 = u3[o3];
            s2(d2 + a3, { pathExt: l2 }, function(r5, s3) {
              if (!r5 && s3) {
                if (!t3.all)
                  return n3(null, d2 + a3);
                f2.push(d2 + a3);
              }
              return e4(o3 + 1, i4);
            });
          }(0, u3.length);
        }(0, i3.length);
      }
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = (e3) => {
        const t3 = (e3 = e3 || {}).env || process.env;
        return (e3.platform || process.platform) !== "win32" ? "PATH" : Object.keys(t3).find((e4) => e4.toUpperCase() === "PATH") || "Path";
      };
    }, function(e2, t2, n2) {
      "use strict";
      n2(32), n2(2), n2(27), n2(64), n2(21);
      var r2 = n2(90), o2 = n2(161), i2 = n2(170), s2 = n2(1);
      function a2(e3, t3) {
        (t3 = t3 || {}).clipboard && console.log("\n*** Clipboard option removed - use clipboardy or clipboard-cli directly ***\n");
        var n3 = Object.keys(e3).length > 0 ? e3 : i2.defaults, s3 = Object.entries(n3).reduce(function(e4, n4) {
          var o3 = n4[0], i3 = n4[1], s4 = r2[`get${o3}`];
          return s4 ? (i3 && e4.push(s4(i3, t3)), e4) : e4 = e4.concat((i3 || []).map(function(e5) {
            var t4 = r2[`get${e5.replace(/\s/g, "")}Info`];
            return t4 ? t4() : Promise.resolve(["Unknown"]);
          }));
        }, []);
        return Promise.all(s3).then(function(e4) {
          var n4 = e4.reduce(function(e5, t4) {
            return t4 && t4[0] && Object.assign(e5, { [t4[0]]: t4 }), e5;
          }, {});
          return function(e5, t4) {
            var n5 = t4.json ? o2.json : t4.markdown ? o2.markdown : o2.yaml;
            if (t4.console) {
              var r3 = false;
              process.stdout.isTTY && (r3 = true), console.log(n5(e5, Object.assign({}, t4, { console: r3 })));
            }
            return n5(e5, Object.assign({}, t4, { console: false }));
          }(Object.entries(i2.defaults).reduce(function(e5, t4) {
            var r3 = t4[0], o3 = t4[1];
            return n4[r3] ? Object.assign(e5, { [r3]: n4[r3][1] }) : Object.assign(e5, { [r3]: (o3 || []).reduce(function(e6, t5) {
              return n4[t5] ? (n4[t5].shift(), n4[t5].length === 1 ? Object.assign(e6, { [t5]: n4[t5][0] }) : Object.assign(e6, { [t5]: { version: n4[t5][0], path: n4[t5][1] } })) : e6;
            }, {}) });
          }, {}), t3);
        });
      }
      e2.exports = { cli: function(e3) {
        if (e3.all)
          return a2(Object.assign({}, i2.defaults, { npmPackages: true, npmGlobalPackages: true }), e3);
        if (e3.raw)
          return a2(JSON.parse(e3.raw), e3);
        if (e3.helper) {
          var t3 = r2[`get${e3.helper}`] || r2[`get${e3.helper}Info`] || r2[e3.helper];
          return t3 ? t3().then(console.log) : console.error("Not Found");
        }
        var n3 = function(e4, t4) {
          return e4.toLowerCase().includes(t4.toLowerCase());
        }, o3 = Object.keys(e3).filter(function(e4) {
          return Object.keys(i2.defaults).some(function(t4) {
            return n3(t4, e4);
          });
        }), c2 = Object.entries(i2.defaults).reduce(function(t4, r3) {
          return o3.some(function(e4) {
            return n3(e4, r3[0]);
          }) ? Object.assign(t4, { [r3[0]]: r3[1] || e3[r3[0]] }) : t4;
        }, {});
        return e3.preset ? i2[e3.preset] ? a2(Object.assign({}, s2.omit(i2[e3.preset], ["options"]), c2), Object.assign({}, i2[e3.preset].options, s2.pick(e3, ["duplicates", "fullTree", "json", "markdown", "console"]))) : console.error(`
No "${e3.preset}" preset found.`) : a2(c2, e3);
      }, helpers: r2, main: a2, run: function(e3, t3) {
        return typeof e3.preset == "string" ? a2(i2[e3.preset], t3) : a2(e3, t3);
      } };
    }, function(e2, t2, n2) {
      var r2 = n2(54), o2 = Math.max, i2 = Math.min;
      e2.exports = function(e3, t3) {
        return (e3 = r2(e3)) < 0 ? o2(e3 + t3, 0) : i2(e3, t3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(3)("unscopables"), o2 = Array.prototype;
      o2[r2] == null && n2(13)(o2, r2, {}), e2.exports = function(e3) {
        o2[r2][e3] = true;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(7), o2 = n2(19), i2 = n2(3)("species");
      e2.exports = function(e3, t3) {
        var n3, s2 = r2(e3).constructor;
        return s2 === void 0 || (n3 = r2(s2)[i2]) == null ? t3 : o2(n3);
      };
    }, function(e2, t2) {
      e2.exports = function(e3, t3, n2) {
        var r2 = n2 === void 0;
        switch (t3.length) {
          case 0:
            return r2 ? e3() : e3.call(n2);
          case 1:
            return r2 ? e3(t3[0]) : e3.call(n2, t3[0]);
          case 2:
            return r2 ? e3(t3[0], t3[1]) : e3.call(n2, t3[0], t3[1]);
          case 3:
            return r2 ? e3(t3[0], t3[1], t3[2]) : e3.call(n2, t3[0], t3[1], t3[2]);
          case 4:
            return r2 ? e3(t3[0], t3[1], t3[2], t3[3]) : e3.call(n2, t3[0], t3[1], t3[2], t3[3]);
        }
        return e3.apply(n2, t3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4), o2 = n2(60).set, i2 = r2.MutationObserver || r2.WebKitMutationObserver, s2 = r2.process, a2 = r2.Promise, c2 = n2(20)(s2) == "process";
      e2.exports = function() {
        var e3, t3, n3, u2 = function() {
          var r3, o3;
          for (c2 && (r3 = s2.domain) && r3.exit(); e3; ) {
            o3 = e3.fn, e3 = e3.next;
            try {
              o3();
            } catch (r4) {
              throw e3 ? n3() : t3 = void 0, r4;
            }
          }
          t3 = void 0, r3 && r3.enter();
        };
        if (c2)
          n3 = function() {
            s2.nextTick(u2);
          };
        else if (!i2 || r2.navigator && r2.navigator.standalone)
          if (a2 && a2.resolve) {
            var l2 = a2.resolve(void 0);
            n3 = function() {
              l2.then(u2);
            };
          } else
            n3 = function() {
              o2.call(r2, u2);
            };
        else {
          var f2 = true, p = document.createTextNode("");
          new i2(u2).observe(p, { characterData: true }), n3 = function() {
            p.data = f2 = !f2;
          };
        }
        return function(r3) {
          var o3 = { fn: r3, next: void 0 };
          t3 && (t3.next = o3), e3 || (e3 = o3, n3()), t3 = o3;
        };
      };
    }, function(e2, t2) {
      e2.exports = function(e3) {
        try {
          return { e: false, v: e3() };
        } catch (e4) {
          return { e: true, v: e4 };
        }
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4).navigator;
      e2.exports = r2 && r2.userAgent || "";
    }, function(e2, t2, n2) {
      var r2 = n2(7), o2 = n2(6), i2 = n2(62);
      e2.exports = function(e3, t3) {
        if (r2(e3), o2(t3) && t3.constructor === e3)
          return t3;
        var n3 = i2.f(e3);
        return (0, n3.resolve)(t3), n3.promise;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(15), o2 = n2(25), i2 = n2(52)(false), s2 = n2(43)("IE_PROTO");
      e2.exports = function(e3, t3) {
        var n3, a2 = o2(e3), c2 = 0, u2 = [];
        for (n3 in a2)
          n3 != s2 && r2(a2, n3) && u2.push(n3);
        for (; t3.length > c2; )
          r2(a2, n3 = t3[c2++]) && (~i2(u2, n3) || u2.push(n3));
        return u2;
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(42), o2 = n2(89), i2 = n2(44), s2 = n2(29), a2 = n2(53), c2 = Object.assign;
      e2.exports = !c2 || n2(10)(function() {
        var e3 = {}, t3 = {}, n3 = Symbol(), r3 = "abcdefghijklmnopqrst";
        return e3[n3] = 7, r3.split("").forEach(function(e4) {
          t3[e4] = e4;
        }), c2({}, e3)[n3] != 7 || Object.keys(c2({}, t3)).join("") != r3;
      }) ? function(e3, t3) {
        for (var n3 = s2(e3), c3 = arguments.length, u2 = 1, l2 = o2.f, f2 = i2.f; c3 > u2; )
          for (var p, h = a2(arguments[u2++]), d2 = l2 ? r2(h).concat(l2(h)) : r2(h), m = d2.length, g = 0; m > g; )
            f2.call(h, p = d2[g++]) && (n3[p] = h[p]);
        return n3;
      } : c2;
    }, function(e2, t2) {
      t2.f = Object.getOwnPropertySymbols;
    }, function(e2, t2, n2) {
      "use strict";
      function r2(e3, t3, n3) {
        return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
      }
      n2(21);
      var o2 = n2(91), i2 = n2(1), s2 = n2(122), a2 = n2(123), c2 = n2(124), u2 = n2(125), l2 = n2(126), f2 = n2(127), p = n2(128), h = n2(129), d2 = n2(130), m = n2(131), g = n2(159), v = n2(160);
      e2.exports = Object.assign({}, i2, o2, function(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var n3 = arguments[t3] != null ? arguments[t3] : {}, o3 = Object.keys(n3);
          typeof Object.getOwnPropertySymbols == "function" && (o3 = o3.concat(Object.getOwnPropertySymbols(n3).filter(function(e4) {
            return Object.getOwnPropertyDescriptor(n3, e4).enumerable;
          }))), o3.forEach(function(t4) {
            r2(e3, t4, n3[t4]);
          });
        }
        return e3;
      }({}, s2, a2, c2, u2, l2, f2, p, h, d2, m, g, v));
    }, function(e2, t2, n2) {
      "use strict";
      n2(22), n2(21), n2(2), n2(32), n2(16);
      var r2 = n2(45), o2 = n2(0), i2 = n2(1), s2 = function(e3) {
        var t3 = e3.split("node_modules" + o2.sep), n3 = t3[t3.length - 1];
        return n3.charAt(0) === "@" ? [n3.split(o2.sep)[0], n3.split(o2.sep)[1]].join("/") : n3.split(o2.sep)[0];
      };
      e2.exports = { getnpmPackages: function(e3, t3) {
        i2.log("trace", "getnpmPackages"), t3 || (t3 = {});
        var n3 = null, r3 = null;
        return typeof e3 == "string" && (e3.includes("*") || e3.includes("?") || e3.includes("+") || e3.includes("!") ? n3 = e3 : e3 = e3.split(",")), Promise.all(["npmPackages", i2.getPackageJsonByPath("package.json").then(function(e4) {
          return Object.assign({}, (e4 || {}).devDependencies || {}, (e4 || {}).dependencies || {});
        }).then(function(e4) {
          return r3 = e4, t3.fullTree || t3.duplicates || n3 ? i2.getAllPackageJsonPaths(n3) : Promise.resolve(Object.keys(e4 || []).map(function(e5) {
            return o2.join("node_modules", e5, "package.json");
          }));
        }).then(function(o3) {
          return !n3 && typeof e3 != "boolean" || t3.fullTree ? Array.isArray(e3) ? Promise.resolve((o3 || []).filter(function(t4) {
            return e3.includes(s2(t4));
          })) : Promise.resolve(o3) : Promise.resolve((o3 || []).filter(function(e4) {
            return Object.keys(r3 || []).includes(s2(e4));
          }));
        }).then(function(e4) {
          return Promise.all([e4, Promise.all(e4.map(function(e5) {
            return i2.getPackageJsonByPath(e5);
          }))]);
        }).then(function(e4) {
          var n4 = e4[0], o3 = e4[1].reduce(function(e5, r4, o4) {
            return r4 && r4.name ? (e5[r4.name] || (e5[r4.name] = {}), t3.duplicates && (e5[r4.name].duplicates = i2.uniq((e5[r4.name].duplicates || []).concat(r4.version))), (n4[o4].match(/node_modules/g) || []).length === 1 && (e5[r4.name].installed = r4.version), e5) : e5;
          }, {});
          return Object.keys(o3).forEach(function(e5) {
            o3[e5].duplicates && o3[e5].installed && (o3[e5].duplicates = o3[e5].duplicates.filter(function(t4) {
              return t4 !== o3[e5].installed;
            })), r3[e5] && (o3[e5].wanted = r3[e5]);
          }), o3;
        }).then(function(n4) {
          return t3.showNotFound && Array.isArray(e3) && e3.forEach(function(e4) {
            n4[e4] || (n4[e4] = "Not Found");
          }), n4;
        }).then(function(e4) {
          return i2.sortObject(e4);
        })]);
      }, getnpmGlobalPackages: function(e3, t3) {
        i2.log("trace", "getnpmGlobalPackages", e3);
        var n3 = null;
        return typeof e3 == "string" ? e3.includes("*") || e3.includes("?") || e3.includes("+") || e3.includes("!") ? n3 = e3 : e3 = e3.split(",") : Array.isArray(e3) || (e3 = true), Promise.all(["npmGlobalPackages", i2.run("npm get prefix --global").then(function(e4) {
          return new Promise(function(t4, s3) {
            return r2(o2.join(e4, i2.isWindows ? "" : "lib", "node_modules", n3 || "{*,@*/*}", "package.json"), function(e5, n4) {
              e5 || t4(n4), s3(e5);
            });
          });
        }).then(function(t4) {
          return Promise.all(t4.filter(function(t5) {
            return typeof e3 == "boolean" || n3 !== null || e3.includes(s2(t5));
          }).map(function(e4) {
            return i2.getPackageJsonByFullPath(e4);
          }));
        }).then(function(e4) {
          return e4.reduce(function(e5, t4) {
            return t4 ? Object.assign(e5, { [t4.name]: t4.version }) : e5;
          }, {});
        }).then(function(n4) {
          return t3.showNotFound && Array.isArray(e3) && e3.forEach(function(e4) {
            n4[e4] || (n4[e4] = "Not Found");
          }), n4;
        })]);
      } };
    }, function(e2, t2, n2) {
      var r2 = n2(6), o2 = n2(20), i2 = n2(3)("match");
      e2.exports = function(e3) {
        var t3;
        return r2(e3) && ((t3 = e3[i2]) !== void 0 ? !!t3 : o2(e3) == "RegExp");
      };
    }, function(e2, t2, n2) {
      var r2 = n2(0), o2 = process.platform === "win32", i2 = n2(5), s2 = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function a2(e3) {
        return typeof e3 == "function" ? e3 : function() {
          var e4;
          if (s2) {
            var t3 = new Error();
            e4 = function(e5) {
              e5 && (t3.message = e5.message, n3(e5 = t3));
            };
          } else
            e4 = n3;
          return e4;
          function n3(e5) {
            if (e5) {
              if (process.throwDeprecation)
                throw e5;
              if (!process.noDeprecation) {
                var t4 = "fs: missing callback " + (e5.stack || e5.message);
                process.traceDeprecation ? console.trace(t4) : console.error(t4);
              }
            }
          }
        }();
      }
      r2.normalize;
      if (o2)
        var c2 = /(.*?)(?:[\/\\]+|$)/g;
      else
        c2 = /(.*?)(?:[\/]+|$)/g;
      if (o2)
        var u2 = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      else
        u2 = /^[\/]*/;
      t2.realpathSync = function(e3, t3) {
        if (e3 = r2.resolve(e3), t3 && Object.prototype.hasOwnProperty.call(t3, e3))
          return t3[e3];
        var n3, s3, a3, l2, f2 = e3, p = {}, h = {};
        function d2() {
          var t4 = u2.exec(e3);
          n3 = t4[0].length, s3 = t4[0], a3 = t4[0], l2 = "", o2 && !h[a3] && (i2.lstatSync(a3), h[a3] = true);
        }
        for (d2(); n3 < e3.length; ) {
          c2.lastIndex = n3;
          var m = c2.exec(e3);
          if (l2 = s3, s3 += m[0], a3 = l2 + m[1], n3 = c2.lastIndex, !(h[a3] || t3 && t3[a3] === a3)) {
            var g;
            if (t3 && Object.prototype.hasOwnProperty.call(t3, a3))
              g = t3[a3];
            else {
              var v = i2.lstatSync(a3);
              if (!v.isSymbolicLink()) {
                h[a3] = true, t3 && (t3[a3] = a3);
                continue;
              }
              var y = null;
              if (!o2) {
                var b2 = v.dev.toString(32) + ":" + v.ino.toString(32);
                p.hasOwnProperty(b2) && (y = p[b2]);
              }
              y === null && (i2.statSync(a3), y = i2.readlinkSync(a3)), g = r2.resolve(l2, y), t3 && (t3[a3] = g), o2 || (p[b2] = y);
            }
            e3 = r2.resolve(g, e3.slice(n3)), d2();
          }
        }
        return t3 && (t3[f2] = e3), e3;
      }, t2.realpath = function(e3, t3, n3) {
        if (typeof n3 != "function" && (n3 = a2(t3), t3 = null), e3 = r2.resolve(e3), t3 && Object.prototype.hasOwnProperty.call(t3, e3))
          return process.nextTick(n3.bind(null, null, t3[e3]));
        var s3, l2, f2, p, h = e3, d2 = {}, m = {};
        function g() {
          var t4 = u2.exec(e3);
          s3 = t4[0].length, l2 = t4[0], f2 = t4[0], p = "", o2 && !m[f2] ? i2.lstat(f2, function(e4) {
            if (e4)
              return n3(e4);
            m[f2] = true, v();
          }) : process.nextTick(v);
        }
        function v() {
          if (s3 >= e3.length)
            return t3 && (t3[h] = e3), n3(null, e3);
          c2.lastIndex = s3;
          var r3 = c2.exec(e3);
          return p = l2, l2 += r3[0], f2 = p + r3[1], s3 = c2.lastIndex, m[f2] || t3 && t3[f2] === f2 ? process.nextTick(v) : t3 && Object.prototype.hasOwnProperty.call(t3, f2) ? w(t3[f2]) : i2.lstat(f2, y);
        }
        function y(e4, r3) {
          if (e4)
            return n3(e4);
          if (!r3.isSymbolicLink())
            return m[f2] = true, t3 && (t3[f2] = f2), process.nextTick(v);
          if (!o2) {
            var s4 = r3.dev.toString(32) + ":" + r3.ino.toString(32);
            if (d2.hasOwnProperty(s4))
              return b2(null, d2[s4], f2);
          }
          i2.stat(f2, function(e5) {
            if (e5)
              return n3(e5);
            i2.readlink(f2, function(e6, t4) {
              o2 || (d2[s4] = t4), b2(e6, t4);
            });
          });
        }
        function b2(e4, o3, i3) {
          if (e4)
            return n3(e4);
          var s4 = r2.resolve(p, o3);
          t3 && (t3[i3] = s4), w(s4);
        }
        function w(t4) {
          e3 = r2.resolve(t4, e3.slice(s3)), g();
        }
        g();
      };
    }, function(e2, t2, n2) {
      var r2 = n2(95), o2 = n2(96);
      e2.exports = function(e3) {
        if (!e3)
          return [];
        e3.substr(0, 2) === "{}" && (e3 = "\\{\\}" + e3.substr(2));
        return function e4(t3, n3) {
          var i3 = [];
          var s3 = o2("{", "}", t3);
          if (!s3 || /\$$/.test(s3.pre))
            return [t3];
          var c3 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(s3.body);
          var u3 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(s3.body);
          var f3 = c3 || u3;
          var g = s3.body.indexOf(",") >= 0;
          if (!f3 && !g)
            return s3.post.match(/,.*\}/) ? (t3 = s3.pre + "{" + s3.body + a2 + s3.post, e4(t3)) : [t3];
          var v;
          if (f3)
            v = s3.body.split(/\.\./);
          else if ((v = function e5(t4) {
            if (!t4)
              return [""];
            var n4 = [];
            var r3 = o2("{", "}", t4);
            if (!r3)
              return t4.split(",");
            var i4 = r3.pre;
            var s4 = r3.body;
            var a3 = r3.post;
            var c4 = i4.split(",");
            c4[c4.length - 1] += "{" + s4 + "}";
            var u4 = e5(a3);
            a3.length && (c4[c4.length - 1] += u4.shift(), c4.push.apply(c4, u4));
            n4.push.apply(n4, c4);
            return n4;
          }(s3.body)).length === 1 && (v = e4(v[0], false).map(p)).length === 1) {
            var y = s3.post.length ? e4(s3.post, false) : [""];
            return y.map(function(e5) {
              return s3.pre + v[0] + e5;
            });
          }
          var b2 = s3.pre;
          var y = s3.post.length ? e4(s3.post, false) : [""];
          var w;
          if (f3) {
            var x = l2(v[0]), S = l2(v[1]), P = Math.max(v[0].length, v[1].length), O = v.length == 3 ? Math.abs(l2(v[2])) : 1, j = d2, E = S < x;
            E && (O *= -1, j = m);
            var I = v.some(h);
            w = [];
            for (var _ = x; j(_, S); _ += O) {
              var A;
              if (u3)
                (A = String.fromCharCode(_)) === "\\" && (A = "");
              else if (A = String(_), I) {
                var k = P - A.length;
                if (k > 0) {
                  var N = new Array(k + 1).join("0");
                  A = _ < 0 ? "-" + N + A.slice(1) : N + A;
                }
              }
              w.push(A);
            }
          } else
            w = r2(v, function(t4) {
              return e4(t4, false);
            });
          for (var F = 0; F < w.length; F++)
            for (var C = 0; C < y.length; C++) {
              var M = b2 + w[F] + y[C];
              (!n3 || f3 || M) && i3.push(M);
            }
          return i3;
        }(function(e4) {
          return e4.split("\\\\").join(i2).split("\\{").join(s2).split("\\}").join(a2).split("\\,").join(c2).split("\\.").join(u2);
        }(e3), true).map(f2);
      };
      var i2 = "\0SLASH" + Math.random() + "\0", s2 = "\0OPEN" + Math.random() + "\0", a2 = "\0CLOSE" + Math.random() + "\0", c2 = "\0COMMA" + Math.random() + "\0", u2 = "\0PERIOD" + Math.random() + "\0";
      function l2(e3) {
        return parseInt(e3, 10) == e3 ? parseInt(e3, 10) : e3.charCodeAt(0);
      }
      function f2(e3) {
        return e3.split(i2).join("\\").split(s2).join("{").split(a2).join("}").split(c2).join(",").split(u2).join(".");
      }
      function p(e3) {
        return "{" + e3 + "}";
      }
      function h(e3) {
        return /^-?0\d/.test(e3);
      }
      function d2(e3, t3) {
        return e3 <= t3;
      }
      function m(e3, t3) {
        return e3 >= t3;
      }
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        for (var r2 = [], o2 = 0; o2 < e3.length; o2++) {
          var i2 = t3(e3[o2], o2);
          n2(i2) ? r2.push.apply(r2, i2) : r2.push(i2);
        }
        return r2;
      };
      var n2 = Array.isArray || function(e3) {
        return Object.prototype.toString.call(e3) === "[object Array]";
      };
    }, function(e2, t2, n2) {
      "use strict";
      function r2(e3, t3, n3) {
        e3 instanceof RegExp && (e3 = o2(e3, n3)), t3 instanceof RegExp && (t3 = o2(t3, n3));
        var r3 = i2(e3, t3, n3);
        return r3 && { start: r3[0], end: r3[1], pre: n3.slice(0, r3[0]), body: n3.slice(r3[0] + e3.length, r3[1]), post: n3.slice(r3[1] + t3.length) };
      }
      function o2(e3, t3) {
        var n3 = t3.match(e3);
        return n3 ? n3[0] : null;
      }
      function i2(e3, t3, n3) {
        var r3, o3, i3, s2, a2, c2 = n3.indexOf(e3), u2 = n3.indexOf(t3, c2 + 1), l2 = c2;
        if (c2 >= 0 && u2 > 0) {
          for (r3 = [], i3 = n3.length; l2 >= 0 && !a2; )
            l2 == c2 ? (r3.push(l2), c2 = n3.indexOf(e3, l2 + 1)) : r3.length == 1 ? a2 = [r3.pop(), u2] : ((o3 = r3.pop()) < i3 && (i3 = o3, s2 = u2), u2 = n3.indexOf(t3, l2 + 1)), l2 = c2 < u2 && c2 >= 0 ? c2 : u2;
          r3.length && (a2 = [i3, s2]);
        }
        return a2;
      }
      e2.exports = r2, r2.range = i2;
    }, function(e2, t2, n2) {
      try {
        var r2 = n2(30);
        if (typeof r2.inherits != "function")
          throw "";
        e2.exports = r2.inherits;
      } catch (t3) {
        e2.exports = n2(98);
      }
    }, function(e2, t2) {
      typeof Object.create == "function" ? e2.exports = function(e3, t3) {
        e3.super_ = t3, e3.prototype = Object.create(t3.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
      } : e2.exports = function(e3, t3) {
        e3.super_ = t3;
        var n2 = function() {
        };
        n2.prototype = t3.prototype, e3.prototype = new n2(), e3.prototype.constructor = e3;
      };
    }, function(e2, t2, n2) {
      e2.exports = d2, d2.GlobSync = m;
      var r2 = n2(5), o2 = n2(67), i2 = n2(46), s2 = (i2.Minimatch, n2(45).Glob, n2(30), n2(0)), a2 = n2(47), c2 = n2(48), u2 = n2(69), l2 = (u2.alphasort, u2.alphasorti, u2.setopts), f2 = u2.ownProp, p = u2.childrenIgnored, h = u2.isIgnored;
      function d2(e3, t3) {
        if (typeof t3 == "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new m(e3, t3).found;
      }
      function m(e3, t3) {
        if (!e3)
          throw new Error("must provide pattern");
        if (typeof t3 == "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof m))
          return new m(e3, t3);
        if (l2(this, e3, t3), this.noprocess)
          return this;
        var n3 = this.minimatch.set.length;
        this.matches = new Array(n3);
        for (var r3 = 0; r3 < n3; r3++)
          this._process(this.minimatch.set[r3], r3, false);
        this._finish();
      }
      m.prototype._finish = function() {
        if (a2(this instanceof m), this.realpath) {
          var e3 = this;
          this.matches.forEach(function(t3, n3) {
            var r3 = e3.matches[n3] = /* @__PURE__ */ Object.create(null);
            for (var i3 in t3)
              try {
                i3 = e3._makeAbs(i3), r3[o2.realpathSync(i3, e3.realpathCache)] = true;
              } catch (t4) {
                if (t4.syscall !== "stat")
                  throw t4;
                r3[e3._makeAbs(i3)] = true;
              }
          });
        }
        u2.finish(this);
      }, m.prototype._process = function(e3, t3, n3) {
        a2(this instanceof m);
        for (var r3, o3 = 0; typeof e3[o3] == "string"; )
          o3++;
        switch (o3) {
          case e3.length:
            return void this._processSimple(e3.join("/"), t3);
          case 0:
            r3 = null;
            break;
          default:
            r3 = e3.slice(0, o3).join("/");
        }
        var s3, u3 = e3.slice(o3);
        r3 === null ? s3 = "." : c2(r3) || c2(e3.join("/")) ? (r3 && c2(r3) || (r3 = "/" + r3), s3 = r3) : s3 = r3;
        var l3 = this._makeAbs(s3);
        p(this, s3) || (u3[0] === i2.GLOBSTAR ? this._processGlobStar(r3, s3, l3, u3, t3, n3) : this._processReaddir(r3, s3, l3, u3, t3, n3));
      }, m.prototype._processReaddir = function(e3, t3, n3, r3, o3, i3) {
        var a3 = this._readdir(n3, i3);
        if (a3) {
          for (var c3 = r3[0], u3 = !!this.minimatch.negate, l3 = c3._glob, f3 = this.dot || l3.charAt(0) === ".", p2 = [], h2 = 0; h2 < a3.length; h2++) {
            if ((g = a3[h2]).charAt(0) !== "." || f3)
              (u3 && !e3 ? !g.match(c3) : g.match(c3)) && p2.push(g);
          }
          var d3 = p2.length;
          if (d3 !== 0)
            if (r3.length !== 1 || this.mark || this.stat) {
              r3.shift();
              for (h2 = 0; h2 < d3; h2++) {
                var m2;
                g = p2[h2];
                m2 = e3 ? [e3, g] : [g], this._process(m2.concat(r3), o3, i3);
              }
            } else {
              this.matches[o3] || (this.matches[o3] = /* @__PURE__ */ Object.create(null));
              for (var h2 = 0; h2 < d3; h2++) {
                var g = p2[h2];
                e3 && (g = e3.slice(-1) !== "/" ? e3 + "/" + g : e3 + g), g.charAt(0) !== "/" || this.nomount || (g = s2.join(this.root, g)), this._emitMatch(o3, g);
              }
            }
        }
      }, m.prototype._emitMatch = function(e3, t3) {
        if (!h(this, t3)) {
          var n3 = this._makeAbs(t3);
          if (this.mark && (t3 = this._mark(t3)), this.absolute && (t3 = n3), !this.matches[e3][t3]) {
            if (this.nodir) {
              var r3 = this.cache[n3];
              if (r3 === "DIR" || Array.isArray(r3))
                return;
            }
            this.matches[e3][t3] = true, this.stat && this._stat(t3);
          }
        }
      }, m.prototype._readdirInGlobStar = function(e3) {
        if (this.follow)
          return this._readdir(e3, false);
        var t3, n3;
        try {
          n3 = r2.lstatSync(e3);
        } catch (e4) {
          if (e4.code === "ENOENT")
            return null;
        }
        var o3 = n3 && n3.isSymbolicLink();
        return this.symlinks[e3] = o3, o3 || !n3 || n3.isDirectory() ? t3 = this._readdir(e3, false) : this.cache[e3] = "FILE", t3;
      }, m.prototype._readdir = function(e3, t3) {
        if (t3 && !f2(this.symlinks, e3))
          return this._readdirInGlobStar(e3);
        if (f2(this.cache, e3)) {
          var n3 = this.cache[e3];
          if (!n3 || n3 === "FILE")
            return null;
          if (Array.isArray(n3))
            return n3;
        }
        try {
          return this._readdirEntries(e3, r2.readdirSync(e3));
        } catch (t4) {
          return this._readdirError(e3, t4), null;
        }
      }, m.prototype._readdirEntries = function(e3, t3) {
        if (!this.mark && !this.stat)
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3 = e3 === "/" ? e3 + r3 : e3 + "/" + r3, this.cache[r3] = true;
          }
        return this.cache[e3] = t3, t3;
      }, m.prototype._readdirError = function(e3, t3) {
        switch (t3.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var n3 = this._makeAbs(e3);
            if (this.cache[n3] = "FILE", n3 === this.cwdAbs) {
              var r3 = new Error(t3.code + " invalid cwd " + this.cwd);
              throw r3.path = this.cwd, r3.code = t3.code, r3;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(e3)] = false;
            break;
          default:
            if (this.cache[this._makeAbs(e3)] = false, this.strict)
              throw t3;
            this.silent || console.error("glob error", t3);
        }
      }, m.prototype._processGlobStar = function(e3, t3, n3, r3, o3, i3) {
        var s3 = this._readdir(n3, i3);
        if (s3) {
          var a3 = r3.slice(1), c3 = e3 ? [e3] : [], u3 = c3.concat(a3);
          this._process(u3, o3, false);
          var l3 = s3.length;
          if (!this.symlinks[n3] || !i3)
            for (var f3 = 0; f3 < l3; f3++) {
              if (s3[f3].charAt(0) !== "." || this.dot) {
                var p2 = c3.concat(s3[f3], a3);
                this._process(p2, o3, true);
                var h2 = c3.concat(s3[f3], r3);
                this._process(h2, o3, true);
              }
            }
        }
      }, m.prototype._processSimple = function(e3, t3) {
        var n3 = this._stat(e3);
        if (this.matches[t3] || (this.matches[t3] = /* @__PURE__ */ Object.create(null)), n3) {
          if (e3 && c2(e3) && !this.nomount) {
            var r3 = /[\/\\]$/.test(e3);
            e3.charAt(0) === "/" ? e3 = s2.join(this.root, e3) : (e3 = s2.resolve(this.root, e3), r3 && (e3 += "/"));
          }
          process.platform === "win32" && (e3 = e3.replace(/\\/g, "/")), this._emitMatch(t3, e3);
        }
      }, m.prototype._stat = function(e3) {
        var t3 = this._makeAbs(e3), n3 = e3.slice(-1) === "/";
        if (e3.length > this.maxLength)
          return false;
        if (!this.stat && f2(this.cache, t3)) {
          var o3 = this.cache[t3];
          if (Array.isArray(o3) && (o3 = "DIR"), !n3 || o3 === "DIR")
            return o3;
          if (n3 && o3 === "FILE")
            return false;
        }
        var i3 = this.statCache[t3];
        if (!i3) {
          var s3;
          try {
            s3 = r2.lstatSync(t3);
          } catch (e4) {
            if (e4 && (e4.code === "ENOENT" || e4.code === "ENOTDIR"))
              return this.statCache[t3] = false, false;
          }
          if (s3 && s3.isSymbolicLink())
            try {
              i3 = r2.statSync(t3);
            } catch (e4) {
              i3 = s3;
            }
          else
            i3 = s3;
        }
        this.statCache[t3] = i3;
        o3 = true;
        return i3 && (o3 = i3.isDirectory() ? "DIR" : "FILE"), this.cache[t3] = this.cache[t3] || o3, (!n3 || o3 !== "FILE") && o3;
      }, m.prototype._mark = function(e3) {
        return u2.mark(this, e3);
      }, m.prototype._makeAbs = function(e3) {
        return u2.makeAbs(this, e3);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(70), o2 = /* @__PURE__ */ Object.create(null), i2 = n2(31);
      e2.exports = r2(function(e3, t3) {
        return o2[e3] ? (o2[e3].push(t3), null) : (o2[e3] = [t3], function(e4) {
          return i2(function t4() {
            var n3 = o2[e4], r3 = n3.length, i3 = function(e5) {
              for (var t5 = e5.length, n4 = [], r4 = 0; r4 < t5; r4++)
                n4[r4] = e5[r4];
              return n4;
            }(arguments);
            try {
              for (var s2 = 0; s2 < r3; s2++)
                n3[s2].apply(null, i3);
            } finally {
              n3.length > r3 ? (n3.splice(0, r3), process.nextTick(function() {
                t4.apply(null, i3);
              })) : delete o2[e4];
            }
          });
        }(e3));
      });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(8), o2 = n2(19), i2 = n2(29), s2 = n2(10), a2 = [].sort, c2 = [1, 2, 3];
      r2(r2.P + r2.F * (s2(function() {
        c2.sort(void 0);
      }) || !s2(function() {
        c2.sort(null);
      }) || !n2(102)(a2)), "Array", { sort: function(e3) {
        return e3 === void 0 ? a2.call(i2(this)) : a2.call(i2(this), o2(e3));
      } });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(10);
      e2.exports = function(e3, t3) {
        return !!e3 && r2(function() {
          t3 ? e3.call(null, function() {
          }, 1) : e3.call(null);
        });
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(104), o2 = n2(73);
      e2.exports = n2(110)("Set", function(e3) {
        return function() {
          return e3(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, { add: function(e3) {
        return r2.def(o2(this, "Set"), e3 = e3 === 0 ? 0 : e3, e3);
      } }, r2);
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(11).f, o2 = n2(71), i2 = n2(40), s2 = n2(12), a2 = n2(37), c2 = n2(38), u2 = n2(106), l2 = n2(109), f2 = n2(63), p = n2(9), h = n2(72).fastKey, d2 = n2(73), m = p ? "_s" : "size", g = function(e3, t3) {
        var n3, r3 = h(t3);
        if (r3 !== "F")
          return e3._i[r3];
        for (n3 = e3._f; n3; n3 = n3.n)
          if (n3.k == t3)
            return n3;
      };
      e2.exports = { getConstructor: function(e3, t3, n3, u3) {
        var l3 = e3(function(e4, r3) {
          a2(e4, l3, t3, "_i"), e4._t = t3, e4._i = o2(null), e4._f = void 0, e4._l = void 0, e4[m] = 0, r3 != null && c2(r3, n3, e4[u3], e4);
        });
        return i2(l3.prototype, { clear: function() {
          for (var e4 = d2(this, t3), n4 = e4._i, r3 = e4._f; r3; r3 = r3.n)
            r3.r = true, r3.p && (r3.p = r3.p.n = void 0), delete n4[r3.i];
          e4._f = e4._l = void 0, e4[m] = 0;
        }, delete: function(e4) {
          var n4 = d2(this, t3), r3 = g(n4, e4);
          if (r3) {
            var o3 = r3.n, i3 = r3.p;
            delete n4._i[r3.i], r3.r = true, i3 && (i3.n = o3), o3 && (o3.p = i3), n4._f == r3 && (n4._f = o3), n4._l == r3 && (n4._l = i3), n4[m]--;
          }
          return !!r3;
        }, forEach: function(e4) {
          d2(this, t3);
          for (var n4, r3 = s2(e4, arguments.length > 1 ? arguments[1] : void 0, 3); n4 = n4 ? n4.n : this._f; )
            for (r3(n4.v, n4.k, this); n4 && n4.r; )
              n4 = n4.p;
        }, has: function(e4) {
          return !!g(d2(this, t3), e4);
        } }), p && r2(l3.prototype, "size", { get: function() {
          return d2(this, t3)[m];
        } }), l3;
      }, def: function(e3, t3, n3) {
        var r3, o3, i3 = g(e3, t3);
        return i3 ? i3.v = n3 : (e3._l = i3 = { i: o3 = h(t3, true), k: t3, v: n3, p: r3 = e3._l, n: void 0, r: false }, e3._f || (e3._f = i3), r3 && (r3.n = i3), e3[m]++, o3 !== "F" && (e3._i[o3] = i3)), e3;
      }, getEntry: g, setStrong: function(e3, t3, n3) {
        u2(e3, t3, function(e4, n4) {
          this._t = d2(e4, t3), this._k = n4, this._l = void 0;
        }, function() {
          for (var e4 = this._k, t4 = this._l; t4 && t4.r; )
            t4 = t4.p;
          return this._t && (this._l = t4 = t4 ? t4.n : this._t._f) ? l2(0, e4 == "keys" ? t4.k : e4 == "values" ? t4.v : [t4.k, t4.v]) : (this._t = void 0, l2(1));
        }, n3 ? "entries" : "values", !n3, true), f2(t3);
      } };
    }, function(e2, t2, n2) {
      var r2 = n2(11), o2 = n2(7), i2 = n2(42);
      e2.exports = n2(9) ? Object.defineProperties : function(e3, t3) {
        o2(e3);
        for (var n3, s2 = i2(t3), a2 = s2.length, c2 = 0; a2 > c2; )
          r2.f(e3, n3 = s2[c2++], t3[n3]);
        return e3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(36), o2 = n2(8), i2 = n2(14), s2 = n2(13), a2 = n2(39), c2 = n2(107), u2 = n2(26), l2 = n2(108), f2 = n2(3)("iterator"), p = !([].keys && "next" in [].keys()), h = function() {
        return this;
      };
      e2.exports = function(e3, t3, n3, d2, m, g, v) {
        c2(n3, t3, d2);
        var y, b2, w, x = function(e4) {
          if (!p && e4 in j)
            return j[e4];
          switch (e4) {
            case "keys":
            case "values":
              return function() {
                return new n3(this, e4);
              };
          }
          return function() {
            return new n3(this, e4);
          };
        }, S = t3 + " Iterator", P = m == "values", O = false, j = e3.prototype, E = j[f2] || j["@@iterator"] || m && j[m], I = E || x(m), _ = m ? P ? x("entries") : I : void 0, A = t3 == "Array" && j.entries || E;
        if (A && (w = l2(A.call(new e3()))) !== Object.prototype && w.next && (u2(w, S, true), r2 || typeof w[f2] == "function" || s2(w, f2, h)), P && E && E.name !== "values" && (O = true, I = function() {
          return E.call(this);
        }), r2 && !v || !p && !O && j[f2] || s2(j, f2, I), a2[t3] = I, a2[S] = h, m)
          if (y = { values: P ? I : x("values"), keys: g ? I : x("keys"), entries: _ }, v)
            for (b2 in y)
              b2 in j || i2(j, b2, y[b2]);
          else
            o2(o2.P + o2.F * (p || O), t3, y);
        return y;
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(71), o2 = n2(23), i2 = n2(26), s2 = {};
      n2(13)(s2, n2(3)("iterator"), function() {
        return this;
      }), e2.exports = function(e3, t3, n3) {
        e3.prototype = r2(s2, { next: o2(1, n3) }), i2(e3, t3 + " Iterator");
      };
    }, function(e2, t2, n2) {
      var r2 = n2(15), o2 = n2(29), i2 = n2(43)("IE_PROTO"), s2 = Object.prototype;
      e2.exports = Object.getPrototypeOf || function(e3) {
        return e3 = o2(e3), r2(e3, i2) ? e3[i2] : typeof e3.constructor == "function" && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? s2 : null;
      };
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        return { value: t3, done: !!e3 };
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(4), o2 = n2(8), i2 = n2(14), s2 = n2(40), a2 = n2(72), c2 = n2(38), u2 = n2(37), l2 = n2(6), f2 = n2(10), p = n2(41), h = n2(26), d2 = n2(111);
      e2.exports = function(e3, t3, n3, m, g, v) {
        var y = r2[e3], b2 = y, w = g ? "set" : "add", x = b2 && b2.prototype, S = {}, P = function(e4) {
          var t4 = x[e4];
          i2(x, e4, e4 == "delete" ? function(e5) {
            return !(v && !l2(e5)) && t4.call(this, e5 === 0 ? 0 : e5);
          } : e4 == "has" ? function(e5) {
            return !(v && !l2(e5)) && t4.call(this, e5 === 0 ? 0 : e5);
          } : e4 == "get" ? function(e5) {
            return v && !l2(e5) ? void 0 : t4.call(this, e5 === 0 ? 0 : e5);
          } : e4 == "add" ? function(e5) {
            return t4.call(this, e5 === 0 ? 0 : e5), this;
          } : function(e5, n4) {
            return t4.call(this, e5 === 0 ? 0 : e5, n4), this;
          });
        };
        if (typeof b2 == "function" && (v || x.forEach && !f2(function() {
          new b2().entries().next();
        }))) {
          var O = new b2(), j = O[w](v ? {} : -0, 1) != O, E = f2(function() {
            O.has(1);
          }), I = p(function(e4) {
            new b2(e4);
          }), _ = !v && f2(function() {
            for (var e4 = new b2(), t4 = 5; t4--; )
              e4[w](t4, t4);
            return !e4.has(-0);
          });
          I || ((b2 = t3(function(t4, n4) {
            u2(t4, b2, e3);
            var r3 = d2(new y(), t4, b2);
            return n4 != null && c2(n4, g, r3[w], r3), r3;
          })).prototype = x, x.constructor = b2), (E || _) && (P("delete"), P("has"), g && P("get")), (_ || j) && P(w), v && x.clear && delete x.clear;
        } else
          b2 = m.getConstructor(t3, e3, g, w), s2(b2.prototype, n3), a2.NEED = true;
        return h(b2, e3), S[e3] = b2, o2(o2.G + o2.W + o2.F * (b2 != y), S), v || m.setStrong(b2, e3, g), b2;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(6), o2 = n2(112).set;
      e2.exports = function(e3, t3, n3) {
        var i2, s2 = t3.constructor;
        return s2 !== n3 && typeof s2 == "function" && (i2 = s2.prototype) !== n3.prototype && r2(i2) && o2 && o2(e3, i2), e3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(6), o2 = n2(7), i2 = function(e3, t3) {
        if (o2(e3), !r2(t3) && t3 !== null)
          throw TypeError(t3 + ": can't set as prototype!");
      };
      e2.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(e3, t3, r3) {
        try {
          (r3 = n2(12)(Function.call, n2(113).f(Object.prototype, "__proto__").set, 2))(e3, []), t3 = !(e3 instanceof Array);
        } catch (e4) {
          t3 = true;
        }
        return function(e4, n3) {
          return i2(e4, n3), t3 ? e4.__proto__ = n3 : r3(e4, n3), e4;
        };
      }({}, false) : void 0), check: i2 };
    }, function(e2, t2, n2) {
      var r2 = n2(44), o2 = n2(23), i2 = n2(25), s2 = n2(51), a2 = n2(15), c2 = n2(50), u2 = Object.getOwnPropertyDescriptor;
      t2.f = n2(9) ? u2 : function(e3, t3) {
        if (e3 = i2(e3), t3 = s2(t3, true), c2)
          try {
            return u2(e3, t3);
          } catch (e4) {
          }
        if (a2(e3, t3))
          return o2(!r2.f.call(e3, t3), e3[t3]);
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(12), o2 = n2(8), i2 = n2(29), s2 = n2(57), a2 = n2(58), c2 = n2(35), u2 = n2(115), l2 = n2(59);
      o2(o2.S + o2.F * !n2(41)(function(e3) {
        Array.from(e3);
      }), "Array", { from: function(e3) {
        var t3, n3, o3, f2, p = i2(e3), h = typeof this == "function" ? this : Array, d2 = arguments.length, m = d2 > 1 ? arguments[1] : void 0, g = m !== void 0, v = 0, y = l2(p);
        if (g && (m = r2(m, d2 > 2 ? arguments[2] : void 0, 2)), y == null || h == Array && a2(y))
          for (n3 = new h(t3 = c2(p.length)); t3 > v; v++)
            u2(n3, v, g ? m(p[v], v) : p[v]);
        else
          for (f2 = y.call(p), n3 = new h(); !(o3 = f2.next()).done; v++)
            u2(n3, v, g ? s2(f2, m, [o3.value, v], true) : o3.value);
        return n3.length = v, n3;
      } });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(11), o2 = n2(23);
      e2.exports = function(e3, t3, n3) {
        t3 in e3 ? r2.f(e3, t3, o2(0, n3)) : e3[t3] = n3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      n2(117);
      var r2 = n2(7), o2 = n2(75), i2 = n2(9), s2 = /./.toString, a2 = function(e3) {
        n2(14)(RegExp.prototype, "toString", e3, true);
      };
      n2(10)(function() {
        return s2.call({ source: "a", flags: "b" }) != "/a/b";
      }) ? a2(function() {
        var e3 = r2(this);
        return "/".concat(e3.source, "/", "flags" in e3 ? e3.flags : !i2 && e3 instanceof RegExp ? o2.call(e3) : void 0);
      }) : s2.name != "toString" && a2(function() {
        return s2.call(this);
      });
    }, function(e2, t2, n2) {
      n2(9) && /./g.flags != "g" && n2(11).f(RegExp.prototype, "flags", { configurable: true, get: n2(75) });
    }, function(e2, t2, n2) {
      var r2;
      n2(5);
      function o2(e3, t3, n3) {
        if (typeof t3 == "function" && (n3 = t3, t3 = {}), !n3) {
          if (typeof Promise != "function")
            throw new TypeError("callback not provided");
          return new Promise(function(n4, r3) {
            o2(e3, t3 || {}, function(e4, t4) {
              e4 ? r3(e4) : n4(t4);
            });
          });
        }
        r2(e3, t3 || {}, function(e4, r3) {
          e4 && (e4.code === "EACCES" || t3 && t3.ignoreErrors) && (e4 = null, r3 = false), n3(e4, r3);
        });
      }
      r2 = process.platform === "win32" || global.TESTING_WINDOWS ? n2(119) : n2(120), e2.exports = o2, o2.sync = function(e3, t3) {
        try {
          return r2.sync(e3, t3 || {});
        } catch (e4) {
          if (t3 && t3.ignoreErrors || e4.code === "EACCES")
            return false;
          throw e4;
        }
      };
    }, function(e2, t2, n2) {
      e2.exports = i2, i2.sync = function(e3, t3) {
        return o2(r2.statSync(e3), e3, t3);
      };
      var r2 = n2(5);
      function o2(e3, t3, n3) {
        return !(!e3.isSymbolicLink() && !e3.isFile()) && function(e4, t4) {
          var n4 = t4.pathExt !== void 0 ? t4.pathExt : process.env.PATHEXT;
          if (!n4)
            return true;
          if ((n4 = n4.split(";")).indexOf("") !== -1)
            return true;
          for (var r3 = 0; r3 < n4.length; r3++) {
            var o3 = n4[r3].toLowerCase();
            if (o3 && e4.substr(-o3.length).toLowerCase() === o3)
              return true;
          }
          return false;
        }(t3, n3);
      }
      function i2(e3, t3, n3) {
        r2.stat(e3, function(r3, i3) {
          n3(r3, !r3 && o2(i3, e3, t3));
        });
      }
    }, function(e2, t2, n2) {
      e2.exports = o2, o2.sync = function(e3, t3) {
        return i2(r2.statSync(e3), t3);
      };
      var r2 = n2(5);
      function o2(e3, t3, n3) {
        r2.stat(e3, function(e4, r3) {
          n3(e4, !e4 && i2(r3, t3));
        });
      }
      function i2(e3, t3) {
        return e3.isFile() && function(e4, t4) {
          var n3 = e4.mode, r3 = e4.uid, o3 = e4.gid, i3 = t4.uid !== void 0 ? t4.uid : process.getuid && process.getuid(), s2 = t4.gid !== void 0 ? t4.gid : process.getgid && process.getgid(), a2 = parseInt("100", 8), c2 = parseInt("010", 8), u2 = parseInt("001", 8), l2 = a2 | c2;
          return n3 & u2 || n3 & c2 && o3 === s2 || n3 & a2 && r3 === i3 || n3 & l2 && i3 === 0;
        }(e3, t3);
      }
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = { androidSystemImages: /system-images;([\S \t]+)/g, androidAPILevels: /platforms;android-(\d+)[\S\s]/g, androidBuildTools: /build-tools;([\d|.]+)[\S\s]/g };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getNodeInfo: function() {
        return r2.log("trace", "getNodeInfo"), Promise.all([r2.isWindows ? r2.run("node -v").then(r2.findVersion) : r2.which("node").then(function(e3) {
          return e3 ? r2.run(e3 + " -v") : Promise.resolve("");
        }).then(r2.findVersion), r2.which("node").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Node", e3[0], e3[1]);
        });
      }, getnpmInfo: function() {
        return r2.log("trace", "getnpmInfo"), Promise.all([r2.run("npm -v"), r2.which("npm").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("npm", e3[0], e3[1]);
        });
      }, getWatchmanInfo: function() {
        return r2.log("trace", "getWatchmanInfo"), Promise.all([r2.which("watchman").then(function(e3) {
          return e3 ? r2.run(e3 + " -v") : void 0;
        }), r2.which("watchman")]).then(function(e3) {
          return r2.determineFound("Watchman", e3[0], e3[1]);
        });
      }, getYarnInfo: function() {
        return r2.log("trace", "getYarnInfo"), Promise.all([r2.run("yarn -v"), r2.which("yarn").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Yarn", e3[0], e3[1]);
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(16), n2(2), n2(27);
      var r2 = n2(5), o2 = n2(17), i2 = n2(1), s2 = n2(0);
      e2.exports = { getBraveBrowserInfo: function() {
        return i2.log("trace", "getBraveBrowser"), (i2.isLinux ? i2.run("brave --version || brave-browser --version").then(function(e3) {
          return e3.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Brave Browser"]).then(i2.findVersion) : Promise.resolve("N/A")).then(function(e3) {
          return i2.determineFound("Brave Browser", e3, "N/A");
        });
      }, getChromeInfo: function() {
        var e3;
        if (i2.log("trace", "getChromeInfo"), i2.isLinux)
          e3 = i2.run("google-chrome --version").then(function(e4) {
            return e4.replace(" dev", "").replace(/^.* ([^ ]*)/g, "$1");
          });
        else if (i2.isMacOS)
          e3 = i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Chrome).then(i2.findVersion);
        else if (i2.isWindows) {
          var t3;
          try {
            t3 = i2.findVersion(r2.readdirSync(s2.join(process.env["ProgramFiles(x86)"], "Google/Chrome/Application")).join("\n"));
          } catch (e4) {
            t3 = i2.NotFound;
          }
          e3 = Promise.resolve(t3);
        } else
          e3 = Promise.resolve("N/A");
        return e3.then(function(e4) {
          return i2.determineFound("Chrome", e4, "N/A");
        });
      }, getChromeCanaryInfo: function() {
        return i2.log("trace", "getChromeCanaryInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Chrome Canary"]).then(function(e3) {
          return i2.determineFound("Chrome Canary", e3, "N/A");
        });
      }, getChromiumInfo: function() {
        return i2.log("trace", "getChromiumInfo"), (i2.isLinux ? i2.run("chromium --version").then(i2.findVersion) : Promise.resolve("N/A")).then(function(e3) {
          return i2.determineFound("Chromium", e3, "N/A");
        });
      }, getEdgeInfo: function() {
        var e3;
        if (i2.log("trace", "getEdgeInfo"), i2.isWindows && o2.release().split(".")[0] === "10") {
          var t3 = { Spartan: "Microsoft.MicrosoftEdge", Chromium: "Microsoft.MicrosoftEdge.Stable", ChromiumDev: "Microsoft.MicrosoftEdge.Dev" };
          e3 = Promise.all(Object.keys(t3).map(function(e4) {
            return function(e5, t4) {
              return i2.run(`powershell get-appxpackage ${e5}`).then(function(e6) {
                if (i2.findVersion(e6) !== "")
                  return `${t4} (${i2.findVersion(e6)})`;
              });
            }(t3[e4], e4);
          }).filter(function(e4) {
            return e4 !== void 0;
          }));
        } else {
          if (!i2.isMacOS)
            return Promise.resolve("N/A");
          e3 = i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Microsoft Edge"]);
        }
        return e3.then(function(e4) {
          return i2.determineFound("Edge", Array.isArray(e4) ? e4.filter(function(e5) {
            return e5 !== void 0;
          }) : e4, i2.NA);
        });
      }, getFirefoxInfo: function() {
        return i2.log("trace", "getFirefoxInfo"), (i2.isLinux ? i2.run("firefox --version").then(function(e3) {
          return e3.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Firefox) : Promise.resolve("N/A")).then(function(e3) {
          return i2.determineFound("Firefox", e3, "N/A");
        });
      }, getFirefoxDeveloperEditionInfo: function() {
        return i2.log("trace", "getFirefoxDeveloperEditionInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Firefox Developer Edition"]).then(function(e3) {
          return i2.determineFound("Firefox Developer Edition", e3, "N/A");
        });
      }, getFirefoxNightlyInfo: function() {
        return i2.log("trace", "getFirefoxNightlyInfo"), (i2.isLinux ? i2.run("firefox-trunk --version").then(function(e3) {
          return e3.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Firefox Nightly"]) : Promise.resolve("N/A")).then(function(e3) {
          return i2.determineFound("Firefox Nightly", e3, "N/A");
        });
      }, getInternetExplorerInfo: function() {
        var e3;
        if (i2.log("trace", "getInternetExplorerInfo"), i2.isWindows) {
          var t3 = [process.env.SYSTEMDRIVE || "C:", "Program Files", "Internet Explorer", "iexplore.exe"].join("\\\\");
          e3 = i2.run(`wmic datafile where "name='${t3}'" get Version`).then(i2.findVersion);
        } else
          e3 = Promise.resolve("N/A");
        return e3.then(function(e4) {
          return i2.determineFound("Internet Explorer", e4, "N/A");
        });
      }, getSafariTechnologyPreviewInfo: function() {
        return i2.log("trace", "getSafariTechnologyPreviewInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Safari Technology Preview"]).then(function(e3) {
          return i2.determineFound("Safari Technology Preview", e3, "N/A");
        });
      }, getSafariInfo: function() {
        return i2.log("trace", "getSafariInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Safari).then(function(e3) {
          return i2.determineFound("Safari", e3, "N/A");
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(32), n2(2);
      var r2 = n2(1);
      e2.exports = { getMongoDBInfo: function() {
        return r2.log("trace", "getMongoDBInfo"), Promise.all([r2.run("mongo --version").then(r2.findVersion), r2.which("mongo")]).then(function(e3) {
          return r2.determineFound("MongoDB", e3[0], e3[1]);
        });
      }, getMySQLInfo: function() {
        return r2.log("trace", "getMySQLInfo"), Promise.all([r2.run("mysql --version").then(function(e3) {
          return `${r2.findVersion(e3, null, 1)}${e3.includes("MariaDB") ? " (MariaDB)" : ""}`;
        }), r2.which("mysql")]).then(function(e3) {
          return r2.determineFound("MySQL", e3[0], e3[1]);
        });
      }, getPostgreSQLInfo: function() {
        return r2.log("trace", "getPostgreSQLInfo"), Promise.all([r2.run("postgres --version").then(r2.findVersion), r2.which("postgres")]).then(function(e3) {
          return r2.determineFound("PostgreSQL", e3[0], e3[1]);
        });
      }, getSQLiteInfo: function() {
        return r2.log("trace", "getSQLiteInfo"), Promise.all([r2.run("sqlite3 --version").then(r2.findVersion), r2.which("sqlite3")]).then(function(e3) {
          return r2.determineFound("SQLite", e3[0], e3[1]);
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(27), n2(16), n2(2);
      var r2 = n2(0), o2 = n2(1);
      e2.exports = { getAndroidStudioInfo: function() {
        var e3 = Promise.resolve("N/A");
        return o2.isMacOS ? e3 = o2.run(o2.generatePlistBuddyCommand(r2.join("/", "Applications", "Android\\ Studio.app", "Contents", "Info.plist"), ["CFBundleShortVersionString", "CFBundleVersion"])).then(function(e4) {
          return e4 || o2.run(o2.generatePlistBuddyCommand(r2.join("~", "Applications", "JetBrains\\ Toolbox", "Android\\ Studio.app", "Contents", "Info.plist"), ["CFBundleShortVersionString", "CFBundleVersion"]));
        }).then(function(e4) {
          return e4.split("\n").join(" ");
        }) : o2.isLinux ? e3 = Promise.all([o2.run('cat /opt/android-studio/bin/studio.sh | grep "$Home/.AndroidStudio" | head -1').then(o2.findVersion), o2.run("cat /opt/android-studio/build.txt")]).then(function(e4) {
          return `${e4[0]} ${e4[1]}`.trim() || o2.NotFound;
        }) : o2.isWindows && (e3 = Promise.all([o2.run('wmic datafile where name="C:\\\\Program Files\\\\Android\\\\Android Studio\\\\bin\\\\studio.exe" get Version').then(function(e4) {
          return e4.replace(/(\r\n|\n|\r)/gm, "");
        }), o2.run('type "C:\\\\Program Files\\\\Android\\\\Android Studio\\\\build.txt"').then(function(e4) {
          return e4.replace(/(\r\n|\n|\r)/gm, "");
        })]).then(function(e4) {
          return `${e4[0]} ${e4[1]}`.trim() || o2.NotFound;
        })), e3.then(function(e4) {
          return o2.determineFound("Android Studio", e4);
        });
      }, getAtomInfo: function() {
        return o2.log("trace", "getAtomInfo"), Promise.all([o2.getDarwinApplicationVersion(o2.ideBundleIdentifiers.Atom), "N/A"]).then(function(e3) {
          return o2.determineFound("Atom", e3[0], e3[1]);
        });
      }, getEmacsInfo: function() {
        return o2.log("trace", "getEmacsInfo"), o2.isMacOS || o2.isLinux ? Promise.all([o2.run("emacs --version").then(o2.findVersion), o2.run("which emacs")]).then(function(e3) {
          return o2.determineFound("Emacs", e3[0], e3[1]);
        }) : Promise.resolve(["Emacs", "N/A"]);
      }, getIntelliJInfo: function() {
        return o2.log("trace", "getIntelliJInfo"), o2.getDarwinApplicationVersion(o2.ideBundleIdentifiers.IntelliJ).then(function(e3) {
          return o2.determineFound("IntelliJ", e3);
        });
      }, getNanoInfo: function() {
        return o2.log("trace", "getNanoInfo"), o2.isMacOS || o2.isLinux ? Promise.all([o2.run("nano --version").then(o2.findVersion), o2.run("which nano")]).then(function(e3) {
          return o2.determineFound("Nano", e3[0], e3[1]);
        }) : Promise.resolve(["Nano", "N/A"]);
      }, getNvimInfo: function() {
        return o2.log("trace", "getNvimInfo"), o2.isMacOS || o2.isLinux ? Promise.all([o2.run("nvim --version").then(o2.findVersion), o2.run("which nvim")]).then(function(e3) {
          return o2.determineFound("Nvim", e3[0], e3[1]);
        }) : Promise.resolve(["Vim", "N/A"]);
      }, getPhpStormInfo: function() {
        return o2.log("trace", "getPhpStormInfo"), o2.getDarwinApplicationVersion(o2.ideBundleIdentifiers.PhpStorm).then(function(e3) {
          return o2.determineFound("PhpStorm", e3);
        });
      }, getSublimeTextInfo: function() {
        return o2.log("trace", "getSublimeTextInfo"), Promise.all([o2.run("subl --version").then(function(e3) {
          return o2.findVersion(e3, /\d+/);
        }), o2.which("subl")]).then(function(e3) {
          return e3[0] === "" && o2.isMacOS ? (o2.log("trace", "getSublimeTextInfo using plist"), Promise.all([o2.getDarwinApplicationVersion(o2.ideBundleIdentifiers["Sublime Text"]), "N/A"])) : e3;
        }).then(function(e3) {
          return o2.determineFound("Sublime Text", e3[0], e3[1]);
        });
      }, getVimInfo: function() {
        return o2.log("trace", "getVimInfo"), o2.isMacOS || o2.isLinux ? Promise.all([o2.run("vim --version").then(o2.findVersion), o2.run("which vim")]).then(function(e3) {
          return o2.determineFound("Vim", e3[0], e3[1]);
        }) : Promise.resolve(["Vim", "N/A"]);
      }, getVSCodeInfo: function() {
        return o2.log("trace", "getVSCodeInfo"), Promise.all([o2.run("code --version").then(o2.findVersion), o2.which("code")]).then(function(e3) {
          return o2.determineFound("VSCode", e3[0], e3[1]);
        });
      }, getVisualStudioInfo: function() {
        return o2.log("trace", "getVisualStudioInfo"), o2.isWindows ? o2.run(`"${process.env["ProgramFiles(x86)"]}/Microsoft Visual Studio/Installer/vswhere.exe" -format json -prerelease`).then(function(e3) {
          var t3 = JSON.parse(e3).map(function(e4) {
            return { Version: e4.installationVersion, DisplayName: e4.displayName };
          });
          return o2.determineFound("Visual Studio", t3.map(function(e4) {
            return `${e4.Version} (${e4.DisplayName})`;
          }));
        }).catch(function() {
          return Promise.resolve(["Visual Studio", o2.NotFound]);
        }) : Promise.resolve(["Visual Studio", o2.NA]);
      }, getWebStormInfo: function() {
        return o2.log("trace", "getWebStormInfo"), o2.getDarwinApplicationVersion(o2.ideBundleIdentifiers.WebStorm).then(function(e3) {
          return o2.determineFound("WebStorm", e3);
        });
      }, getXcodeInfo: function() {
        return o2.log("trace", "getXcodeInfo"), o2.isMacOS ? Promise.all([o2.which("xcodebuild").then(function(e3) {
          return o2.run(e3 + " -version");
        }).then(function(e3) {
          return `${o2.findVersion(e3)}/${e3.split("Build version ")[1]}`;
        }), o2.which("xcodebuild")]).then(function(e3) {
          return o2.determineFound("Xcode", e3[0], e3[1]);
        }) : Promise.resolve(["Xcode", "N/A"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getBashInfo: function() {
        return r2.log("trace", "getBashInfo"), Promise.all([r2.run("bash --version").then(r2.findVersion), r2.which("bash")]).then(function(e3) {
          return r2.determineFound("Bash", e3[0], e3[1]);
        });
      }, getElixirInfo: function() {
        return r2.log("trace", "getElixirInfo"), Promise.all([r2.run("elixir --version").then(function(e3) {
          return r2.findVersion(e3, /[Elixir]+\s([\d+.[\d+|.]+)/, 1);
        }), r2.which("elixir")]).then(function(e3) {
          return Promise.resolve(r2.determineFound("Elixir", e3[0], e3[1]));
        });
      }, getErlangInfo: function() {
        return r2.log("trace", "getErlangInfo"), Promise.all([r2.run(`erl -eval "{ok, Version} = file:read_file(filename:join([code:root_dir(), 'releases', erlang:system_info(otp_release), 'OTP_VERSION'])), io:fwrite(Version), halt()." -noshell`).then(r2.findVersion), r2.which("erl")]).then(function(e3) {
          return Promise.resolve(r2.determineFound("Erlang", e3[0], e3[1]));
        });
      }, getGoInfo: function() {
        return r2.log("trace", "getGoInfo"), Promise.all([r2.run("go version").then(r2.findVersion), r2.which("go")]).then(function(e3) {
          return r2.determineFound("Go", e3[0], e3[1]);
        });
      }, getJavaInfo: function() {
        return r2.log("trace", "getJavaInfo"), Promise.all([r2.run("javac -version", { unify: true }).then(function(e3) {
          return r2.findVersion(e3, /\d+\.[\w+|.|_|-]+/);
        }), r2.run("which javac")]).then(function(e3) {
          return r2.determineFound("Java", e3[0], e3[1]);
        });
      }, getPerlInfo: function() {
        return r2.log("trace", "getPerlInfo"), Promise.all([r2.run("perl -v").then(r2.findVersion), r2.which("perl")]).then(function(e3) {
          return r2.determineFound("Perl", e3[0], e3[1]);
        });
      }, getPHPInfo: function() {
        return r2.log("trace", "getPHPInfo"), Promise.all([r2.run("php -v").then(r2.findVersion), r2.which("php")]).then(function(e3) {
          return r2.determineFound("PHP", e3[0], e3[1]);
        });
      }, getProtocInfo: function() {
        return r2.log("trace", "getProtocInfo"), Promise.all([r2.run("protoc --version").then(r2.findVersion), r2.run("which protoc")]).then(function(e3) {
          return r2.determineFound("Protoc", e3[0], e3[1]);
        });
      }, getPythonInfo: function() {
        return r2.log("trace", "getPythonInfo"), Promise.all([r2.run("python -V 2>&1").then(r2.findVersion), r2.run("which python")]).then(function(e3) {
          return r2.determineFound("Python", e3[0], e3[1]);
        });
      }, getPython3Info: function() {
        return r2.log("trace", "getPython3Info"), Promise.all([r2.run("python3 -V 2>&1").then(r2.findVersion), r2.run("which python3")]).then(function(e3) {
          return r2.determineFound("Python3", e3[0], e3[1]);
        });
      }, getRInfo: function() {
        return r2.log("trace", "getRInfo"), Promise.all([r2.run("R --version", { unify: true }).then(r2.findVersion), r2.which("R")]).then(function(e3) {
          return r2.determineFound("R", e3[0], e3[1]);
        });
      }, getRubyInfo: function() {
        return r2.log("trace", "getRubyInfo"), Promise.all([r2.run("ruby -v").then(r2.findVersion), r2.which("ruby")]).then(function(e3) {
          return r2.determineFound("Ruby", e3[0], e3[1]);
        });
      }, getRustInfo: function() {
        return r2.log("trace", "getRustInfo"), Promise.all([r2.run("rustc --version").then(r2.findVersion), r2.run("which rustc")]).then(function(e3) {
          return r2.determineFound("Rust", e3[0], e3[1]);
        });
      }, getScalaInfo: function() {
        return r2.log("trace", "getScalaInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("scalac -version").then(r2.findVersion), r2.run("which scalac")]).then(function(e3) {
          return r2.determineFound("Scala", e3[0], e3[1]);
        }) : Promise.resolve(["Scala", "N/A"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getAptInfo: function() {
        return r2.log("trace", "getAptInfo"), r2.isLinux ? Promise.all([r2.run("apt --version").then(r2.findVersion), r2.which("apt")]).then(function(e3) {
          return r2.determineFound("Apt", e3[0], e3[1]);
        }) : Promise.all(["Apt", "N/A"]);
      }, getCargoInfo: function() {
        return r2.log("trace", "getCargoInfo"), Promise.all([r2.run("cargo --version").then(r2.findVersion), r2.which("cargo").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Cargo", e3[0], e3[1]);
        });
      }, getCocoaPodsInfo: function() {
        return r2.log("trace", "getCocoaPodsInfo"), r2.isMacOS ? Promise.all([r2.run("pod --version").then(r2.findVersion), r2.which("pod")]).then(function(e3) {
          return r2.determineFound("CocoaPods", e3[0], e3[1]);
        }) : Promise.all(["CocoaPods", "N/A"]);
      }, getComposerInfo: function() {
        return r2.log("trace", "getComposerInfo"), Promise.all([r2.run("composer --version").then(r2.findVersion), r2.which("composer").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Composer", e3[0], e3[1]);
        });
      }, getGradleInfo: function() {
        return r2.log("trace", "getGradleInfo"), Promise.all([r2.run("gradle --version").then(r2.findVersion), r2.which("gradle").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Gradle", e3[0], e3[1]);
        });
      }, getHomebrewInfo: function() {
        return r2.log("trace", "getHomebrewInfo"), r2.isMacOS ? Promise.all([r2.run("brew --version").then(r2.findVersion), r2.which("brew")]).then(function(e3) {
          return r2.determineFound("Homebrew", e3[0], e3[1]);
        }) : Promise.all(["Homebrew", "N/A"]);
      }, getMavenInfo: function() {
        return r2.log("trace", "getMavenInfo"), Promise.all([r2.run("mvn --version").then(r2.findVersion), r2.which("mvn").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("Maven", e3[0], e3[1]);
        });
      }, getpip2Info: function() {
        return r2.log("trace", "getpip2Info"), Promise.all([r2.run("pip2 --version").then(r2.findVersion), r2.which("pip2").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("pip2", e3[0], e3[1]);
        });
      }, getpip3Info: function() {
        return r2.log("trace", "getpip3Info"), Promise.all([r2.run("pip3 --version").then(r2.findVersion), r2.which("pip3").then(r2.condensePath)]).then(function(e3) {
          return r2.determineFound("pip3", e3[0], e3[1]);
        });
      }, getRubyGemsInfo: function() {
        return r2.log("trace", "getRubyGemsInfo"), Promise.all([r2.run("gem --version").then(r2.findVersion), r2.which("gem")]).then(function(e3) {
          return r2.determineFound("RubyGems", e3[0], e3[1]);
        });
      }, getYumInfo: function() {
        return r2.log("trace", "getYumInfo"), r2.isLinux ? Promise.all([r2.run("yum --version").then(r2.findVersion), r2.which("yum")]).then(function(e3) {
          return r2.determineFound("Yum", e3[0], e3[1]);
        }) : Promise.all(["Yum", "N/A"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1), o2 = n2(0);
      e2.exports = { getYarnWorkspacesInfo: function() {
        return r2.log("trace", "getYarnWorkspacesInfo"), Promise.all([r2.run("yarn -v"), r2.getPackageJsonByPath("package.json").then(function(e3) {
          return e3 && "workspaces" in e3;
        })]).then(function(e3) {
          var t3 = "Yarn Workspaces";
          return e3[0] && e3[1] ? Promise.resolve([t3, e3[0]]) : Promise.resolve([t3, "Not Found"]);
        });
      }, getLernaInfo: function() {
        return r2.log("trace", "getLernaInfo"), Promise.all([r2.getPackageJsonByName("lerna").then(function(e3) {
          return e3 && e3.version;
        }), r2.fileExists(o2.join(process.cwd(), "lerna.json"))]).then(function(e3) {
          return e3[0] && e3[1] ? Promise.resolve(["Lerna", e3[0]]) : Promise.resolve(["Lerna", "Not Found"]);
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(22), n2(2), n2(16);
      var r2 = n2(5), o2 = n2(0), i2 = n2(1);
      e2.exports = { getAndroidSDKInfo: function() {
        return i2.run("sdkmanager --list").then(function(e3) {
          return !e3 && process.env.ANDROID_HOME ? i2.run(`${process.env.ANDROID_HOME}/tools/bin/sdkmanager --list`) : e3;
        }).then(function(e3) {
          return !e3 && process.env.ANDROID_HOME ? i2.run(`${process.env.ANDROID_HOME}/cmdline-tools/latest/bin/sdkmanager --list`) : e3;
        }).then(function(e3) {
          return !e3 && i2.isMacOS ? i2.run("~/Library/Android/sdk/tools/bin/sdkmanager --list") : e3;
        }).then(function(e3) {
          var t3 = i2.parseSDKManagerOutput(e3), n3 = function(e4) {
            var t4, n4 = o2.join(e4, "source.properties");
            try {
              t4 = r2.readFileSync(n4, "utf8");
            } catch (e5) {
              if (e5.code === "ENOENT")
                return;
              throw e5;
            }
            for (var i3 = t4.split("\n"), s3 = 0; s3 < i3.length; s3 += 1) {
              var a2 = i3[s3].split("=");
              if (a2.length === 2 && a2[0].trim() === "Pkg.Revision")
                return a2[1].trim();
            }
          }, s2 = process.env.ANDROID_NDK ? n3(process.env.ANDROID_NDK) : process.env.ANDROID_NDK_HOME ? n3(process.env.ANDROID_NDK_HOME) : process.env.ANDROID_HOME ? n3(o2.join(process.env.ANDROID_HOME, "ndk-bundle")) : void 0;
          return t3.buildTools.length || t3.apiLevels.length || t3.systemImages.length || s2 ? Promise.resolve(["Android SDK", { "API Levels": t3.apiLevels || i2.NotFound, "Build Tools": t3.buildTools || i2.NotFound, "System Images": t3.systemImages || i2.NotFound, "Android NDK": s2 || i2.NotFound }]) : Promise.resolve(["Android SDK", i2.NotFound]);
        });
      }, getiOSSDKInfo: function() {
        return i2.isMacOS ? i2.run("xcodebuild -showsdks").then(function(e3) {
          return e3.match(/[\w]+\s[\d|.]+/g);
        }).then(i2.uniq).then(function(e3) {
          return e3.length ? ["iOS SDK", { Platforms: e3 }] : ["iOS SDK", i2.NotFound];
        }) : Promise.resolve(["iOS SDK", "N/A"]);
      }, getWindowsSDKInfo: function() {
        if (i2.log("trace", "getWindowsSDKInfo"), i2.isWindows) {
          var e3 = i2.NotFound;
          return i2.run("reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock").then(function(t3) {
            e3 = t3.split(/[\r\n]/g).slice(1).filter(function(e4) {
              return e4 !== "";
            }).reduce(function(e4, t4) {
              var n4 = t4.match(/[^\s]+/g);
              return n4[2] !== "0x0" && n4[2] !== "0x1" || (n4[2] = n4[2] === "0x1" ? "Enabled" : "Disabled"), e4[n4[0]] = n4[2], e4;
            }, {}), Object.keys(e3).length === 0 && (e3 = i2.NotFound);
            try {
              var n3 = r2.readdirSync(`${process.env["ProgramFiles(x86)"]}/Windows Kits/10/Platforms/UAP`);
              e3.Versions = n3;
            } catch (e4) {
            }
            return Promise.resolve(["Windows SDK", e3]);
          });
        }
        return Promise.resolve(["Windows SDK", i2.NA]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getApacheInfo: function() {
        return r2.log("trace", "getApacheInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("apachectl -v").then(r2.findVersion), r2.run("which apachectl")]).then(function(e3) {
          return r2.determineFound("Apache", e3[0], e3[1]);
        }) : Promise.resolve(["Apache", "N/A"]);
      }, getNginxInfo: function() {
        return r2.log("trace", "getNginxInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("nginx -v 2>&1").then(r2.findVersion), r2.run("which nginx")]).then(function(e3) {
          return r2.determineFound("Nginx", e3[0], e3[1]);
        }) : Promise.resolve(["Nginx", "N/A"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(22), n2(2);
      var r2 = n2(132), o2 = n2(1), i2 = n2(17);
      e2.exports = { getContainerInfo: function() {
        return o2.log("trace", "getContainerInfo"), o2.isLinux ? Promise.all([o2.fileExists("/.dockerenv"), o2.readFile("/proc/self/cgroup")]).then(function(e3) {
          return o2.log("trace", "getContainerInfoThen", e3), Promise.resolve(["Container", e3[0] || e3[1] ? "Yes" : "N/A"]);
        }).catch(function(e3) {
          return o2.log("trace", "getContainerInfoCatch", e3);
        }) : Promise.resolve(["Container", "N/A"]);
      }, getCPUInfo: function() {
        var e3;
        o2.log("trace", "getCPUInfo");
        try {
          var t3 = i2.cpus();
          e3 = "(" + t3.length + ") " + i2.arch() + " " + t3[0].model;
        } catch (t4) {
          e3 = "Unknown";
        }
        return Promise.all(["CPU", e3]);
      }, getMemoryInfo: function() {
        return o2.log("trace", "getMemoryInfo"), Promise.all(["Memory", `${o2.toReadableBytes(i2.freemem())} / ${o2.toReadableBytes(i2.totalmem())}`]);
      }, getOSInfo: function() {
        return o2.log("trace", "getOSInfo"), (o2.isMacOS ? o2.run("sw_vers -productVersion ") : o2.isLinux ? o2.run("cat /etc/os-release").then(function(e3) {
          var t3 = (e3 || "").match(/NAME="(.+)"/) || "", n3 = (e3 || "").match(/VERSION="(.+)"/) || ["", ""], r3 = n3 !== null ? n3[1] : "";
          return `${t3[1]} ${r3}`.trim() || "";
        }) : o2.isWindows ? Promise.resolve(i2.release()) : Promise.resolve()).then(function(e3) {
          var t3 = r2(i2.platform(), i2.release());
          return e3 && (t3 += ` ${e3}`), ["OS", t3];
        });
      }, getShellInfo: function() {
        if (o2.log("trace", "getShellInfo", process.env), o2.isMacOS || o2.isLinux) {
          var e3 = process.env.SHELL || o2.runSync("getent passwd $LOGNAME | cut -d: -f7 | head -1"), t3 = `${e3} --version 2>&1`;
          return e3.match("/bin/ash") && (t3 = `${e3} --help 2>&1`), Promise.all([o2.run(t3).then(o2.findVersion), o2.which(e3)]).then(function(e4) {
            return o2.determineFound("Shell", e4[0] || "Unknown", e4[1]);
          });
        }
        return Promise.resolve(["Shell", "N/A"]);
      }, getGLibcInfo: function() {
        return o2.log("trace", "getGLibc"), o2.isLinux ? Promise.all([o2.run("ldd --version").then(o2.findVersion)]).then(function(e3) {
          return o2.determineFound("GLibc", e3[0] || "Unknown");
        }) : Promise.resolve(["GLibc", "N/A"]);
      } };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(17), o2 = n2(133), i2 = n2(134);
      e2.exports = (e3, t3) => {
        if (!e3 && t3)
          throw new Error("You can't specify a `release` without specifying `platform`");
        let n3;
        if ((e3 = e3 || r2.platform()) === "darwin")
          return t3 || r2.platform() !== "darwin" || (t3 = r2.release()), (t3 ? Number(t3.split(".")[0]) > 15 ? "macOS" : "OS X" : "macOS") + ((n3 = t3 ? o2(t3).name : "") ? " " + n3 : "");
        return e3 === "linux" ? (t3 || r2.platform() !== "linux" || (t3 = r2.release()), "Linux" + ((n3 = t3 ? t3.replace(/^(\d+\.\d+).*/, "$1") : "") ? " " + n3 : "")) : e3 === "win32" ? (t3 || r2.platform() !== "win32" || (t3 = r2.release()), "Windows" + ((n3 = t3 ? i2(t3) : "") ? " " + n3 : "")) : e3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(17), o2 = /* @__PURE__ */ new Map([[18, "Mojave"], [17, "High Sierra"], [16, "Sierra"], [15, "El Capitan"], [14, "Yosemite"], [13, "Mavericks"], [12, "Mountain Lion"], [11, "Lion"], [10, "Snow Leopard"], [9, "Leopard"], [8, "Tiger"], [7, "Panther"], [6, "Jaguar"], [5, "Puma"]]), i2 = (e3) => (e3 = Number((e3 || r2.release()).split(".")[0]), { name: o2.get(e3), version: "10." + (e3 - 4) });
      e2.exports = i2, e2.exports.default = i2;
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(17), o2 = n2(135), i2 = /* @__PURE__ */ new Map([["10.0", "10"], ["6.3", "8.1"], ["6.2", "8"], ["6.1", "7"], ["6.0", "Vista"], ["5.2", "Server 2003"], ["5.1", "XP"], ["5.0", "2000"], ["4.9", "ME"], ["4.1", "98"], ["4.0", "95"]]);
      e2.exports = (e3) => {
        const t3 = /\d+\.\d/.exec(e3 || r2.release());
        if (e3 && !t3)
          throw new Error("`release` argument doesn't match `n.n`");
        const n3 = (t3 || [])[0];
        if ((!e3 || e3 === r2.release()) && ["6.1", "6.2", "6.3", "10.0"].includes(n3)) {
          const e4 = ((o2.sync("wmic", ["os", "get", "Caption"]).stdout || "").match(/2008|2012|2016/) || [])[0];
          if (e4)
            return `Server ${e4}`;
        }
        return i2.get(n3);
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(0), o2 = n2(49), i2 = n2(136), s2 = n2(146), a2 = n2(147), c2 = n2(148), u2 = n2(149), l2 = n2(154), f2 = n2(155), p = n2(157), h = n2(158), d2 = 1e7;
      function m(e3, t3, n3) {
        let o3;
        return (n3 = Object.assign({ extendEnv: true, env: {} }, n3)).extendEnv && (n3.env = Object.assign({}, process.env, n3.env)), n3.__winShell === true ? (delete n3.__winShell, o3 = { command: e3, args: t3, options: n3, file: e3, original: { cmd: e3, args: t3 } }) : o3 = i2._parse(e3, t3, n3), (n3 = Object.assign({ maxBuffer: d2, buffer: true, stripEof: true, preferLocal: true, localDir: o3.options.cwd || process.cwd(), encoding: "utf8", reject: true, cleanup: true }, o3.options)).stdio = h(n3), n3.preferLocal && (n3.env = a2.env(Object.assign({}, n3, { cwd: n3.localDir }))), n3.detached && (n3.cleanup = false), process.platform === "win32" && r2.basename(o3.command) === "cmd.exe" && o3.args.unshift("/q"), { cmd: o3.command, args: o3.args, opts: n3, parsed: o3 };
      }
      function g(e3, t3) {
        return t3 && e3.stripEof && (t3 = s2(t3)), t3;
      }
      function v(e3, t3, n3) {
        let r3 = "/bin/sh", o3 = ["-c", t3];
        return n3 = Object.assign({}, n3), process.platform === "win32" && (n3.__winShell = true, r3 = process.env.comspec || "cmd.exe", o3 = ["/s", "/c", `"${t3}"`], n3.windowsVerbatimArguments = true), n3.shell && (r3 = n3.shell, delete n3.shell), e3(r3, o3, n3);
      }
      function y(e3, t3, { encoding: n3, buffer: r3, maxBuffer: o3 }) {
        if (!e3[t3])
          return null;
        let i3;
        return (i3 = r3 ? n3 ? u2(e3[t3], { encoding: n3, maxBuffer: o3 }) : u2.buffer(e3[t3], { maxBuffer: o3 }) : new Promise((n4, r4) => {
          e3[t3].once("end", n4).once("error", r4);
        })).catch((e4) => {
          throw e4.stream = t3, e4.message = `${t3} ${e4.message}`, e4;
        });
      }
      function b2(e3, t3) {
        const { stdout: n3, stderr: r3 } = e3;
        let o3 = e3.error;
        const { code: i3, signal: s3 } = e3, { parsed: a3, joinedCmd: c3 } = t3, u3 = t3.timedOut || false;
        if (!o3) {
          let e4 = "";
          Array.isArray(a3.opts.stdio) ? (a3.opts.stdio[2] !== "inherit" && (e4 += e4.length > 0 ? r3 : `
${r3}`), a3.opts.stdio[1] !== "inherit" && (e4 += `
${n3}`)) : a3.opts.stdio !== "inherit" && (e4 = `
${r3}${n3}`), (o3 = new Error(`Command failed: ${c3}${e4}`)).code = i3 < 0 ? p(i3) : i3;
        }
        return o3.stdout = n3, o3.stderr = r3, o3.failed = true, o3.signal = s3 || null, o3.cmd = c3, o3.timedOut = u3, o3;
      }
      function w(e3, t3) {
        let n3 = e3;
        return Array.isArray(t3) && t3.length > 0 && (n3 += " " + t3.join(" ")), n3;
      }
      e2.exports = (e3, t3, n3) => {
        const r3 = m(e3, t3, n3), { encoding: s3, buffer: a3, maxBuffer: u3 } = r3.opts, p2 = w(e3, t3);
        let h2, d3;
        try {
          h2 = o2.spawn(r3.cmd, r3.args, r3.opts);
        } catch (e4) {
          return Promise.reject(e4);
        }
        r3.opts.cleanup && (d3 = f2(() => {
          h2.kill();
        }));
        let v2 = null, x = false;
        const S = () => {
          v2 && (clearTimeout(v2), v2 = null), d3 && d3();
        };
        r3.opts.timeout > 0 && (v2 = setTimeout(() => {
          v2 = null, x = true, h2.kill(r3.opts.killSignal);
        }, r3.opts.timeout));
        const P = new Promise((e4) => {
          h2.on("exit", (t4, n4) => {
            S(), e4({ code: t4, signal: n4 });
          }), h2.on("error", (t4) => {
            S(), e4({ error: t4 });
          }), h2.stdin && h2.stdin.on("error", (t4) => {
            S(), e4({ error: t4 });
          });
        });
        function O() {
          h2.stdout && h2.stdout.destroy(), h2.stderr && h2.stderr.destroy();
        }
        const j = () => l2(Promise.all([P, y(h2, "stdout", { encoding: s3, buffer: a3, maxBuffer: u3 }), y(h2, "stderr", { encoding: s3, buffer: a3, maxBuffer: u3 })]).then((e4) => {
          const t4 = e4[0];
          if (t4.stdout = e4[1], t4.stderr = e4[2], t4.error || t4.code !== 0 || t4.signal !== null) {
            const e5 = b2(t4, { joinedCmd: p2, parsed: r3, timedOut: x });
            if (e5.killed = e5.killed || h2.killed, !r3.opts.reject)
              return e5;
            throw e5;
          }
          return { stdout: g(r3.opts, t4.stdout), stderr: g(r3.opts, t4.stderr), code: 0, failed: false, killed: false, signal: null, cmd: p2, timedOut: false };
        }), O);
        return i2._enoent.hookChildProcess(h2, r3.parsed), function(e4, t4) {
          t4 != null && (c2(t4) ? t4.pipe(e4.stdin) : e4.stdin.end(t4));
        }(h2, r3.opts.input), h2.then = (e4, t4) => j().then(e4, t4), h2.catch = (e4) => j().catch(e4), h2;
      }, e2.exports.stdout = (...t3) => e2.exports(...t3).then((e3) => e3.stdout), e2.exports.stderr = (...t3) => e2.exports(...t3).then((e3) => e3.stderr), e2.exports.shell = (t3, n3) => v(e2.exports, t3, n3), e2.exports.sync = (e3, t3, n3) => {
        const r3 = m(e3, t3, n3), i3 = w(e3, t3);
        if (c2(r3.opts.input))
          throw new TypeError("The `input` option cannot be a stream in sync mode");
        const s3 = o2.spawnSync(r3.cmd, r3.args, r3.opts);
        if (s3.code = s3.status, s3.error || s3.status !== 0 || s3.signal !== null) {
          const e4 = b2(s3, { joinedCmd: i3, parsed: r3 });
          if (!r3.opts.reject)
            return e4;
          throw e4;
        }
        return { stdout: g(r3.opts, s3.stdout), stderr: g(r3.opts, s3.stderr), code: 0, failed: false, signal: null, cmd: i3, timedOut: false };
      }, e2.exports.shellSync = (t3, n3) => v(e2.exports.sync, t3, n3);
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(49), o2 = n2(137), i2 = n2(145);
      function s2(e3, t3, n3) {
        const s3 = o2(e3, t3, n3), a2 = r2.spawn(s3.command, s3.args, s3.options);
        return i2.hookChildProcess(a2, s3), a2;
      }
      e2.exports = s2, e2.exports.spawn = s2, e2.exports.sync = function(e3, t3, n3) {
        const s3 = o2(e3, t3, n3), a2 = r2.spawnSync(s3.command, s3.args, s3.options);
        return a2.error = a2.error || i2.verifyENOENTSync(a2.status, s3), a2;
      }, e2.exports._parse = o2, e2.exports._enoent = i2;
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(0), o2 = n2(138), i2 = n2(139), s2 = n2(140), a2 = n2(141), c2 = n2(144), u2 = process.platform === "win32", l2 = /\.(?:com|exe)$/i, f2 = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i, p = o2(() => c2.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
      function h(e3) {
        if (!u2)
          return e3;
        const t3 = function(e4) {
          e4.file = i2(e4);
          const t4 = e4.file && a2(e4.file);
          return t4 ? (e4.args.unshift(e4.file), e4.command = t4, i2(e4)) : e4.file;
        }(e3), n3 = !l2.test(t3);
        if (e3.options.forceShell || n3) {
          const n4 = f2.test(t3);
          e3.command = r2.normalize(e3.command), e3.command = s2.command(e3.command), e3.args = e3.args.map((e4) => s2.argument(e4, n4));
          const o3 = [e3.command].concat(e3.args).join(" ");
          e3.args = ["/d", "/s", "/c", `"${o3}"`], e3.command = process.env.comspec || "cmd.exe", e3.options.windowsVerbatimArguments = true;
        }
        return e3;
      }
      e2.exports = function(e3, t3, n3) {
        t3 && !Array.isArray(t3) && (n3 = t3, t3 = null);
        const r3 = { command: e3, args: t3 = t3 ? t3.slice(0) : [], options: n3 = Object.assign({}, n3), file: void 0, original: { command: e3, args: t3 } };
        return n3.shell ? function(e4) {
          if (p)
            return e4;
          const t4 = [e4.command].concat(e4.args).join(" ");
          return u2 ? (e4.command = typeof e4.options.shell == "string" ? e4.options.shell : process.env.comspec || "cmd.exe", e4.args = ["/d", "/s", "/c", `"${t4}"`], e4.options.windowsVerbatimArguments = true) : (typeof e4.options.shell == "string" ? e4.command = e4.options.shell : process.platform === "android" ? e4.command = "/system/bin/sh" : e4.command = "/bin/sh", e4.args = ["-c", t4]), e4;
        }(r3) : h(r3);
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function(e3) {
        try {
          return e3();
        } catch (e4) {
        }
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(0), o2 = n2(76), i2 = n2(77)();
      function s2(e3, t3) {
        const n3 = process.cwd(), s3 = e3.options.cwd != null;
        if (s3)
          try {
            process.chdir(e3.options.cwd);
          } catch (e4) {
          }
        let a2;
        try {
          a2 = o2.sync(e3.command, { path: (e3.options.env || process.env)[i2], pathExt: t3 ? r2.delimiter : void 0 });
        } catch (e4) {
        } finally {
          process.chdir(n3);
        }
        return a2 && (a2 = r2.resolve(s3 ? e3.options.cwd : "", a2)), a2;
      }
      e2.exports = function(e3) {
        return s2(e3) || s2(e3, true);
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = /([()\][%!^"`<>&|;, *?])/g;
      e2.exports.command = function(e3) {
        return e3 = e3.replace(r2, "^$1");
      }, e2.exports.argument = function(e3, t3) {
        return e3 = (e3 = `"${e3 = (e3 = (e3 = `${e3}`).replace(/(\\*)"/g, '$1$1\\"')).replace(/(\\*)$/, "$1$1")}"`).replace(r2, "^$1"), t3 && (e3 = e3.replace(r2, "^$1")), e3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(5), o2 = n2(142);
      e2.exports = function(e3) {
        let t3, n3;
        Buffer.alloc ? t3 = Buffer.alloc(150) : (t3 = new Buffer(150)).fill(0);
        try {
          n3 = r2.openSync(e3, "r"), r2.readSync(n3, t3, 0, 150, 0), r2.closeSync(n3);
        } catch (e4) {
        }
        return o2(t3.toString());
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(143);
      e2.exports = function(e3) {
        var t3 = e3.match(r2);
        if (!t3)
          return null;
        var n3 = t3[0].replace(/#! ?/, "").split(" "), o2 = n3[0].split("/").pop(), i2 = n3[1];
        return o2 === "env" ? i2 : o2 + (i2 ? " " + i2 : "");
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = /^#!.*/;
    }, function(e2, t2) {
      var n2;
      t2 = e2.exports = Y, n2 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        var e3 = Array.prototype.slice.call(arguments, 0);
        e3.unshift("SEMVER"), console.log.apply(console, e3);
      } : function() {
      }, t2.SEMVER_SPEC_VERSION = "2.0.0";
      var r2 = 256, o2 = Number.MAX_SAFE_INTEGER || 9007199254740991, i2 = t2.re = [], s2 = t2.src = [], a2 = 0, c2 = a2++;
      s2[c2] = "0|[1-9]\\d*";
      var u2 = a2++;
      s2[u2] = "[0-9]+";
      var l2 = a2++;
      s2[l2] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
      var f2 = a2++;
      s2[f2] = "(" + s2[c2] + ")\\.(" + s2[c2] + ")\\.(" + s2[c2] + ")";
      var p = a2++;
      s2[p] = "(" + s2[u2] + ")\\.(" + s2[u2] + ")\\.(" + s2[u2] + ")";
      var h = a2++;
      s2[h] = "(?:" + s2[c2] + "|" + s2[l2] + ")";
      var d2 = a2++;
      s2[d2] = "(?:" + s2[u2] + "|" + s2[l2] + ")";
      var m = a2++;
      s2[m] = "(?:-(" + s2[h] + "(?:\\." + s2[h] + ")*))";
      var g = a2++;
      s2[g] = "(?:-?(" + s2[d2] + "(?:\\." + s2[d2] + ")*))";
      var v = a2++;
      s2[v] = "[0-9A-Za-z-]+";
      var y = a2++;
      s2[y] = "(?:\\+(" + s2[v] + "(?:\\." + s2[v] + ")*))";
      var b2 = a2++, w = "v?" + s2[f2] + s2[m] + "?" + s2[y] + "?";
      s2[b2] = "^" + w + "$";
      var x = "[v=\\s]*" + s2[p] + s2[g] + "?" + s2[y] + "?", S = a2++;
      s2[S] = "^" + x + "$";
      var P = a2++;
      s2[P] = "((?:<|>)?=?)";
      var O = a2++;
      s2[O] = s2[u2] + "|x|X|\\*";
      var j = a2++;
      s2[j] = s2[c2] + "|x|X|\\*";
      var E = a2++;
      s2[E] = "[v=\\s]*(" + s2[j] + ")(?:\\.(" + s2[j] + ")(?:\\.(" + s2[j] + ")(?:" + s2[m] + ")?" + s2[y] + "?)?)?";
      var I = a2++;
      s2[I] = "[v=\\s]*(" + s2[O] + ")(?:\\.(" + s2[O] + ")(?:\\.(" + s2[O] + ")(?:" + s2[g] + ")?" + s2[y] + "?)?)?";
      var _ = a2++;
      s2[_] = "^" + s2[P] + "\\s*" + s2[E] + "$";
      var A = a2++;
      s2[A] = "^" + s2[P] + "\\s*" + s2[I] + "$";
      var k = a2++;
      s2[k] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
      var N = a2++;
      s2[N] = "(?:~>?)";
      var F = a2++;
      s2[F] = "(\\s*)" + s2[N] + "\\s+", i2[F] = new RegExp(s2[F], "g");
      var C = a2++;
      s2[C] = "^" + s2[N] + s2[E] + "$";
      var M = a2++;
      s2[M] = "^" + s2[N] + s2[I] + "$";
      var T = a2++;
      s2[T] = "(?:\\^)";
      var V = a2++;
      s2[V] = "(\\s*)" + s2[T] + "\\s+", i2[V] = new RegExp(s2[V], "g");
      var D = a2++;
      s2[D] = "^" + s2[T] + s2[E] + "$";
      var B = a2++;
      s2[B] = "^" + s2[T] + s2[I] + "$";
      var L = a2++;
      s2[L] = "^" + s2[P] + "\\s*(" + x + ")$|^$";
      var $ = a2++;
      s2[$] = "^" + s2[P] + "\\s*(" + w + ")$|^$";
      var R = a2++;
      s2[R] = "(\\s*)" + s2[P] + "\\s*(" + x + "|" + s2[E] + ")", i2[R] = new RegExp(s2[R], "g");
      var G = a2++;
      s2[G] = "^\\s*(" + s2[E] + ")\\s+-\\s+(" + s2[E] + ")\\s*$";
      var W = a2++;
      s2[W] = "^\\s*(" + s2[I] + ")\\s+-\\s+(" + s2[I] + ")\\s*$";
      var U = a2++;
      s2[U] = "(<|>)?=?\\s*\\*";
      for (var q = 0; q < 35; q++)
        n2(q, s2[q]), i2[q] || (i2[q] = new RegExp(s2[q]));
      function K(e3, t3) {
        if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof Y)
          return e3;
        if (typeof e3 != "string")
          return null;
        if (e3.length > r2)
          return null;
        if (!(t3.loose ? i2[S] : i2[b2]).test(e3))
          return null;
        try {
          return new Y(e3, t3);
        } catch (e4) {
          return null;
        }
      }
      function Y(e3, t3) {
        if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof Y) {
          if (e3.loose === t3.loose)
            return e3;
          e3 = e3.version;
        } else if (typeof e3 != "string")
          throw new TypeError("Invalid Version: " + e3);
        if (e3.length > r2)
          throw new TypeError("version is longer than " + r2 + " characters");
        if (!(this instanceof Y))
          return new Y(e3, t3);
        n2("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose;
        var s3 = e3.trim().match(t3.loose ? i2[S] : i2[b2]);
        if (!s3)
          throw new TypeError("Invalid Version: " + e3);
        if (this.raw = e3, this.major = +s3[1], this.minor = +s3[2], this.patch = +s3[3], this.major > o2 || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > o2 || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > o2 || this.patch < 0)
          throw new TypeError("Invalid patch version");
        s3[4] ? this.prerelease = s3[4].split(".").map(function(e4) {
          if (/^[0-9]+$/.test(e4)) {
            var t4 = +e4;
            if (t4 >= 0 && t4 < o2)
              return t4;
          }
          return e4;
        }) : this.prerelease = [], this.build = s3[5] ? s3[5].split(".") : [], this.format();
      }
      t2.parse = K, t2.valid = function(e3, t3) {
        var n3 = K(e3, t3);
        return n3 ? n3.version : null;
      }, t2.clean = function(e3, t3) {
        var n3 = K(e3.trim().replace(/^[=v]+/, ""), t3);
        return n3 ? n3.version : null;
      }, t2.SemVer = Y, Y.prototype.format = function() {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
      }, Y.prototype.toString = function() {
        return this.version;
      }, Y.prototype.compare = function(e3) {
        return n2("SemVer.compare", this.version, this.options, e3), e3 instanceof Y || (e3 = new Y(e3, this.options)), this.compareMain(e3) || this.comparePre(e3);
      }, Y.prototype.compareMain = function(e3) {
        return e3 instanceof Y || (e3 = new Y(e3, this.options)), J(this.major, e3.major) || J(this.minor, e3.minor) || J(this.patch, e3.patch);
      }, Y.prototype.comparePre = function(e3) {
        if (e3 instanceof Y || (e3 = new Y(e3, this.options)), this.prerelease.length && !e3.prerelease.length)
          return -1;
        if (!this.prerelease.length && e3.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e3.prerelease.length)
          return 0;
        var t3 = 0;
        do {
          var r3 = this.prerelease[t3], o3 = e3.prerelease[t3];
          if (n2("prerelease compare", t3, r3, o3), r3 === void 0 && o3 === void 0)
            return 0;
          if (o3 === void 0)
            return 1;
          if (r3 === void 0)
            return -1;
          if (r3 !== o3)
            return J(r3, o3);
        } while (++t3);
      }, Y.prototype.inc = function(e3, t3) {
        switch (e3) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0)
              this.prerelease = [0];
            else {
              for (var n3 = this.prerelease.length; --n3 >= 0; )
                typeof this.prerelease[n3] == "number" && (this.prerelease[n3]++, n3 = -2);
              n3 === -1 && this.prerelease.push(0);
            }
            t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
            break;
          default:
            throw new Error("invalid increment argument: " + e3);
        }
        return this.format(), this.raw = this.version, this;
      }, t2.inc = function(e3, t3, n3, r3) {
        typeof n3 == "string" && (r3 = n3, n3 = void 0);
        try {
          return new Y(e3, n3).inc(t3, r3).version;
        } catch (e4) {
          return null;
        }
      }, t2.diff = function(e3, t3) {
        if (Z(e3, t3))
          return null;
        var n3 = K(e3), r3 = K(t3);
        if (n3.prerelease.length || r3.prerelease.length) {
          for (var o3 in n3)
            if ((o3 === "major" || o3 === "minor" || o3 === "patch") && n3[o3] !== r3[o3])
              return "pre" + o3;
          return "prerelease";
        }
        for (var o3 in n3)
          if ((o3 === "major" || o3 === "minor" || o3 === "patch") && n3[o3] !== r3[o3])
            return o3;
      }, t2.compareIdentifiers = J;
      var H = /^[0-9]+$/;
      function J(e3, t3) {
        var n3 = H.test(e3), r3 = H.test(t3);
        return n3 && r3 && (e3 = +e3, t3 = +t3), n3 && !r3 ? -1 : r3 && !n3 ? 1 : e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
      }
      function z(e3, t3, n3) {
        return new Y(e3, n3).compare(new Y(t3, n3));
      }
      function Q(e3, t3, n3) {
        return z(e3, t3, n3) > 0;
      }
      function X(e3, t3, n3) {
        return z(e3, t3, n3) < 0;
      }
      function Z(e3, t3, n3) {
        return z(e3, t3, n3) === 0;
      }
      function ee(e3, t3, n3) {
        return z(e3, t3, n3) !== 0;
      }
      function te(e3, t3, n3) {
        return z(e3, t3, n3) >= 0;
      }
      function ne(e3, t3, n3) {
        return z(e3, t3, n3) <= 0;
      }
      function re(e3, t3, n3, r3) {
        var o3;
        switch (t3) {
          case "===":
            typeof e3 == "object" && (e3 = e3.version), typeof n3 == "object" && (n3 = n3.version), o3 = e3 === n3;
            break;
          case "!==":
            typeof e3 == "object" && (e3 = e3.version), typeof n3 == "object" && (n3 = n3.version), o3 = e3 !== n3;
            break;
          case "":
          case "=":
          case "==":
            o3 = Z(e3, n3, r3);
            break;
          case "!=":
            o3 = ee(e3, n3, r3);
            break;
          case ">":
            o3 = Q(e3, n3, r3);
            break;
          case ">=":
            o3 = te(e3, n3, r3);
            break;
          case "<":
            o3 = X(e3, n3, r3);
            break;
          case "<=":
            o3 = ne(e3, n3, r3);
            break;
          default:
            throw new TypeError("Invalid operator: " + t3);
        }
        return o3;
      }
      function oe(e3, t3) {
        if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof oe) {
          if (e3.loose === !!t3.loose)
            return e3;
          e3 = e3.value;
        }
        if (!(this instanceof oe))
          return new oe(e3, t3);
        n2("comparator", e3, t3), this.options = t3, this.loose = !!t3.loose, this.parse(e3), this.semver === ie ? this.value = "" : this.value = this.operator + this.semver.version, n2("comp", this);
      }
      t2.rcompareIdentifiers = function(e3, t3) {
        return J(t3, e3);
      }, t2.major = function(e3, t3) {
        return new Y(e3, t3).major;
      }, t2.minor = function(e3, t3) {
        return new Y(e3, t3).minor;
      }, t2.patch = function(e3, t3) {
        return new Y(e3, t3).patch;
      }, t2.compare = z, t2.compareLoose = function(e3, t3) {
        return z(e3, t3, true);
      }, t2.rcompare = function(e3, t3, n3) {
        return z(t3, e3, n3);
      }, t2.sort = function(e3, n3) {
        return e3.sort(function(e4, r3) {
          return t2.compare(e4, r3, n3);
        });
      }, t2.rsort = function(e3, n3) {
        return e3.sort(function(e4, r3) {
          return t2.rcompare(e4, r3, n3);
        });
      }, t2.gt = Q, t2.lt = X, t2.eq = Z, t2.neq = ee, t2.gte = te, t2.lte = ne, t2.cmp = re, t2.Comparator = oe;
      var ie = {};
      function se(e3, t3) {
        if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof se)
          return e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease ? e3 : new se(e3.raw, t3);
        if (e3 instanceof oe)
          return new se(e3.value, t3);
        if (!(this instanceof se))
          return new se(e3, t3);
        if (this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease, this.raw = e3, this.set = e3.split(/\s*\|\|\s*/).map(function(e4) {
          return this.parseRange(e4.trim());
        }, this).filter(function(e4) {
          return e4.length;
        }), !this.set.length)
          throw new TypeError("Invalid SemVer Range: " + e3);
        this.format();
      }
      function ae(e3) {
        return !e3 || e3.toLowerCase() === "x" || e3 === "*";
      }
      function ce(e3, t3, n3, r3, o3, i3, s3, a3, c3, u3, l3, f3, p2) {
        return ((t3 = ae(n3) ? "" : ae(r3) ? ">=" + n3 + ".0.0" : ae(o3) ? ">=" + n3 + "." + r3 + ".0" : ">=" + t3) + " " + (a3 = ae(c3) ? "" : ae(u3) ? "<" + (+c3 + 1) + ".0.0" : ae(l3) ? "<" + c3 + "." + (+u3 + 1) + ".0" : f3 ? "<=" + c3 + "." + u3 + "." + l3 + "-" + f3 : "<=" + a3)).trim();
      }
      function ue(e3, t3, r3) {
        for (var o3 = 0; o3 < e3.length; o3++)
          if (!e3[o3].test(t3))
            return false;
        if (r3 || (r3 = {}), t3.prerelease.length && !r3.includePrerelease) {
          for (o3 = 0; o3 < e3.length; o3++)
            if (n2(e3[o3].semver), e3[o3].semver !== ie && e3[o3].semver.prerelease.length > 0) {
              var i3 = e3[o3].semver;
              if (i3.major === t3.major && i3.minor === t3.minor && i3.patch === t3.patch)
                return true;
            }
          return false;
        }
        return true;
      }
      function le(e3, t3, n3) {
        try {
          t3 = new se(t3, n3);
        } catch (e4) {
          return false;
        }
        return t3.test(e3);
      }
      function fe(e3, t3, n3, r3) {
        var o3, i3, s3, a3, c3;
        switch (e3 = new Y(e3, r3), t3 = new se(t3, r3), n3) {
          case ">":
            o3 = Q, i3 = ne, s3 = X, a3 = ">", c3 = ">=";
            break;
          case "<":
            o3 = X, i3 = te, s3 = Q, a3 = "<", c3 = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (le(e3, t3, r3))
          return false;
        for (var u3 = 0; u3 < t3.set.length; ++u3) {
          var l3 = t3.set[u3], f3 = null, p2 = null;
          if (l3.forEach(function(e4) {
            e4.semver === ie && (e4 = new oe(">=0.0.0")), f3 = f3 || e4, p2 = p2 || e4, o3(e4.semver, f3.semver, r3) ? f3 = e4 : s3(e4.semver, p2.semver, r3) && (p2 = e4);
          }), f3.operator === a3 || f3.operator === c3)
            return false;
          if ((!p2.operator || p2.operator === a3) && i3(e3, p2.semver))
            return false;
          if (p2.operator === c3 && s3(e3, p2.semver))
            return false;
        }
        return true;
      }
      oe.prototype.parse = function(e3) {
        var t3 = this.options.loose ? i2[L] : i2[$], n3 = e3.match(t3);
        if (!n3)
          throw new TypeError("Invalid comparator: " + e3);
        this.operator = n3[1], this.operator === "=" && (this.operator = ""), n3[2] ? this.semver = new Y(n3[2], this.options.loose) : this.semver = ie;
      }, oe.prototype.toString = function() {
        return this.value;
      }, oe.prototype.test = function(e3) {
        return n2("Comparator.test", e3, this.options.loose), this.semver === ie || (typeof e3 == "string" && (e3 = new Y(e3, this.options)), re(e3, this.operator, this.semver, this.options));
      }, oe.prototype.intersects = function(e3, t3) {
        if (!(e3 instanceof oe))
          throw new TypeError("a Comparator is required");
        var n3;
        if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), this.operator === "")
          return n3 = new se(e3.value, t3), le(this.value, n3, t3);
        if (e3.operator === "")
          return n3 = new se(this.value, t3), le(e3.semver, n3, t3);
        var r3 = !(this.operator !== ">=" && this.operator !== ">" || e3.operator !== ">=" && e3.operator !== ">"), o3 = !(this.operator !== "<=" && this.operator !== "<" || e3.operator !== "<=" && e3.operator !== "<"), i3 = this.semver.version === e3.semver.version, s3 = !(this.operator !== ">=" && this.operator !== "<=" || e3.operator !== ">=" && e3.operator !== "<="), a3 = re(this.semver, "<", e3.semver, t3) && (this.operator === ">=" || this.operator === ">") && (e3.operator === "<=" || e3.operator === "<"), c3 = re(this.semver, ">", e3.semver, t3) && (this.operator === "<=" || this.operator === "<") && (e3.operator === ">=" || e3.operator === ">");
        return r3 || o3 || i3 && s3 || a3 || c3;
      }, t2.Range = se, se.prototype.format = function() {
        return this.range = this.set.map(function(e3) {
          return e3.join(" ").trim();
        }).join("||").trim(), this.range;
      }, se.prototype.toString = function() {
        return this.range;
      }, se.prototype.parseRange = function(e3) {
        var t3 = this.options.loose;
        e3 = e3.trim();
        var r3 = t3 ? i2[W] : i2[G];
        e3 = e3.replace(r3, ce), n2("hyphen replace", e3), e3 = e3.replace(i2[R], "$1$2$3"), n2("comparator trim", e3, i2[R]), e3 = (e3 = (e3 = e3.replace(i2[F], "$1~")).replace(i2[V], "$1^")).split(/\s+/).join(" ");
        var o3 = t3 ? i2[L] : i2[$], s3 = e3.split(" ").map(function(e4) {
          return function(e5, t4) {
            return n2("comp", e5, t4), e5 = function(e6, t5) {
              return e6.trim().split(/\s+/).map(function(e7) {
                return function(e8, t6) {
                  n2("caret", e8, t6), t6 && typeof t6 == "object" || (t6 = { loose: !!t6, includePrerelease: false });
                  var r4 = t6.loose ? i2[B] : i2[D];
                  return e8.replace(r4, function(t7, r5, o4, i3, s4) {
                    var a3;
                    return n2("caret", e8, t7, r5, o4, i3, s4), ae(r5) ? a3 = "" : ae(o4) ? a3 = ">=" + r5 + ".0.0 <" + (+r5 + 1) + ".0.0" : ae(i3) ? a3 = r5 === "0" ? ">=" + r5 + "." + o4 + ".0 <" + r5 + "." + (+o4 + 1) + ".0" : ">=" + r5 + "." + o4 + ".0 <" + (+r5 + 1) + ".0.0" : s4 ? (n2("replaceCaret pr", s4), s4.charAt(0) !== "-" && (s4 = "-" + s4), a3 = r5 === "0" ? o4 === "0" ? ">=" + r5 + "." + o4 + "." + i3 + s4 + " <" + r5 + "." + o4 + "." + (+i3 + 1) : ">=" + r5 + "." + o4 + "." + i3 + s4 + " <" + r5 + "." + (+o4 + 1) + ".0" : ">=" + r5 + "." + o4 + "." + i3 + s4 + " <" + (+r5 + 1) + ".0.0") : (n2("no pr"), a3 = r5 === "0" ? o4 === "0" ? ">=" + r5 + "." + o4 + "." + i3 + " <" + r5 + "." + o4 + "." + (+i3 + 1) : ">=" + r5 + "." + o4 + "." + i3 + " <" + r5 + "." + (+o4 + 1) + ".0" : ">=" + r5 + "." + o4 + "." + i3 + " <" + (+r5 + 1) + ".0.0"), n2("caret return", a3), a3;
                  });
                }(e7, t5);
              }).join(" ");
            }(e5, t4), n2("caret", e5), e5 = function(e6, t5) {
              return e6.trim().split(/\s+/).map(function(e7) {
                return function(e8, t6) {
                  t6 && typeof t6 == "object" || (t6 = { loose: !!t6, includePrerelease: false });
                  var r4 = t6.loose ? i2[M] : i2[C];
                  return e8.replace(r4, function(t7, r5, o4, i3, s4) {
                    var a3;
                    return n2("tilde", e8, t7, r5, o4, i3, s4), ae(r5) ? a3 = "" : ae(o4) ? a3 = ">=" + r5 + ".0.0 <" + (+r5 + 1) + ".0.0" : ae(i3) ? a3 = ">=" + r5 + "." + o4 + ".0 <" + r5 + "." + (+o4 + 1) + ".0" : s4 ? (n2("replaceTilde pr", s4), s4.charAt(0) !== "-" && (s4 = "-" + s4), a3 = ">=" + r5 + "." + o4 + "." + i3 + s4 + " <" + r5 + "." + (+o4 + 1) + ".0") : a3 = ">=" + r5 + "." + o4 + "." + i3 + " <" + r5 + "." + (+o4 + 1) + ".0", n2("tilde return", a3), a3;
                  });
                }(e7, t5);
              }).join(" ");
            }(e5, t4), n2("tildes", e5), e5 = function(e6, t5) {
              return n2("replaceXRanges", e6, t5), e6.split(/\s+/).map(function(e7) {
                return function(e8, t6) {
                  e8 = e8.trim(), t6 && typeof t6 == "object" || (t6 = { loose: !!t6, includePrerelease: false });
                  var r4 = t6.loose ? i2[A] : i2[_];
                  return e8.replace(r4, function(t7, r5, o4, i3, s4, a3) {
                    n2("xRange", e8, t7, r5, o4, i3, s4, a3);
                    var c3 = ae(o4), u3 = c3 || ae(i3), l3 = u3 || ae(s4), f3 = l3;
                    return r5 === "=" && f3 && (r5 = ""), c3 ? t7 = r5 === ">" || r5 === "<" ? "<0.0.0" : "*" : r5 && f3 ? (u3 && (i3 = 0), l3 && (s4 = 0), r5 === ">" ? (r5 = ">=", u3 ? (o4 = +o4 + 1, i3 = 0, s4 = 0) : l3 && (i3 = +i3 + 1, s4 = 0)) : r5 === "<=" && (r5 = "<", u3 ? o4 = +o4 + 1 : i3 = +i3 + 1), t7 = r5 + o4 + "." + i3 + "." + s4) : u3 ? t7 = ">=" + o4 + ".0.0 <" + (+o4 + 1) + ".0.0" : l3 && (t7 = ">=" + o4 + "." + i3 + ".0 <" + o4 + "." + (+i3 + 1) + ".0"), n2("xRange return", t7), t7;
                  });
                }(e7, t5);
              }).join(" ");
            }(e5, t4), n2("xrange", e5), e5 = function(e6, t5) {
              return n2("replaceStars", e6, t5), e6.trim().replace(i2[U], "");
            }(e5, t4), n2("stars", e5), e5;
          }(e4, this.options);
        }, this).join(" ").split(/\s+/);
        return this.options.loose && (s3 = s3.filter(function(e4) {
          return !!e4.match(o3);
        })), s3 = s3.map(function(e4) {
          return new oe(e4, this.options);
        }, this);
      }, se.prototype.intersects = function(e3, t3) {
        if (!(e3 instanceof se))
          throw new TypeError("a Range is required");
        return this.set.some(function(n3) {
          return n3.every(function(n4) {
            return e3.set.some(function(e4) {
              return e4.every(function(e5) {
                return n4.intersects(e5, t3);
              });
            });
          });
        });
      }, t2.toComparators = function(e3, t3) {
        return new se(e3, t3).set.map(function(e4) {
          return e4.map(function(e5) {
            return e5.value;
          }).join(" ").trim().split(" ");
        });
      }, se.prototype.test = function(e3) {
        if (!e3)
          return false;
        typeof e3 == "string" && (e3 = new Y(e3, this.options));
        for (var t3 = 0; t3 < this.set.length; t3++)
          if (ue(this.set[t3], e3, this.options))
            return true;
        return false;
      }, t2.satisfies = le, t2.maxSatisfying = function(e3, t3, n3) {
        var r3 = null, o3 = null;
        try {
          var i3 = new se(t3, n3);
        } catch (e4) {
          return null;
        }
        return e3.forEach(function(e4) {
          i3.test(e4) && (r3 && o3.compare(e4) !== -1 || (o3 = new Y(r3 = e4, n3)));
        }), r3;
      }, t2.minSatisfying = function(e3, t3, n3) {
        var r3 = null, o3 = null;
        try {
          var i3 = new se(t3, n3);
        } catch (e4) {
          return null;
        }
        return e3.forEach(function(e4) {
          i3.test(e4) && (r3 && o3.compare(e4) !== 1 || (o3 = new Y(r3 = e4, n3)));
        }), r3;
      }, t2.validRange = function(e3, t3) {
        try {
          return new se(e3, t3).range || "*";
        } catch (e4) {
          return null;
        }
      }, t2.ltr = function(e3, t3, n3) {
        return fe(e3, t3, "<", n3);
      }, t2.gtr = function(e3, t3, n3) {
        return fe(e3, t3, ">", n3);
      }, t2.outside = fe, t2.prerelease = function(e3, t3) {
        var n3 = K(e3, t3);
        return n3 && n3.prerelease.length ? n3.prerelease : null;
      }, t2.intersects = function(e3, t3, n3) {
        return e3 = new se(e3, n3), t3 = new se(t3, n3), e3.intersects(t3);
      }, t2.coerce = function(e3) {
        if (e3 instanceof Y)
          return e3;
        if (typeof e3 != "string")
          return null;
        var t3 = e3.match(i2[k]);
        return t3 == null ? null : K((t3[1] || "0") + "." + (t3[2] || "0") + "." + (t3[3] || "0"));
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = process.platform === "win32";
      function o2(e3, t3) {
        return Object.assign(new Error(`${t3} ${e3.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${t3} ${e3.command}`, path: e3.command, spawnargs: e3.args });
      }
      function i2(e3, t3) {
        return r2 && e3 === 1 && !t3.file ? o2(t3.original, "spawn") : null;
      }
      e2.exports = { hookChildProcess: function(e3, t3) {
        if (!r2)
          return;
        const n3 = e3.emit;
        e3.emit = function(r3, o3) {
          if (r3 === "exit") {
            const r4 = i2(o3, t3);
            if (r4)
              return n3.call(e3, "error", r4);
          }
          return n3.apply(e3, arguments);
        };
      }, verifyENOENT: i2, verifyENOENTSync: function(e3, t3) {
        return r2 && e3 === 1 && !t3.file ? o2(t3.original, "spawnSync") : null;
      }, notFoundError: o2 };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function(e3) {
        var t3 = typeof e3 == "string" ? "\n" : "\n".charCodeAt(), n3 = typeof e3 == "string" ? "\r" : "\r".charCodeAt();
        return e3[e3.length - 1] === t3 && (e3 = e3.slice(0, e3.length - 1)), e3[e3.length - 1] === n3 && (e3 = e3.slice(0, e3.length - 1)), e3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(0), o2 = n2(77);
      e2.exports = (e3) => {
        let t3;
        e3 = Object.assign({ cwd: process.cwd(), path: process.env[o2()] }, e3);
        let n3 = r2.resolve(e3.cwd);
        const i2 = [];
        for (; t3 !== n3; )
          i2.push(r2.join(n3, "node_modules/.bin")), t3 = n3, n3 = r2.resolve(n3, "..");
        return i2.push(r2.dirname(process.execPath)), i2.concat(e3.path).join(r2.delimiter);
      }, e2.exports.env = (t3) => {
        t3 = Object.assign({ env: process.env }, t3);
        const n3 = Object.assign({}, t3.env), r3 = o2({ env: n3 });
        return t3.path = n3[r3], n3[r3] = e2.exports(t3), n3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = e2.exports = function(e3) {
        return e3 !== null && typeof e3 == "object" && typeof e3.pipe == "function";
      };
      r2.writable = function(e3) {
        return r2(e3) && e3.writable !== false && typeof e3._write == "function" && typeof e3._writableState == "object";
      }, r2.readable = function(e3) {
        return r2(e3) && e3.readable !== false && typeof e3._read == "function" && typeof e3._readableState == "object";
      }, r2.duplex = function(e3) {
        return r2.writable(e3) && r2.readable(e3);
      }, r2.transform = function(e3) {
        return r2.duplex(e3) && typeof e3._transform == "function" && typeof e3._transformState == "object";
      };
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(150), o2 = n2(152);
      class i2 extends Error {
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      }
      function s2(e3, t3) {
        if (!e3)
          return Promise.reject(new Error("Expected a stream"));
        t3 = Object.assign({ maxBuffer: 1 / 0 }, t3);
        const { maxBuffer: n3 } = t3;
        let s3;
        return new Promise((a2, c2) => {
          const u2 = (e4) => {
            e4 && (e4.bufferedData = s3.getBufferedValue()), c2(e4);
          };
          (s3 = r2(e3, o2(t3), (e4) => {
            e4 ? u2(e4) : a2();
          })).on("data", () => {
            s3.getBufferedLength() > n3 && u2(new i2());
          });
        }).then(() => s3.getBufferedValue());
      }
      e2.exports = s2, e2.exports.buffer = (e3, t3) => s2(e3, Object.assign({}, t3, { encoding: "buffer" })), e2.exports.array = (e3, t3) => s2(e3, Object.assign({}, t3, { array: true })), e2.exports.MaxBufferError = i2;
    }, function(e2, t2, n2) {
      var r2 = n2(31), o2 = n2(151), i2 = n2(5), s2 = function() {
      }, a2 = /^v?\.0/.test(process.version), c2 = function(e3) {
        return typeof e3 == "function";
      }, u2 = function(e3, t3, n3, u3) {
        u3 = r2(u3);
        var l3 = false;
        e3.on("close", function() {
          l3 = true;
        }), o2(e3, { readable: t3, writable: n3 }, function(e4) {
          if (e4)
            return u3(e4);
          l3 = true, u3();
        });
        var f3 = false;
        return function(t4) {
          if (!l3 && !f3)
            return f3 = true, function(e4) {
              return !!a2 && !!i2 && (e4 instanceof (i2.ReadStream || s2) || e4 instanceof (i2.WriteStream || s2)) && c2(e4.close);
            }(e3) ? e3.close(s2) : function(e4) {
              return e4.setHeader && c2(e4.abort);
            }(e3) ? e3.abort() : c2(e3.destroy) ? e3.destroy() : void u3(t4 || new Error("stream was destroyed"));
        };
      }, l2 = function(e3) {
        e3();
      }, f2 = function(e3, t3) {
        return e3.pipe(t3);
      };
      e2.exports = function() {
        var e3, t3 = Array.prototype.slice.call(arguments), n3 = c2(t3[t3.length - 1] || s2) && t3.pop() || s2;
        if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2)
          throw new Error("pump requires two streams per minimum");
        var r3 = t3.map(function(o3, i3) {
          var s3 = i3 < t3.length - 1;
          return u2(o3, s3, i3 > 0, function(t4) {
            e3 || (e3 = t4), t4 && r3.forEach(l2), s3 || (r3.forEach(l2), n3(e3));
          });
        });
        return t3.reduce(f2);
      };
    }, function(e2, t2, n2) {
      var r2 = n2(31), o2 = function() {
      }, i2 = function(e3, t3, n3) {
        if (typeof t3 == "function")
          return i2(e3, null, t3);
        t3 || (t3 = {}), n3 = r2(n3 || o2);
        var s2 = e3._writableState, a2 = e3._readableState, c2 = t3.readable || t3.readable !== false && e3.readable, u2 = t3.writable || t3.writable !== false && e3.writable, l2 = function() {
          e3.writable || f2();
        }, f2 = function() {
          u2 = false, c2 || n3.call(e3);
        }, p = function() {
          c2 = false, u2 || n3.call(e3);
        }, h = function(t4) {
          n3.call(e3, t4 ? new Error("exited with error code: " + t4) : null);
        }, d2 = function(t4) {
          n3.call(e3, t4);
        }, m = function() {
          return (!c2 || a2 && a2.ended) && (!u2 || s2 && s2.ended) ? void 0 : n3.call(e3, new Error("premature close"));
        }, g = function() {
          e3.req.on("finish", f2);
        };
        return !function(e4) {
          return e4.setHeader && typeof e4.abort == "function";
        }(e3) ? u2 && !s2 && (e3.on("end", l2), e3.on("close", l2)) : (e3.on("complete", f2), e3.on("abort", m), e3.req ? g() : e3.on("request", g)), function(e4) {
          return e4.stdio && Array.isArray(e4.stdio) && e4.stdio.length === 3;
        }(e3) && e3.on("exit", h), e3.on("end", p), e3.on("finish", f2), t3.error !== false && e3.on("error", d2), e3.on("close", m), function() {
          e3.removeListener("complete", f2), e3.removeListener("abort", m), e3.removeListener("request", g), e3.req && e3.req.removeListener("finish", f2), e3.removeListener("end", l2), e3.removeListener("close", l2), e3.removeListener("finish", f2), e3.removeListener("exit", h), e3.removeListener("end", p), e3.removeListener("error", d2), e3.removeListener("close", m);
        };
      };
      e2.exports = i2;
    }, function(e2, t2, n2) {
      "use strict";
      const { PassThrough: r2 } = n2(153);
      e2.exports = (e3) => {
        e3 = Object.assign({}, e3);
        const { array: t3 } = e3;
        let { encoding: n3 } = e3;
        const o2 = n3 === "buffer";
        let i2 = false;
        t3 ? i2 = !(n3 || o2) : n3 = n3 || "utf8", o2 && (n3 = null);
        let s2 = 0;
        const a2 = [], c2 = new r2({ objectMode: i2 });
        return n3 && c2.setEncoding(n3), c2.on("data", (e4) => {
          a2.push(e4), i2 ? s2 = a2.length : s2 += e4.length;
        }), c2.getBufferedValue = () => t3 ? a2 : o2 ? Buffer.concat(a2, s2) : a2.join(""), c2.getBufferedLength = () => s2, c2;
      };
    }, function(e2, t2) {
      e2.exports = (init_stream(), __toCommonJS(stream_exports));
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = (e3, t3) => (t3 = t3 || (() => {
      }), e3.then((e4) => new Promise((e5) => {
        e5(t3());
      }).then(() => e4), (e4) => new Promise((e5) => {
        e5(t3());
      }).then(() => {
        throw e4;
      })));
    }, function(e2, t2, n2) {
      var r2, o2 = n2(47), i2 = n2(156), s2 = n2(68);
      function a2() {
        l2 && (l2 = false, i2.forEach(function(e3) {
          try {
            process.removeListener(e3, u2[e3]);
          } catch (e4) {
          }
        }), process.emit = d2, process.reallyExit = p, r2.count -= 1);
      }
      function c2(e3, t3, n3) {
        r2.emitted[e3] || (r2.emitted[e3] = true, r2.emit(e3, t3, n3));
      }
      typeof s2 != "function" && (s2 = s2.EventEmitter), process.__signal_exit_emitter__ ? r2 = process.__signal_exit_emitter__ : ((r2 = process.__signal_exit_emitter__ = new s2()).count = 0, r2.emitted = {}), r2.infinite || (r2.setMaxListeners(1 / 0), r2.infinite = true), e2.exports = function(e3, t3) {
        o2.equal(typeof e3, "function", "a callback must be provided for exit handler"), l2 === false && f2();
        var n3 = "exit";
        t3 && t3.alwaysLast && (n3 = "afterexit");
        return r2.on(n3, e3), function() {
          r2.removeListener(n3, e3), r2.listeners("exit").length === 0 && r2.listeners("afterexit").length === 0 && a2();
        };
      }, e2.exports.unload = a2;
      var u2 = {};
      i2.forEach(function(e3) {
        u2[e3] = function() {
          process.listeners(e3).length === r2.count && (a2(), c2("exit", null, e3), c2("afterexit", null, e3), process.kill(process.pid, e3));
        };
      }), e2.exports.signals = function() {
        return i2;
      }, e2.exports.load = f2;
      var l2 = false;
      function f2() {
        l2 || (l2 = true, r2.count += 1, i2 = i2.filter(function(e3) {
          try {
            return process.on(e3, u2[e3]), true;
          } catch (e4) {
            return false;
          }
        }), process.emit = m, process.reallyExit = h);
      }
      var p = process.reallyExit;
      function h(e3) {
        process.exitCode = e3 || 0, c2("exit", process.exitCode, null), c2("afterexit", process.exitCode, null), p.call(process, process.exitCode);
      }
      var d2 = process.emit;
      function m(e3, t3) {
        if (e3 === "exit") {
          t3 !== void 0 && (process.exitCode = t3);
          var n3 = d2.apply(this, arguments);
          return c2("exit", process.exitCode, null), c2("afterexit", process.exitCode, null), n3;
        }
        return d2.apply(this, arguments);
      }
    }, function(e2, t2) {
      e2.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"], process.platform !== "win32" && e2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), process.platform === "linux" && e2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = n2(30);
      let o2;
      if (typeof r2.getSystemErrorName == "function")
        e2.exports = r2.getSystemErrorName;
      else {
        try {
          if (typeof (o2 = process.binding("uv")).errname != "function")
            throw new TypeError("uv.errname is not a function");
        } catch (e3) {
          console.error("execa/lib/errname: unable to establish process.binding('uv')", e3), o2 = null;
        }
        e2.exports = (e3) => i2(o2, e3);
      }
      function i2(e3, t3) {
        if (e3)
          return e3.errname(t3);
        if (!(t3 < 0))
          throw new Error("err >= 0");
        return `Unknown system error ${t3}`;
      }
      e2.exports.__test__ = i2;
    }, function(e2, t2, n2) {
      "use strict";
      const r2 = ["stdin", "stdout", "stderr"];
      e2.exports = (e3) => {
        if (!e3)
          return null;
        if (e3.stdio && ((e4) => r2.some((t4) => Boolean(e4[t4])))(e3))
          throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${r2.map((e4) => `\`${e4}\``).join(", ")}`);
        if (typeof e3.stdio == "string")
          return e3.stdio;
        const t3 = e3.stdio || [];
        if (!Array.isArray(t3))
          throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t3}\``);
        const n3 = [], o2 = Math.max(t3.length, r2.length);
        for (let i2 = 0; i2 < o2; i2++) {
          let o3 = null;
          t3[i2] !== void 0 ? o3 = t3[i2] : e3[r2[i2]] !== void 0 && (o3 = e3[r2[i2]]), n3[i2] = o3;
        }
        return n3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getBazelInfo: function() {
        return r2.log("trace", "getBazelInfo"), Promise.all([r2.run("bazel --version").then(r2.findVersion), r2.run("which bazel")]).then(function(e3) {
          return r2.determineFound("Bazel", e3[0], e3[1]);
        });
      }, getCMakeInfo: function() {
        return r2.log("trace", "getCMakeInfo"), Promise.all([r2.run("cmake --version").then(r2.findVersion), r2.run("which cmake")]).then(function(e3) {
          return r2.determineFound("CMake", e3[0], e3[1]);
        });
      }, getGCCInfo: function() {
        return r2.log("trace", "getGCCInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("gcc -v 2>&1").then(r2.findVersion), r2.run("which gcc")]).then(function(e3) {
          return r2.determineFound("GCC", e3[0], e3[1]);
        }) : Promise.resolve(["GCC", "N/A"]);
      }, getClangInfo: function() {
        return r2.log("trace", "getClangInfo"), Promise.all([r2.run("clang --version").then(r2.findVersion), r2.which("clang")]).then(function(e3) {
          return r2.determineFound("Clang", e3[0], e3[1]);
        });
      }, getGitInfo: function() {
        return r2.log("trace", "getGitInfo"), Promise.all([r2.run("git --version").then(r2.findVersion), r2.run("which git")]).then(function(e3) {
          return r2.determineFound("Git", e3[0], e3[1]);
        });
      }, getMakeInfo: function() {
        return r2.log("trace", "getMakeInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("make --version").then(r2.findVersion), r2.run("which make")]).then(function(e3) {
          return r2.determineFound("Make", e3[0], e3[1]);
        }) : Promise.resolve(["Make", "N/A"]);
      }, getNinjaInfo: function() {
        return r2.log("trace", "getNinjaInfo"), Promise.all([r2.run("ninja --version").then(r2.findVersion), r2.run("which ninja")]).then(function(e3) {
          return r2.determineFound("Ninja", e3[0], e3[1]);
        });
      }, getMercurialInfo: function() {
        return r2.log("trace", "getMercurialInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("hg --version").then(r2.findVersion), r2.run("which hg")]).then(function(e3) {
          return r2.determineFound("Mercurial", e3[0], e3[1]);
        }) : Promise.resolve(["Mercurial", "N/A"]);
      }, getSubversionInfo: function() {
        return r2.log("trace", "getSubversionInfo"), r2.isMacOS || r2.isLinux ? Promise.all([r2.run("svn --version").then(r2.findVersion), r2.run("which svn")]).then(function(e3) {
          return r2.determineFound("Subversion", e3[0], e3[1]);
        }) : Promise.resolve(["Subversion", "N/A"]);
      }, getFFmpegInfo: function() {
        return r2.log("trace", "getFFmpegInfo"), Promise.all([r2.run("ffmpeg -version").then(r2.findVersion), r2.which("ffmpeg")]).then(function(e3) {
          return r2.determineFound("FFmpeg", e3[0], e3[1]);
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(2);
      var r2 = n2(1);
      e2.exports = { getDockerInfo: function() {
        return r2.log("trace", "getDockerInfo"), Promise.all([r2.run("docker --version").then(r2.findVersion), r2.which("docker")]).then(function(e3) {
          return r2.determineFound("Docker", e3[0], e3[1]);
        });
      }, getParallelsInfo: function() {
        return r2.log("trace", "getParallelsInfo"), Promise.all([r2.run("prlctl --version").then(r2.findVersion), r2.which("prlctl")]).then(function(e3) {
          return r2.determineFound("Parallels", e3[0], e3[1]);
        });
      }, getVirtualBoxInfo: function() {
        return r2.log("trace", "getVirtualBoxInfo"), Promise.all([r2.run("vboxmanage --version").then(r2.findVersion), r2.which("vboxmanage")]).then(function(e3) {
          return r2.determineFound("VirtualBox", e3[0], e3[1]);
        });
      }, getVMwareFusionInfo: function() {
        return r2.log("trace", "getVMwareFusionInfo"), r2.getDarwinApplicationVersion("com.vmware.fusion").then(function(e3) {
          return r2.determineFound("VMWare Fusion", e3, "N/A");
        });
      } };
    }, function(e2, t2, n2) {
      "use strict";
      n2(162), n2(64), n2(22), n2(16), n2(21), n2(74);
      var r2 = n2(163), o2 = n2(1);
      function i2(e3, t3) {
        return o2.log("trace", "clean", e3), Object.keys(e3).reduce(function(n3, r3) {
          return !t3.showNotFound && e3[r3] === "Not Found" || e3[r3] === "N/A" || e3[r3] === void 0 || Object.keys(e3[r3]).length === 0 ? n3 : o2.isObject(e3[r3]) ? Object.values(e3[r3]).every(function(e4) {
            return e4 === "N/A" || !t3.showNotFound && e4 === "Not Found";
          }) ? n3 : Object.assign(n3, { [r3]: i2(e3[r3], t3) }) : Object.assign(n3, { [r3]: e3[r3] });
        }, {});
      }
      function s2(e3, t3) {
        o2.log("trace", "formatHeaders"), t3 || (t3 = { type: "underline" });
        var n3 = { underline: ["\x1B[4m", "\x1B[0m"] };
        return e3.slice().split("\n").map(function(e4) {
          if (e4.slice("-1") === ":") {
            var r3 = e4.match(/^[\s]*/g)[0];
            return `${r3}${n3[t3.type][0]}${e4.slice(r3.length)}${n3[t3.type][1]}`;
          }
          return e4;
        }).join("\n");
      }
      function a2(e3) {
        return o2.log("trace", "formatPackages"), e3.npmPackages ? Object.assign(e3, { npmPackages: Object.entries(e3.npmPackages || {}).reduce(function(e4, t3) {
          var n3 = t3[0], r3 = t3[1];
          if (r3 === "Not Found")
            return Object.assign(e4, { [n3]: r3 });
          var o3 = r3.wanted ? `${r3.wanted} =>` : "", i3 = Array.isArray(r3.installed) ? r3.installed.join(", ") : r3.installed, s3 = r3.duplicates ? `(${r3.duplicates.join(", ")})` : "";
          return Object.assign(e4, { [n3]: `${o3} ${i3} ${s3}` });
        }, {}) }) : e3;
      }
      function c2(e3, t3, n3) {
        return n3 || (n3 = { emptyMessage: "None" }), Array.isArray(t3) && (t3 = t3.length > 0 ? t3.join(", ") : n3.emptyMessage), { [e3]: t3 };
      }
      function u2(e3) {
        return o2.log("trace", "serializeArrays"), function e4(t3, n3) {
          return Object.entries(t3).reduce(function(t4, r3) {
            var i3 = r3[0], s3 = r3[1];
            return o2.isObject(s3) ? Object.assign(t4, { [i3]: e4(s3, n3) }) : Object.assign(t4, n3(i3, s3));
          }, {});
        }(e3, c2);
      }
      function l2(e3) {
        return o2.log("trace", "serializeVersionsAndPaths"), Object.entries(e3).reduce(function(e4, t3) {
          return Object.assign(e4, { [t3[0]]: Object.entries(t3[1]).reduce(function(e5, t4) {
            var n3 = t4[0], r3 = t4[1];
            return r3.version ? Object.assign(e5, { [n3]: [r3.version, r3.path].filter(Boolean).join(" - ") }) : Object.assign(e5, { [n3]: [r3][0] });
          }, {}) }, {});
        }, {});
      }
      function f2(e3) {
        return r2(e3, { indent: "  ", prefix: "\n", postfix: "\n" });
      }
      function p(e3) {
        return e3.slice().split("\n").map(function(e4) {
          if (e4 !== "") {
            var t3 = e4.slice("-1") === ":", n3 = e4.search(/\S|$/);
            return t3 ? `${"#".repeat(n3 / 2 + 1)} ` + e4.slice(n3) : " - " + e4.slice(n3);
          }
          return "";
        }).join("\n");
      }
      function h(e3, t3) {
        return t3 || (t3 = { indent: "  " }), JSON.stringify(e3, null, t3.indent);
      }
      e2.exports = { json: function(e3, t3) {
        return o2.log("trace", "formatToJson"), t3 || (t3 = {}), e3 = o2.pipe([function() {
          return i2(e3, t3);
        }, t3.title ? function(e4) {
          return { [t3.title]: e4 };
        } : o2.noop, h])(e3), e3 = t3.console ? `
${e3}
` : e3;
      }, markdown: function(e3, t3) {
        return o2.log("trace", "formatToMarkdown"), o2.pipe([function() {
          return i2(e3, t3);
        }, a2, u2, l2, f2, p, t3.title ? function(e4) {
          return `
# ${t3.title}${e4}`;
        } : o2.noop])(e3, t3);
      }, yaml: function(e3, t3) {
        return o2.log("trace", "formatToYaml", t3), o2.pipe([function() {
          return i2(e3, t3);
        }, a2, u2, l2, t3.title ? function(e4) {
          return { [t3.title]: e4 };
        } : o2.noop, f2, t3.console ? s2 : o2.noop])(e3, t3);
      } };
    }, function(e2, t2, n2) {
      n2(28)("search", 1, function(e3, t3, n3) {
        return [function(n4) {
          "use strict";
          var r2 = e3(this), o2 = n4 == null ? void 0 : n4[t3];
          return o2 !== void 0 ? o2.call(n4, r2) : new RegExp(n4)[t3](String(r2));
        }, n3];
      });
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(164), o2 = n2(165), i2 = n2(169), s2 = ["object", "array"];
      e2.exports = function(e3, t3) {
        var n3 = o2(t3), a2 = n3.colors, c2 = n3.prefix, u2 = n3.postfix, l2 = n3.dateToString, f2 = n3.errorToString, p = n3.indent, h = /* @__PURE__ */ new Map();
        function d2(e4) {
          var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, n4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (Object.keys(e4).length === 0)
            return " {}";
          var o3 = "\n", a3 = i2(t4, p);
          return Object.keys(e4).forEach(function(c3) {
            var u3 = e4[c3], l3 = r2(u3), f3 = i2(n4, "  "), p2 = s2.indexOf(l3) !== -1 ? "" : " ", h2 = v(u3) ? " [Circular]" : g(l3, u3, t4 + 1, n4);
            o3 += `${f3}${a3}${c3}:${p2}${h2}
`;
          }), o3.substring(0, o3.length - 1);
        }
        function m(e4) {
          var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, n4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (e4.length === 0)
            return " []";
          var o3 = "\n", s3 = i2(t4, p);
          return e4.forEach(function(e5) {
            var a3 = r2(e5), c3 = i2(n4, "  "), u3 = v(e5) ? "[Circular]" : g(a3, e5, t4, n4 + 1).toString().trimLeft();
            o3 += `${c3}${s3}- ${u3}
`;
          }), o3.substring(0, o3.length - 1);
        }
        function g(e4, t4, n4, r3) {
          switch (e4) {
            case "array":
              return m(t4, n4, r3);
            case "object":
              return d2(t4, n4, r3);
            case "string":
              return a2.string(t4);
            case "symbol":
              return a2.symbol(t4.toString());
            case "number":
              return a2.number(t4);
            case "boolean":
              return a2.boolean(t4);
            case "null":
              return a2.null("null");
            case "undefined":
              return a2.undefined("undefined");
            case "date":
              return a2.date(l2(t4));
            case "error":
              return a2.error(f2(t4));
            default:
              return t4 && t4.toString ? t4.toString() : Object.prototype.toString.call(t4);
          }
        }
        function v(e4) {
          return ["object", "array"].indexOf(r2(e4)) !== -1 && (!!h.has(e4) || (h.set(e4), false));
        }
        var y = "";
        return h.set(e3), r2(e3) === "object" && Object.keys(e3).length > 0 ? y = d2(e3) : r2(e3) === "array" && e3.length > 0 && (y = m(e3)), y.length === 0 ? "" : `${c2}${y.slice(1)}${u2}`;
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function(e3) {
        return Array.isArray(e3) ? "array" : e3 instanceof Date ? "date" : e3 instanceof Error ? "error" : e3 === null ? "null" : typeof e3 == "object" && Object.prototype.toString.call(e3) === "[object Object]" ? "object" : typeof e3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      var r2 = n2(166), o2 = n2(167), i2 = n2(168), s2 = " ", a2 = "\n", c2 = "";
      function u2(e3, t3) {
        return e3 === void 0 ? t3 : e3;
      }
      e2.exports = function() {
        var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return { indent: u2(e3.indent, s2), prefix: u2(e3.prefix, a2), postfix: u2(e3.postfix, c2), errorToString: e3.errorToString || r2, dateToString: e3.dateToString || o2, colors: Object.assign({}, i2, e3.colors) };
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function(e3) {
        return Error.prototype.toString.call(e3);
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function(e3) {
        return `new Date(${Date.prototype.toISOString.call(e3)})`;
      };
    }, function(e2, t2, n2) {
      "use strict";
      function r2(e3) {
        return e3;
      }
      e2.exports = { date: r2, error: r2, symbol: r2, string: r2, number: r2, boolean: r2, null: r2, undefined: r2 };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = function() {
        for (var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "  ", n3 = "", r2 = 0; r2 < e3; r2 += 1)
          n3 += t3;
        return n3;
      };
    }, function(e2, t2, n2) {
      "use strict";
      e2.exports = { defaults: { System: ["OS", "CPU", "Memory", "Container", "Shell"], Binaries: ["Node", "Yarn", "npm", "Watchman"], Managers: ["Apt", "Cargo", "CocoaPods", "Composer", "Gradle", "Homebrew", "Maven", "pip2", "pip3", "RubyGems", "Yum"], Utilities: ["Bazel", "CMake", "Make", "GCC", "Git", "Clang", "Ninja", "Mercurial", "Subversion", "FFmpeg"], Servers: ["Apache", "Nginx"], Virtualization: ["Docker", "Parallels", "VirtualBox", "VMware Fusion"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Atom", "Emacs", "IntelliJ", "NVim", "Nano", "PhpStorm", "Sublime Text", "VSCode", "Visual Studio", "Vim", "WebStorm", "Xcode"], Languages: ["Bash", "Go", "Elixir", "Erlang", "Java", "Perl", "PHP", "Protoc", "Python", "Python3", "R", "Ruby", "Rust", "Scala"], Databases: ["MongoDB", "MySQL", "PostgreSQL", "SQLite"], Browsers: ["Brave Browser", "Chrome", "Chrome Canary", "Chromium", "Edge", "Firefox", "Firefox Developer Edition", "Firefox Nightly", "Internet Explorer", "Safari", "Safari Technology Preview"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: null, npmGlobalPackages: null }, jest: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], npmPackages: ["jest"] }, "react-native": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "Watchman"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Xcode", "Visual Studio"], npmPackages: ["react", "react-native"], npmGlobalPackages: ["react-native-cli"] }, nyc: { System: ["OS", "CPU", "Memory"], Binaries: ["Node", "Yarn", "npm"], npmPackages: "/**/{*babel*,@babel/*/,*istanbul*,nyc,source-map-support,typescript,ts-node}" }, webpack: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], npmPackages: "*webpack*", npmGlobalPackages: ["webpack", "webpack-cli"] }, "styled-components": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], Browsers: ["Chrome", "Firefox", "Safari"], npmPackages: "*styled-components*" }, "create-react-app": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-dom", "react-scripts"], npmGlobalPackages: ["create-react-app"], options: { duplicates: true, showNotFound: true } }, apollo: { System: ["OS"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Firefox", "Safari"], npmPackages: "{*apollo*,@apollo/*}", npmGlobalPackages: "{*apollo*,@apollo/*}" }, "react-native-web": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-native-web"], options: { showNotFound: true } }, babel: { System: ["OS"], Binaries: ["Node", "npm", "Yarn"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: "{*babel*,@babel/*,eslint,webpack,create-react-app,react-native,lerna,jest}" }, playwright: { System: ["OS", "Memory", "Container"], Binaries: ["Node", "Yarn", "npm"], Languages: ["Bash"], npmPackages: "playwright*" } };
    }]);
  }
});

// node_modules/@vuepress/cli/lib/commands/info.js
var require_info = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/info.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.info = void 0;
    var utils_1 = require_lib();
    var envinfo = require_envinfo();
    var info = async () => {
      const spinner = (0, utils_1.ora)();
      spinner.start("Collecting Environment Info");
      const result = await envinfo.run({
        System: ["OS", "CPU", "Memory", "Shell"],
        Binaries: ["Node", "Yarn", "npm"],
        Utilities: ["Git"],
        Browsers: ["Chrome", "Edge", "Firefox", "Safari"],
        npmPackages: [
          "@vuepress/bundler-vite",
          "@vuepress/bundler-webpack",
          "@vuepress/cli",
          "@vuepress/client",
          "@vuepress/core",
          "@vuepress/markdown",
          "@vuepress/plugin-active-header-links",
          "@vuepress/plugin-back-to-top",
          "@vuepress/plugin-container",
          "@vuepress/plugin-docsearch",
          "@vuepress/plugin-external-link-icon",
          "@vuepress/plugin-git",
          "@vuepress/plugin-google-analytics",
          "@vuepress/plugin-medium-zoom",
          "@vuepress/plugin-nprogress",
          "@vuepress/plugin-palette",
          "@vuepress/plugin-prismjs",
          "@vuepress/plugin-pwa",
          "@vuepress/plugin-pwa-popup",
          "@vuepress/plugin-register-components",
          "@vuepress/plugin-search",
          "@vuepress/plugin-shiki",
          "@vuepress/plugin-theme-data",
          "@vuepress/plugin-toc",
          "@vuepress/shared",
          "@vuepress/theme-default",
          "@vuepress/utils",
          "vuepress",
          "vuepress-vite",
          "vuepress-webpack",
          "vue",
          "vue-router",
          "vue-loader"
        ]
      }, {
        showNotFound: true,
        duplicates: true,
        fullTree: true
      });
      spinner.stop();
      console.info(result);
    };
    exports2.info = info;
  }
});

// node_modules/@vuepress/cli/lib/commands/index.js
var require_commands = __commonJS({
  "node_modules/@vuepress/cli/lib/commands/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_build(), exports2);
    __exportStar(require_dev(), exports2);
    __exportStar(require_info(), exports2);
  }
});

// node_modules/cac/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/cac/dist/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events = (init_events(), __toCommonJS(events_exports));
    function toArr(any) {
      return any == null ? [] : Array.isArray(any) ? any : [any];
    }
    function toVal(out, key, val, opts) {
      var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
      out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
    }
    function mri2(args, opts) {
      args = args || [];
      opts = opts || {};
      var k, arr, arg, name, val, out = { _: [] };
      var i2 = 0, j = 0, idx = 0, len = args.length;
      const alibi = opts.alias !== void 0;
      const strict = opts.unknown !== void 0;
      const defaults = opts.default !== void 0;
      opts.alias = opts.alias || {};
      opts.string = toArr(opts.string);
      opts.boolean = toArr(opts.boolean);
      if (alibi) {
        for (k in opts.alias) {
          arr = opts.alias[k] = toArr(opts.alias[k]);
          for (i2 = 0; i2 < arr.length; i2++) {
            (opts.alias[arr[i2]] = arr.concat(k)).splice(i2, 1);
          }
        }
      }
      for (i2 = opts.boolean.length; i2-- > 0; ) {
        arr = opts.alias[opts.boolean[i2]] || [];
        for (j = arr.length; j-- > 0; )
          opts.boolean.push(arr[j]);
      }
      for (i2 = opts.string.length; i2-- > 0; ) {
        arr = opts.alias[opts.string[i2]] || [];
        for (j = arr.length; j-- > 0; )
          opts.string.push(arr[j]);
      }
      if (defaults) {
        for (k in opts.default) {
          name = typeof opts.default[k];
          arr = opts.alias[k] = opts.alias[k] || [];
          if (opts[name] !== void 0) {
            opts[name].push(k);
            for (i2 = 0; i2 < arr.length; i2++) {
              opts[name].push(arr[i2]);
            }
          }
        }
      }
      const keys = strict ? Object.keys(opts.alias) : [];
      for (i2 = 0; i2 < len; i2++) {
        arg = args[i2];
        if (arg === "--") {
          out._ = out._.concat(args.slice(++i2));
          break;
        }
        for (j = 0; j < arg.length; j++) {
          if (arg.charCodeAt(j) !== 45)
            break;
        }
        if (j === 0) {
          out._.push(arg);
        } else if (arg.substring(j, j + 3) === "no-") {
          name = arg.substring(j + 3);
          if (strict && !~keys.indexOf(name)) {
            return opts.unknown(arg);
          }
          out[name] = false;
        } else {
          for (idx = j + 1; idx < arg.length; idx++) {
            if (arg.charCodeAt(idx) === 61)
              break;
          }
          name = arg.substring(j, idx);
          val = arg.substring(++idx) || (i2 + 1 === len || ("" + args[i2 + 1]).charCodeAt(0) === 45 || args[++i2]);
          arr = j === 2 ? [name] : name;
          for (idx = 0; idx < arr.length; idx++) {
            name = arr[idx];
            if (strict && !~keys.indexOf(name))
              return opts.unknown("-".repeat(j) + name);
            toVal(out, name, idx + 1 < arr.length || val, opts);
          }
        }
      }
      if (defaults) {
        for (k in opts.default) {
          if (out[k] === void 0) {
            out[k] = opts.default[k];
          }
        }
      }
      if (alibi) {
        for (k in out) {
          arr = opts.alias[k] || [];
          while (arr.length > 0) {
            out[arr.shift()] = out[k];
          }
        }
      }
      return out;
    }
    var removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
    var findAllBrackets = (v) => {
      const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
      const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
      const res = [];
      const parse2 = (match) => {
        let variadic = false;
        let value = match[1];
        if (value.startsWith("...")) {
          value = value.slice(3);
          variadic = true;
        }
        return {
          required: match[0].startsWith("<"),
          value,
          variadic
        };
      };
      let angledMatch;
      while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
        res.push(parse2(angledMatch));
      }
      let squareMatch;
      while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
        res.push(parse2(squareMatch));
      }
      return res;
    };
    var getMriOptions = (options2) => {
      const result = { alias: {}, boolean: [] };
      for (const [index, option] of options2.entries()) {
        if (option.names.length > 1) {
          result.alias[option.names[0]] = option.names.slice(1);
        }
        if (option.isBoolean) {
          if (option.negated) {
            const hasStringTypeOption = options2.some((o2, i2) => {
              return i2 !== index && o2.names.some((name) => option.names.includes(name)) && typeof o2.required === "boolean";
            });
            if (!hasStringTypeOption) {
              result.boolean.push(option.names[0]);
            }
          } else {
            result.boolean.push(option.names[0]);
          }
        }
      }
      return result;
    };
    var findLongest = (arr) => {
      return arr.sort((a2, b2) => {
        return a2.length > b2.length ? -1 : 1;
      })[0];
    };
    var padRight = (str2, length) => {
      return str2.length >= length ? str2 : `${str2}${" ".repeat(length - str2.length)}`;
    };
    var camelcase = (input) => {
      return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
        return p1 + p2.toUpperCase();
      });
    };
    var setDotProp = (obj, keys, val) => {
      let i2 = 0;
      let length = keys.length;
      let t2 = obj;
      let x;
      for (; i2 < length; ++i2) {
        x = t2[keys[i2]];
        t2 = t2[keys[i2]] = i2 === length - 1 ? val : x != null ? x : !!~keys[i2 + 1].indexOf(".") || !(+keys[i2 + 1] > -1) ? {} : [];
      }
    };
    var setByType = (obj, transforms) => {
      for (const key of Object.keys(transforms)) {
        const transform = transforms[key];
        if (transform.shouldTransform) {
          obj[key] = Array.prototype.concat.call([], obj[key]);
          if (typeof transform.transformFunction === "function") {
            obj[key] = obj[key].map(transform.transformFunction);
          }
        }
      }
    };
    var getFileName = (input) => {
      const m = /([^\\\/]+)$/.exec(input);
      return m ? m[1] : "";
    };
    var camelcaseOptionName = (name) => {
      return name.split(".").map((v, i2) => {
        return i2 === 0 ? camelcase(v) : v;
      }).join(".");
    };
    var CACError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error(message).stack;
        }
      }
    };
    var Option = class {
      constructor(rawName, description, config) {
        this.rawName = rawName;
        this.description = description;
        this.config = Object.assign({}, config);
        rawName = rawName.replace(/\.\*/g, "");
        this.negated = false;
        this.names = removeBrackets(rawName).split(",").map((v) => {
          let name = v.trim().replace(/^-{1,2}/, "");
          if (name.startsWith("no-")) {
            this.negated = true;
            name = name.replace(/^no-/, "");
          }
          return camelcaseOptionName(name);
        }).sort((a2, b2) => a2.length > b2.length ? 1 : -1);
        this.name = this.names[this.names.length - 1];
        if (this.negated && this.config.default == null) {
          this.config.default = true;
        }
        if (rawName.includes("<")) {
          this.required = true;
        } else if (rawName.includes("[")) {
          this.required = false;
        } else {
          this.isBoolean = true;
        }
      }
    };
    var processArgs = process.argv;
    var platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
    var Command = class {
      constructor(rawName, description, config = {}, cli) {
        this.rawName = rawName;
        this.description = description;
        this.config = config;
        this.cli = cli;
        this.options = [];
        this.aliasNames = [];
        this.name = removeBrackets(rawName);
        this.args = findAllBrackets(rawName);
        this.examples = [];
      }
      usage(text) {
        this.usageText = text;
        return this;
      }
      allowUnknownOptions() {
        this.config.allowUnknownOptions = true;
        return this;
      }
      ignoreOptionDefaultValue() {
        this.config.ignoreOptionDefaultValue = true;
        return this;
      }
      version(version, customFlags = "-v, --version") {
        this.versionNumber = version;
        this.option(customFlags, "Display version number");
        return this;
      }
      example(example) {
        this.examples.push(example);
        return this;
      }
      option(rawName, description, config) {
        const option = new Option(rawName, description, config);
        this.options.push(option);
        return this;
      }
      alias(name) {
        this.aliasNames.push(name);
        return this;
      }
      action(callback) {
        this.commandAction = callback;
        return this;
      }
      isMatched(name) {
        return this.name === name || this.aliasNames.includes(name);
      }
      get isDefaultCommand() {
        return this.name === "" || this.aliasNames.includes("!");
      }
      get isGlobalCommand() {
        return this instanceof GlobalCommand;
      }
      hasOption(name) {
        name = name.split(".")[0];
        return this.options.find((option) => {
          return option.names.includes(name);
        });
      }
      outputHelp() {
        const { name, commands } = this.cli;
        const {
          versionNumber,
          options: globalOptions,
          helpCallback
        } = this.cli.globalCommand;
        let sections = [
          {
            body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
          }
        ];
        sections.push({
          title: "Usage",
          body: `  $ ${name} ${this.usageText || this.rawName}`
        });
        const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
        if (showCommands) {
          const longestCommandName = findLongest(commands.map((command) => command.rawName));
          sections.push({
            title: "Commands",
            body: commands.map((command) => {
              return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
            }).join("\n")
          });
          sections.push({
            title: `For more info, run any command with the \`--help\` flag`,
            body: commands.map((command) => `  $ ${name}${command.name === "" ? "" : ` ${command.name}`} --help`).join("\n")
          });
        }
        let options2 = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
        if (!this.isGlobalCommand && !this.isDefaultCommand) {
          options2 = options2.filter((option) => option.name !== "version");
        }
        if (options2.length > 0) {
          const longestOptionName = findLongest(options2.map((option) => option.rawName));
          sections.push({
            title: "Options",
            body: options2.map((option) => {
              return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === void 0 ? "" : `(default: ${option.config.default})`}`;
            }).join("\n")
          });
        }
        if (this.examples.length > 0) {
          sections.push({
            title: "Examples",
            body: this.examples.map((example) => {
              if (typeof example === "function") {
                return example(name);
              }
              return example;
            }).join("\n")
          });
        }
        if (helpCallback) {
          sections = helpCallback(sections) || sections;
        }
        console.log(sections.map((section) => {
          return section.title ? `${section.title}:
${section.body}` : section.body;
        }).join("\n\n"));
      }
      outputVersion() {
        const { name } = this.cli;
        const { versionNumber } = this.cli.globalCommand;
        if (versionNumber) {
          console.log(`${name}/${versionNumber} ${platformInfo}`);
        }
      }
      checkRequiredArgs() {
        const minimalArgsCount = this.args.filter((arg) => arg.required).length;
        if (this.cli.args.length < minimalArgsCount) {
          throw new CACError(`missing required args for command \`${this.rawName}\``);
        }
      }
      checkUnknownOptions() {
        const { options: options2, globalCommand } = this.cli;
        if (!this.config.allowUnknownOptions) {
          for (const name of Object.keys(options2)) {
            if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
              throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
            }
          }
        }
      }
      checkOptionValue() {
        const { options: parsedOptions, globalCommand } = this.cli;
        const options2 = [...globalCommand.options, ...this.options];
        for (const option of options2) {
          const value = parsedOptions[option.name.split(".")[0]];
          if (option.required) {
            const hasNegated = options2.some((o2) => o2.negated && o2.names.includes(option.name));
            if (value === true || value === false && !hasNegated) {
              throw new CACError(`option \`${option.rawName}\` value is missing`);
            }
          }
        }
      }
    };
    var GlobalCommand = class extends Command {
      constructor(cli) {
        super("@@global@@", "", {}, cli);
      }
    };
    var __assign = Object.assign;
    var CAC = class extends events.EventEmitter {
      constructor(name = "") {
        super();
        this.name = name;
        this.commands = [];
        this.rawArgs = [];
        this.args = [];
        this.options = {};
        this.globalCommand = new GlobalCommand(this);
        this.globalCommand.usage("<command> [options]");
      }
      usage(text) {
        this.globalCommand.usage(text);
        return this;
      }
      command(rawName, description, config) {
        const command = new Command(rawName, description || "", config, this);
        command.globalCommand = this.globalCommand;
        this.commands.push(command);
        return command;
      }
      option(rawName, description, config) {
        this.globalCommand.option(rawName, description, config);
        return this;
      }
      help(callback) {
        this.globalCommand.option("-h, --help", "Display this message");
        this.globalCommand.helpCallback = callback;
        this.showHelpOnExit = true;
        return this;
      }
      version(version, customFlags = "-v, --version") {
        this.globalCommand.version(version, customFlags);
        this.showVersionOnExit = true;
        return this;
      }
      example(example) {
        this.globalCommand.example(example);
        return this;
      }
      outputHelp() {
        if (this.matchedCommand) {
          this.matchedCommand.outputHelp();
        } else {
          this.globalCommand.outputHelp();
        }
      }
      outputVersion() {
        this.globalCommand.outputVersion();
      }
      setParsedInfo({ args, options: options2 }, matchedCommand, matchedCommandName) {
        this.args = args;
        this.options = options2;
        if (matchedCommand) {
          this.matchedCommand = matchedCommand;
        }
        if (matchedCommandName) {
          this.matchedCommandName = matchedCommandName;
        }
        return this;
      }
      unsetMatchedCommand() {
        this.matchedCommand = void 0;
        this.matchedCommandName = void 0;
      }
      parse(argv = processArgs, {
        run = true
      } = {}) {
        this.rawArgs = argv;
        if (!this.name) {
          this.name = argv[1] ? getFileName(argv[1]) : "cli";
        }
        let shouldParse = true;
        for (const command of this.commands) {
          const parsed = this.mri(argv.slice(2), command);
          const commandName = parsed.args[0];
          if (command.isMatched(commandName)) {
            shouldParse = false;
            const parsedInfo = __assign(__assign({}, parsed), {
              args: parsed.args.slice(1)
            });
            this.setParsedInfo(parsedInfo, command, commandName);
            this.emit(`command:${commandName}`, command);
          }
        }
        if (shouldParse) {
          for (const command of this.commands) {
            if (command.name === "") {
              shouldParse = false;
              const parsed = this.mri(argv.slice(2), command);
              this.setParsedInfo(parsed, command);
              this.emit(`command:!`, command);
            }
          }
        }
        if (shouldParse) {
          const parsed = this.mri(argv.slice(2));
          this.setParsedInfo(parsed);
        }
        if (this.options.help && this.showHelpOnExit) {
          this.outputHelp();
          run = false;
          this.unsetMatchedCommand();
        }
        if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
          this.outputVersion();
          run = false;
          this.unsetMatchedCommand();
        }
        const parsedArgv = { args: this.args, options: this.options };
        if (run) {
          this.runMatchedCommand();
        }
        if (!this.matchedCommand && this.args[0]) {
          this.emit("command:*");
        }
        return parsedArgv;
      }
      mri(argv, command) {
        const cliOptions = [
          ...this.globalCommand.options,
          ...command ? command.options : []
        ];
        const mriOptions = getMriOptions(cliOptions);
        let argsAfterDoubleDashes = [];
        const doubleDashesIndex = argv.indexOf("--");
        if (doubleDashesIndex > -1) {
          argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
          argv = argv.slice(0, doubleDashesIndex);
        }
        let parsed = mri2(argv, mriOptions);
        parsed = Object.keys(parsed).reduce((res, name) => {
          return __assign(__assign({}, res), {
            [camelcaseOptionName(name)]: parsed[name]
          });
        }, { _: [] });
        const args = parsed._;
        const options2 = {
          "--": argsAfterDoubleDashes
        };
        const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
        let transforms = /* @__PURE__ */ Object.create(null);
        for (const cliOption of cliOptions) {
          if (!ignoreDefault && cliOption.config.default !== void 0) {
            for (const name of cliOption.names) {
              options2[name] = cliOption.config.default;
            }
          }
          if (Array.isArray(cliOption.config.type)) {
            if (transforms[cliOption.name] === void 0) {
              transforms[cliOption.name] = /* @__PURE__ */ Object.create(null);
              transforms[cliOption.name]["shouldTransform"] = true;
              transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
            }
          }
        }
        for (const key of Object.keys(parsed)) {
          if (key !== "_") {
            const keys = key.split(".");
            setDotProp(options2, keys, parsed[key]);
            setByType(options2, transforms);
          }
        }
        return {
          args,
          options: options2
        };
      }
      runMatchedCommand() {
        const { args, options: options2, matchedCommand: command } = this;
        if (!command || !command.commandAction)
          return;
        command.checkUnknownOptions();
        command.checkOptionValue();
        command.checkRequiredArgs();
        const actionArgs = [];
        command.args.forEach((arg, index) => {
          if (arg.variadic) {
            actionArgs.push(args.slice(index));
          } else {
            actionArgs.push(args[index]);
          }
        });
        actionArgs.push(options2);
        return command.commandAction.apply(this, actionArgs);
      }
    };
    var cac = (name = "") => new CAC(name);
    exports2.CAC = CAC;
    exports2.Command = Command;
    exports2.cac = cac;
    exports2.default = cac;
  }
});

// node_modules/cac/index-compat.js
var require_index_compat = __commonJS({
  "node_modules/cac/index-compat.js"(exports2, module2) {
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var { cac, CAC, Command } = require_dist2();
    module2.exports = cac;
    Object.assign(module2.exports, {
      default: cac,
      cac,
      CAC,
      Command
    });
  }
});

// node_modules/@vuepress/cli/package.json
var require_package2 = __commonJS({
  "node_modules/@vuepress/cli/package.json"(exports2, module2) {
    module2.exports = {
      name: "@vuepress/cli",
      version: "2.0.0-beta.46",
      description: "CLI package of VuePress",
      keywords: [
        "vuepress",
        "cli"
      ],
      homepage: "https://github.com/vuepress",
      bugs: {
        url: "https://github.com/vuepress/vuepress-next/issues"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/vuepress/vuepress-next.git"
      },
      license: "MIT",
      author: "meteorlxy",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      bin: {
        "vuepress-cli": "bin/vuepress.js"
      },
      files: [
        "bin",
        "lib"
      ],
      dependencies: {
        "@vuepress/core": "2.0.0-beta.46",
        "@vuepress/shared": "2.0.0-beta.46",
        "@vuepress/utils": "2.0.0-beta.46",
        cac: "^6.7.12",
        chokidar: "^3.5.3",
        envinfo: "^7.8.1",
        esbuild: "^0.14.39"
      },
      devDependencies: {
        "@types/envinfo": "^7.8.1"
      },
      publishConfig: {
        access: "public"
      },
      scripts: {
        build: "tsc -b tsconfig.build.json",
        clean: "rimraf lib *.tsbuildinfo"
      }
    };
  }
});

// node_modules/@vuepress/cli/lib/cli.js
var require_cli = __commonJS({
  "node_modules/@vuepress/cli/lib/cli.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cli = void 0;
    var utils_1 = require_lib();
    var cac_1 = require_index_compat();
    var commands_1 = require_commands();
    var utils_2 = require_utils5();
    var wrapCommand = (cmd) => {
      const wrappedCommand = (...args) => cmd(...args).catch((err) => {
        console.error(utils_1.chalk.red(err.stack));
        process.exit(1);
      });
      return wrappedCommand;
    };
    var cli = (defaultAppConfig = {}) => {
      (0, utils_2.allowTs)();
      const program = (0, cac_1.cac)("vuepress");
      const versionCli = require_package2().version;
      const versionCore = require_package().version;
      program.version(`core@${versionCore} vuepress/cli@${versionCli}`);
      program.help();
      program.command("dev [sourceDir]", "Start development server").option("-c, --config <config>", "Set path to config file").option("-p, --port <port>", "Use specified port (default: 8080)").option("-t, --temp <temp>", "Set the directory of the temporary files").option("--host <host>", "Use specified host (default: 0.0.0.0)").option("--cache <cache>", "Set the directory of the cache files").option("--clean-temp", "Clean the temporary files before dev").option("--clean-cache", "Clean the cache files before dev").option("--open", "Open browser when ready").option("--debug", "Enable debug mode").option("--no-watch", "Disable watching page and config files").action(wrapCommand((0, commands_1.createDev)(defaultAppConfig)));
      program.command("build [sourceDir]", "Build to static site").option("-c, --config <config>", "Set path to config file").option("-d, --dest <dest>", "Set the directory build output (default: .vuepress/dist)").option("-t, --temp <temp>", "Set the directory of the temporary files").option("--cache <cache>", "Set the directory of the cache files").option("--clean-temp", "Clean the temporary files before build").option("--clean-cache", "Clean the cache files before build").option("--debug", "Enable debug mode").action(wrapCommand((0, commands_1.createBuild)(defaultAppConfig)));
      program.command("info", "Display environment information").action(wrapCommand(commands_1.info));
      program.parse(process.argv);
    };
    exports2.cli = cli;
  }
});

// node_modules/@vuepress/cli/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@vuepress/cli/lib/index.js"(exports2) {
    "use strict";
    init_define_EXTERNAL_LINK_ICON_LOCALES();
    init_define_MZ_ZOOM_OPTIONS();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_commands(), exports2);
    __exportStar(require_config(), exports2);
    __exportStar(require_cli(), exports2);
    __exportStar(require_utils5(), exports2);
  }
});

// dep:@vuepress_cli
init_define_EXTERNAL_LINK_ICON_LOCALES();
init_define_MZ_ZOOM_OPTIONS();
var vuepress_cli_default = require_lib5();
export {
  vuepress_cli_default as default
};
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=@vuepress_cli.js.map
